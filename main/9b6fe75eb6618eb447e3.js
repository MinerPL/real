(this.webpackChunkdiscord_app = this.webpackChunkdiscord_app || []).push([
    ["48449"], {
        662697: function(e, t, n) {
            let i = {};
            i.isSafari = function() {
                var e, t, n;
                return (null === (e = navigator) || void 0 === e ? void 0 : e.vendor) && (null === (n = navigator) || void 0 === n ? void 0 : null === (t = n.vendor) || void 0 === t ? void 0 : t.indexOf("Apple")) > -1 && navigator.userAgent && -1 == navigator.userAgent.indexOf("CriOS") && -1 == navigator.userAgent.indexOf("FxiOS")
            }, i.isMobile = function() {
                var e, t;
                let n = navigator.userAgent || (null === (e = navigator) || void 0 === e ? void 0 : e.vendor) || (null === (t = window) || void 0 === t ? void 0 : t.opera);
                return /iPhone|iPad|iPod|Android|IEMobile|Windows Phone|BlackBerry|webOS|Opera Mini|Nexus 7|Nexus 10|KFAPWI/i.test(n) || /(android|bb\d+|meego).+mobile|avantgo|bada\/|blackberry|blazer|compal|elaine|fennec|hiptop|iemobile|ip(hone|od)|iris|kindle|lge |maemo|midp|mmp|mobile.+firefox|netfront|opera m(ob|in)i|palm( os)?|phone|p(ixi|re)\/|plucker|pocket|psp|series(4|6)0|symbian|treo|up\.(browser|link)|vodafone|wap|windows ce|xda|xiino/i.test(n) || /1207|6310|6590|3gso|4thp|50[1-6]i|770s|802s|a wa|abac|ac(er|oo|s\-)|ai(ko|rn)|al(av|ca|co)|amoi|an(ex|ny|yw)|aptu|ar(ch|go)|as(te|us)|attw|au(di|\-m|r |s )|avan|be(ck|ll|nq)|bi(lb|rd)|bl(ac|az)|br(e|v)w|bumb|bw\-(n|u)|c55\/|capi|ccwa|cdm\-|cell|chtm|cldc|cmd\-|co(mp|nd)|craw|da(it|ll|ng)|dbte|dc\-s|devi|dica|dmob|do(c|p)o|ds(12|\-d)|el(49|ai)|em(l2|ul)|er(ic|k0)|esl8|ez([4-7]0|os|wa|ze)|fetc|fly(\-|_)|g1 u|g560|gene|gf\-5|g\-mo|go(\.w|od)|gr(ad|un)|haie|hcit|hd\-(m|p|t)|hei\-|hi(pt|ta)|hp( i|ip)|hs\-c|ht(c(\-| |_|a|g|p|s|t)|tp)|hu(aw|tc)|i\-(20|go|ma)|i230|iac( |\-|\/)|ibro|idea|ig01|ikom|im1k|inno|ipaq|iris|ja(t|v)a|jbro|jemu|jigs|kddi|keji|kgt( |\/)|klon|kpt |kwc\-|kyo(c|k)|le(no|xi)|lg( g|\/(k|l|u)|50|54|\-[a-w])|libw|lynx|m1\-w|m3ga|m50\/|ma(te|ui|xo)|mc(01|21|ca)|m\-cr|me(rc|ri)|mi(o8|oa|ts)|mmef|mo(01|02|bi|de|do|t(\-| |o|v)|zz)|mt(50|p1|v )|mwbp|mywa|n10[0-2]|n20[2-3]|n30(0|2)|n50(0|2|5)|n7(0(0|1)|10)|ne((c|m)\-|on|tf|wf|wg|wt)|nok(6|i)|nzph|o2im|op(ti|wv)|oran|owg1|p800|pan(a|d|t)|pdxg|pg(13|\-([1-8]|c))|phil|pire|pl(ay|uc)|pn\-2|po(ck|rt|se)|prox|psio|pt\-g|qa\-a|qc(07|12|21|32|60|\-[2-7]|i\-)|qtek|r380|r600|raks|rim9|ro(ve|zo)|s55\/|sa(ge|ma|mm|ms|ny|va)|sc(01|h\-|oo|p\-)|sdk\/|se(c(\-|0|1)|47|mc|nd|ri)|sgh\-|shar|sie(\-|m)|sk\-0|sl(45|id)|sm(al|ar|b3|it|t5)|so(ft|ny)|sp(01|h\-|v\-|v )|sy(01|mb)|t2(18|50)|t6(00|10|18)|ta(gt|lk)|tcl\-|tdg\-|tel(i|m)|tim\-|t\-mo|to(pl|sh)|ts(70|m\-|m3|m5)|tx\-9|up(\.b|g1|si)|utst|v400|v750|veri|vi(rg|te)|vk(40|5[0-3]|\-v)|vm40|voda|vulc|vx(52|53|60|61|70|80|81|83|85|98)|w3c(\-| )|webc|whit|wi(g |nc|nw)|wmlb|wonu|x700|yas\-|your|zeto|zte\-/i.test(n.substr(0, 4))
            }, e.exports = function() {
                return !(0, i.isSafari)() && !(0, i.isMobile)()
            }
        },
        194175: function(e, t, n) {
            "use strict";
            e.exports = n.p + "f8a931382dfd43511663.png"
        },
        35024: function(e, t, n) {
            "use strict";
            e.exports = n.p + "27b152e2ddb3acb76a92.svg"
        },
        159142: function(e, t, n) {
            "use strict";
            e.exports = n.p + "00c76084e1093f9ea889.png"
        },
        671223: function(e, t, n) {
            "use strict";
            e.exports = n.p + "e549d55ee6158479e2de.svg"
        },
        211689: function(e, t, n) {
            "use strict";
            e.exports = n.p + "342f1fa88c1e9eb7d685.png"
        },
        350043: function(e, t, n) {
            "use strict";
            e.exports = n.p + "bd96553546da26a4c70b.svg"
        },
        698833: function(e, t, n) {
            "use strict";
            e.exports = n.p + "bd96553546da26a4c70b.svg"
        },
        14366: function(e, t, n) {
            "use strict";
            e.exports = n.p + "a0eec7ce800d5e8f7a7c.png"
        },
        286611: function(e, t, n) {
            "use strict";
            e.exports = n.p + "1aee697591ca8309583c.svg"
        },
        994873: function(e, t, n) {
            "use strict";
            e.exports = n.p + "62fcac729728135080d2.png"
        },
        376998: function(e, t, n) {
            "use strict";
            e.exports = n.p + "8cef483d85d7337d2a62.svg"
        },
        396128: function(e, t, n) {
            "use strict";
            e.exports = n.p + "4dd44f1f2d9d4be0cc63.png"
        },
        497894: function(e, t, n) {
            "use strict";
            e.exports = n.p + "f22d0f157e5b64710577.svg"
        },
        1308: function(e, t, n) {
            "use strict";
            e.exports = n.p + "0445c89ecb480f2a1a55.png"
        },
        746621: function(e, t, n) {
            "use strict";
            e.exports = n.p + "9993a343c4facfd14f9f.svg"
        },
        879157: function(e, t, n) {
            "use strict";
            e.exports = n.p + "35c3598bd9942c1025a7.png"
        },
        870064: function(e, t, n) {
            "use strict";
            e.exports = n.p + "dacb3f3794eb5252e56f.svg"
        },
        259168: function(e, t, n) {
            "use strict";
            e.exports = n.p + "f217682409870bbd0836.png"
        },
        735638: function(e, t, n) {
            "use strict";
            e.exports = n.p + "bc893c6d474bc13bf8a4.svg"
        },
        321223: function(e, t, n) {
            "use strict";
            e.exports = n.p + "a7abeaf389161e8af518.png"
        },
        94470: function(e, t, n) {
            "use strict";
            e.exports = n.p + "5617849b51454655bcf1.svg"
        },
        646994: function(e, t, n) {
            "use strict";
            e.exports = n.p + "2ba3f6ae083c107778b8.png"
        },
        375518: function(e, t, n) {
            "use strict";
            e.exports = n.p + "767d18d4d02d9a2e1ab1.svg"
        },
        299059: function(e, t, n) {
            "use strict";
            e.exports = n.p + "1ea986c64731860da168.png"
        },
        496955: function(e, t, n) {
            "use strict";
            e.exports = n.p + "ec048b4bbcf47d45c7f6.svg"
        },
        612315: function(e, t, n) {
            "use strict";
            e.exports = n.p + "589bcc78c02a11c07b3b.png"
        },
        152071: function(e, t, n) {
            "use strict";
            e.exports = n.p + "f330962c0eb993878478.svg"
        },
        530354: function(e, t, n) {
            "use strict";
            e.exports = n.p + "c4707432ef3414ccffd3.png"
        },
        667083: function(e, t, n) {
            "use strict";
            e.exports = n.p + "4d004ea91b2a1cd534cf.svg"
        },
        925382: function(e, t, n) {
            "use strict";
            e.exports = n.p + "c1637fa995b3054b92c1.png"
        },
        509949: function(e, t, n) {
            "use strict";
            e.exports = n.p + "a63af69b0b1958fabf1a.svg"
        },
        347775: function(e, t, n) {
            "use strict";
            e.exports = n.p + "993cc4012ce9f9b8e83f.png"
        },
        524855: function(e, t, n) {
            "use strict";
            e.exports = n.p + "c44f32fe60d6657fda9f.svg"
        },
        770624: function(e, t, n) {
            "use strict";
            e.exports = n.p + "d94334b9983e676643d1.png"
        },
        209560: function(e, t, n) {
            "use strict";
            e.exports = n.p + "dcd6afd78d21cd3980ab.svg"
        },
        322246: function(e, t, n) {
            "use strict";
            e.exports = n.p + "18e328090e441ee508bb.png"
        },
        154849: function(e, t, n) {
            "use strict";
            e.exports = n.p + "1b0b60300e4f234337be.svg"
        },
        964854: function(e, t, n) {
            "use strict";
            e.exports = n.p + "fa615b5c168c88e54a15.png"
        },
        895661: function(e, t, n) {
            "use strict";
            e.exports = n.p + "75577d21ad1497348a3c.svg"
        },
        373338: function(e, t, n) {
            "use strict";
            e.exports = n.p + "c6833beabfb84014185b.png"
        },
        977001: function(e, t, n) {
            "use strict";
            e.exports = n.p + "cc912bf56af0fd3bc301.svg"
        },
        479111: function(e, t, n) {
            "use strict";
            e.exports = n.p + "7ed3c5a97238a23cb662.png"
        },
        592466: function(e, t, n) {
            "use strict";
            e.exports = n.p + "9210accea56102b27039.svg"
        },
        300525: function(e, t, n) {
            "use strict";
            e.exports = n.p + "7886764ea4a20e975460.png"
        },
        704777: function(e, t, n) {
            "use strict";
            e.exports = n.p + "d521f9c27b53f7a779e6.svg"
        },
        501653: function(e, t, n) {
            "use strict";
            e.exports = n.p + "982cb6e35a9ac7fdd64b.png"
        },
        940593: function(e, t, n) {
            "use strict";
            e.exports = n.p + "2794bf75be23707f7947.svg"
        },
        768935: function(e, t, n) {
            "use strict";
            e.exports = n.p + "a68ff7e6034b896c58db.png"
        },
        869872: function(e, t, n) {
            "use strict";
            e.exports = n.p + "2eed3033a8780ccf636f.svg"
        },
        629132: function(e, t, n) {
            "use strict";
            e.exports = n.p + "168e981f36abde84b10d.png"
        },
        301098: function(e, t, n) {
            "use strict";
            e.exports = n.p + "d76473a750af3dce43b9.svg"
        },
        992221: function(e, t, n) {
            "use strict";
            e.exports = n.p + "98e6b7218970562d1ce0.png"
        },
        894025: function(e, t, n) {
            "use strict";
            e.exports = n.p + "603007783abe09a10ae5.svg"
        },
        731368: function(e, t, n) {
            "use strict";
            e.exports = n.p + "32bba0abbf7d086814d2.png"
        },
        645496: function(e, t, n) {
            "use strict";
            e.exports = n.p + "9ee6d9ab5420113bca0b.svg"
        },
        561050: function(e, t, n) {
            "use strict";
            e.exports = n.p + "626f7ddce038206bd639.png"
        },
        630528: function(e, t, n) {
            "use strict";
            e.exports = n.p + "7231645d01e0b14f58cc.svg"
        },
        618077: function(e, t, n) {
            "use strict";
            e.exports = n.p + "16085d3c07fa01281190.png"
        },
        662418: function(e, t, n) {
            "use strict";
            e.exports = n.p + "31076feac041da4dd070.svg"
        },
        777626: function(e, t, n) {
            "use strict";
            e.exports = n.p + "07e1a53bc84c6231f92f.png"
        },
        566035: function(e, t, n) {
            "use strict";
            e.exports = n.p + "d46756f782e19355e483.svg"
        },
        877414: function(e, t, n) {
            "use strict";
            e.exports = n.p + "46ab48b39d1fc32713b8.png"
        },
        309663: function(e, t, n) {
            "use strict";
            e.exports = n.p + "100f3a82bf746402d6ac.svg"
        },
        196135: function(e, t, n) {
            "use strict";
            e.exports = n.p + "1a0c571e8d650ca3f54f.png"
        },
        793866: function(e, t, n) {
            "use strict";
            e.exports = n.p + "822dc9e43f7ee79edd0e.svg"
        },
        482311: function(e, t, n) {
            "use strict";
            e.exports = n.p + "bb3d1d12d5e2ce557119.png"
        },
        204844: function(e, t, n) {
            "use strict";
            e.exports = n.p + "715a8b0f690da5b34fbb.svg"
        },
        115658: function(e, t, n) {
            "use strict";
            e.exports = n.p + "30c4ac099a8b53735946.png"
        },
        729332: function(e, t, n) {
            "use strict";
            e.exports = n.p + "7ccb5f56c32c63e01c04.svg"
        },
        288589: function(e, t, n) {
            "use strict";
            e.exports = n.p + "86bda9e409f43d56e197.png"
        },
        31439: function(e, t, n) {
            "use strict";
            e.exports = n.p + "a675673d2271538be738.svg"
        },
        122630: function(e, t, n) {
            "use strict";
            e.exports = n.p + "6302c9d4ad9d5c4a3376.png"
        },
        372786: function(e, t, n) {
            "use strict";
            e.exports = n.p + "57a3fe2c0e62e98937fd.svg"
        },
        961232: function(e, t, n) {
            "use strict";
            e.exports = n.p + "ad2246e21de708819ad4.png"
        },
        387628: function(e, t, n) {
            "use strict";
            e.exports = n.p + "6f0eed9e1276f69c9127.svg"
        },
        980576: function(e, t, n) {
            "use strict";
            e.exports = n.p + "59e8df9657fe6fc725dc.png"
        },
        552995: function(e, t, n) {
            "use strict";
            e.exports = n.p + "f47485602365c946fa52.svg"
        },
        483819: function(e, t, n) {
            "use strict";
            e.exports = n.p + "f8d31171246dfaf90b12.png"
        },
        955307: function(e, t, n) {
            "use strict";
            e.exports = n.p + "cc52988849f86e1c85f5.svg"
        },
        192473: function(e, t, n) {
            "use strict";
            e.exports = n.p + "59e8df9657fe6fc725dc.png"
        },
        312139: function(e, t, n) {
            "use strict";
            e.exports = n.p + "f47485602365c946fa52.svg"
        },
        272378: function(e, t, n) {
            "use strict";
            e.exports = n.p + "9a15d086141be29d9fcd.png"
        },
        599004: function(e, t, n) {
            "use strict";
            e.exports = n.p + "bcd90f795bdc48050bce.png"
        },
        713106: function(e, t, n) {
            "use strict";
            e.exports = n.p + "fe9652309ef98c6f358e.svg"
        },
        956204: function(e, t, n) {
            "use strict";
            e.exports = n.p + "44c2a9c4e45973e395c0.png"
        },
        946662: function(e, t, n) {
            "use strict";
            e.exports = n.p + "496af98033e8f20540ec.svg"
        },
        299893: function(e, t, n) {
            "use strict";
            e.exports = n.p + "0ca73c69572a9c477cce.png"
        },
        997771: function(e, t, n) {
            "use strict";
            e.exports = n.p + "d8deaf4c4cbec4b8f9d6.svg"
        },
        255284: function(e, t, n) {
            "use strict";
            e.exports = n.p + "3c33877770f5210c5c01.png"
        },
        223406: function(e, t, n) {
            "use strict";
            e.exports = n.p + "5db6f2b6add954cbf0ea.svg"
        },
        523403: function(e, t, n) {
            "use strict";
            e.exports = n.p + "ca47ceaf07c3f567d239.png"
        },
        153846: function(e, t, n) {
            "use strict";
            e.exports = n.p + "6e62e16e7b4b8d34906b.svg"
        },
        145159: function(e, t, n) {
            "use strict";
            e.exports = n.p + "77df90635e4555438f29.png"
        },
        994912: function(e, t, n) {
            "use strict";
            e.exports = n.p + "0cbfee20a3f2cd0dd313.svg"
        },
        899676: function(e, t, n) {
            "use strict";
            e.exports = n.p + "worklet.84fc546a1c8906aa08ae.js"
        },
        157552: function(e, t, n) {
            "use strict";
            n.r(t), n.d(t, {
                fetchBranches: function() {
                    return c
                },
                fetchBranchesForApplication: function() {
                    return h
                }
            }), n("222007");
            var i = n("917351"),
                s = n.n(i),
                a = n("872717"),
                o = n("913144"),
                r = n("807085"),
                l = n("686470"),
                u = n("602043"),
                d = n("49111");
            async function c() {
                let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : l.default.entitledBranchIds;
                if (!(0, u.isSupportedPlatform)() || 0 === e.length) return [];
                let t = s.chunk(e, 50);
                try {
                    let e = t.map(async e => {
                            let t = await a.default.post({
                                url: d.Endpoints.APPLICATION_BRANCHES,
                                body: {
                                    branch_ids: e
                                },
                                oldFormErrors: !0
                            });
                            return t.body.map(r.default.createFromServer)
                        }),
                        n = await Promise.all(e),
                        i = s.flatten(n);
                    return o.default.dispatch({
                        type: "APPLICATION_BRANCHES_FETCH_SUCCESS",
                        branches: i
                    }), i
                } catch (t) {
                    return o.default.dispatch({
                        type: "APPLICATION_BRANCHES_FETCH_FAIL",
                        branchIds: e
                    }), []
                }
            }
            async function h(e) {
                try {
                    let t = await a.default.get({
                            url: d.Endpoints.OWNED_APPLICATION_BRANCHES(e),
                            oldFormErrors: !0
                        }),
                        n = Array.isArray(t.body) ? t.body.map(r.default.createFromServer) : [];
                    return o.default.dispatch({
                        type: "OWNED_APPLICATION_BRANCHES_FETCH_SUCCESS",
                        applicationId: e,
                        branches: n
                    }), n
                } catch (t) {
                    return o.default.dispatch({
                        type: "OWNED_APPLICATION_BRANCHES_FETCH_FAIL",
                        applicationId: e
                    }), []
                }
            }
        },
        71313: function(e, t, n) {
            "use strict";
            n.r(t), n.d(t, {
                fetchLiveBuild: function() {
                    return h
                }
            });
            var i = n("872717"),
                s = n("398183"),
                a = n("862337"),
                o = n("913144"),
                r = n("915639"),
                l = n("686470"),
                u = n("645672"),
                d = n("49111");
            let c = {};
            async function h(e, t) {
                let n = arguments.length > 2 && void 0 !== arguments[2] && arguments[2],
                    p = r.default.locale;
                return o.default.dispatch({
                    type: "APPLICATION_BUILD_FETCH_START",
                    applicationId: e,
                    branchId: t,
                    locale: p
                }), n && await (0, s.sleep)(6e4 * Math.random()), i.default.get({
                    url: d.Endpoints.APPLICATION_LIVE_BUILD(e, t),
                    query: {
                        platform: (0, u.getBuildPlatform)(),
                        locale: p
                    },
                    oldFormErrors: !0
                }).then(n => {
                    let i = n.body;
                    if (0 === i.manifests.length) {
                        o.default.dispatch({
                            type: "APPLICATION_BUILD_NOT_FOUND",
                            applicationId: e,
                            branchId: t
                        });
                        return
                    }
                    o.default.dispatch({
                        type: "APPLICATION_BUILD_FETCH_SUCCESS",
                        applicationId: e,
                        branchId: t,
                        locale: p,
                        build: i
                    })
                }, n => {
                    let {
                        status: i
                    } = n;
                    if (404 === i) o.default.dispatch({
                        type: "APPLICATION_BUILD_NOT_FOUND",
                        applicationId: e,
                        branchId: t
                    });
                    else {
                        var s, r;
                        s = e, null == c[r = t] && (c[r] = new a.Timeout), c[r].start(6e5 + 6e5 * Math.random(), () => {
                            let e = l.default.getLibraryApplication(s, r);
                            null != e && h(s, r)
                        })
                    }
                })
            }
        },
        190017: function(e, t, n) {
            "use strict";
            n.r(t), n.d(t, {
                init: function() {
                    return g
                },
                destroy: function() {
                    return S
                },
                installApplication: function() {
                    return _
                },
                repairApplication: function() {
                    return v
                },
                updateApplication: function() {
                    return C
                },
                uninstallApplication: function() {
                    return T
                },
                resume: function() {
                    return I
                },
                pause: function() {
                    return A
                },
                moveUp: function() {
                    return N
                },
                cancel: function() {
                    return D
                },
                removeFinished: function() {
                    return O
                },
                completeRepair: function() {
                    return R
                },
                completeInstall: function() {
                    return b
                }
            }), n("70102");
            var i = n("872717"),
                s = n("913144"),
                a = n("299285"),
                o = n("393414"),
                r = n("845579"),
                l = n("568307"),
                u = n("98328"),
                d = n("599110"),
                c = n("645672"),
                h = n("269180"),
                p = n("152723"),
                f = n("71313"),
                m = n("49111"),
                E = n("782340");

            function g(e, t) {
                p.default.init({
                    userToken: e,
                    userId: t,
                    installPaths: u.default.installationPaths,
                    platform: (0, c.getBuildPlatform)(),
                    stateCallback: e => {
                        s.default.dispatch({
                            type: "DISPATCH_APPLICATION_STATE_UPDATE",
                            state: e
                        })
                    },
                    errorCallback: e => {
                        s.default.dispatch({
                            type: "DISPATCH_APPLICATION_ERROR",
                            error: e
                        })
                    }
                })
            }

            function S() {
                p.default.destroy()
            }

            function _(e) {
                let {
                    application: t,
                    branchId: n,
                    buildId: i,
                    manifestIds: a,
                    installationPath: o,
                    analyticsLocation: r
                } = e;
                p.default.setTargetManifest({
                    applicationId: t.id,
                    applicationName: t.name,
                    applicationIcon: t.icon,
                    branchId: n,
                    buildId: i,
                    manifestIds: a,
                    installationPath: o
                }), s.default.dispatch({
                    type: "DISPATCH_APPLICATION_INSTALL",
                    applicationId: t.id,
                    branchId: n,
                    installationPath: o
                }), d.default.track(m.AnalyticEvents.LIBRARY_INSTALL_INITIATED, {
                    application_id: t.id,
                    application_name: t.name,
                    sku_id: t.primarySkuId,
                    location: r
                })
            }

            function v(e, t, n) {
                (0, f.fetchLiveBuild)(e.id, t).then(() => {
                    s.default.dispatch({
                        type: "DISPATCH_APPLICATION_REPAIR",
                        applicationId: e.id,
                        branchId: t
                    })
                }), d.default.track(m.AnalyticEvents.LIBRARY_REPAIR_INITIATED, {
                    application_id: e.id,
                    application_name: e.name,
                    sku_id: e.primarySkuId,
                    location: n
                })
            }

            function C(e, t, n, i) {
                let a = arguments.length > 4 && void 0 !== arguments[4] && arguments[4];
                ! function(e, t, n, i) {
                    if (l.default.getRunningDiscordApplicationIds().includes(e.id)) return;
                    let s = u.default.getInstallationPath(e.id, t);
                    if (null == s) throw Error("Missing installation path for application: ".concat(e.id, " ").concat(t));
                    p.default.setTargetManifest({
                        applicationId: e.id,
                        applicationName: e.name,
                        applicationIcon: e.icon,
                        branchId: t,
                        buildId: n,
                        manifestIds: i,
                        installationPath: s
                    })
                }(e, t, n, i), s.default.dispatch({
                    type: "DISPATCH_APPLICATION_UPDATE",
                    applicationId: e.id,
                    branchId: t,
                    automatic: a
                })
            }

            function T(e, t, n) {
                let i = a.default.getApplication(e);
                null != i && (h.default.removeShortcuts(i.name), d.default.track(m.AnalyticEvents.LIBRARY_UNINSTALL_INITIATED, {
                    application_id: i.id,
                    application_name: i.name,
                    sku_id: i.primarySkuId,
                    location: n
                })), p.default.uninstall(e, t), s.default.dispatch({
                    type: "DISPATCH_APPLICATION_UNINSTALL",
                    applicationId: e,
                    branchId: t
                })
            }

            function I() {
                p.default.resume()
            }

            function A() {
                p.default.pause()
            }

            function N(e, t) {
                s.default.dispatch({
                    type: "DISPATCH_APPLICATION_MOVE_UP",
                    applicationId: e,
                    branchId: t
                })
            }

            function D(e, t) {
                p.default.cancel(e, t), s.default.dispatch({
                    type: "DISPATCH_APPLICATION_CANCEL",
                    applicationId: e,
                    branchId: t
                })
            }

            function O(e, t) {
                s.default.dispatch({
                    type: "DISPATCH_APPLICATION_REMOVE_FINISHED",
                    applicationId: e,
                    branchId: t
                })
            }

            function R(e, t) {
                let n = a.default.getApplication(e);
                null != n && h.default.createShortcuts(r.InstallShortcutDesktop.getSetting(), r.InstallShortcutStartMenu.getSetting(), n.name, n.id, t.installPath)
            }

            function b(e, t) {
                let s = a.default.getApplication(e);
                i.default.post({
                    url: m.Endpoints.LIBRARY_APPLICATION_INSTALLED(e, e),
                    oldFormErrors: !0
                }), null != s && (h.default.createShortcuts(r.InstallShortcutDesktop.getSetting(), r.InstallShortcutStartMenu.getSetting(), s.name, s.id, t.installPath), n.el("193990").then(n.bind(n, "193990")).then(e => {
                    let {
                        default: t
                    } = e;
                    t.showNotification(s.getIconURL(64), E.default.Messages.GAME_LIBRARY_NOTIFICATION_GAME_INSTALLED_TITLE, E.default.Messages.GAME_LIBRARY_NOTIFICATION_GAME_INSTALLED_BODY.format({
                        name: s.name
                    }), {
                        notif_type: "Game Library Game Installed"
                    }, {
                        onClick: () => (0, o.transitionTo)(m.Routes.APPLICATION_LIBRARY),
                        omitViewTracking: !0
                    })
                }))
            }
        },
        363658: function(e, t, n) {
            "use strict";
            n.r(t), n.d(t, {
                default: function() {
                    return s
                }
            });
            var i = n("913144"),
                s = {
                    clearVADWarning() {
                        i.default.dispatch({
                            type: "PERMISSION_CLEAR_VAD_WARNING"
                        })
                    },
                    clearSuppressWarning() {
                        let e = arguments.length > 0 && void 0 !== arguments[0] && arguments[0];
                        i.default.dispatch({
                            type: "PERMISSION_CLEAR_SUPPRESS_WARNING",
                            forever: e
                        })
                    },
                    clearPTTAdminWarning() {
                        i.default.dispatch({
                            type: "PERMISSION_CLEAR_PTT_ADMIN_WARNING"
                        })
                    },
                    requestElevatedProcess(e) {
                        i.default.dispatch({
                            type: "PERMISSION_REQUEST_ELEVATED_PROCESS",
                            pid: e
                        })
                    },
                    clearElevatedProcess() {
                        i.default.dispatch({
                            type: "PERMISSION_CLEAR_ELEVATED_PROCESS"
                        })
                    },
                    continueNonelevatedProcess(e) {
                        i.default.dispatch({
                            type: "PERMISSION_CONTINUE_NONELEVATED_PROCESS",
                            pid: e
                        })
                    }
                }
        },
        673777: function(e, t, n) {
            "use strict";
            n.r(t), n.d(t, {
                open: function() {
                    return a
                },
                close: function() {
                    return o
                },
                openReplay: function() {
                    return r
                },
                setSection: function() {
                    return l
                },
                setShouldRecordNextConnection: function() {
                    return u
                },
                chooseReplayPath: function() {
                    return d
                }
            });
            var i = n("913144"),
                s = n("49671");

            function a(e) {
                i.default.dispatch({
                    type: "RTC_DEBUG_MODAL_OPEN",
                    section: e
                }), i.default.dispatch({
                    type: "RTC_DEBUG_POPOUT_WINDOW_OPEN"
                })
            }

            function o() {
                i.default.dispatch({
                    type: "RTC_DEBUG_MODAL_CLOSE"
                })
            }

            function r() {
                i.default.dispatch({
                    type: "RTC_DEBUG_MODAL_OPEN_REPLAY"
                })
            }

            function l(e) {
                i.default.dispatch({
                    type: "RTC_DEBUG_MODAL_SET_SECTION",
                    section: e
                })
            }

            function u(e) {
                i.default.dispatch({
                    type: "RTC_DEBUG_SET_RECORDING_FLAG",
                    value: e
                })
            }

            function d() {
                s.default.fileManager.showOpenDialog({
                    filters: [{
                        name: "All Files",
                        extensions: ["*"]
                    }]
                }).then(e => {
                    let t = 0 === e.length ? "" : e[0];
                    i.default.dispatch({
                        type: "RTC_DEBUG_MODAL_OPEN_REPLAY_AT_PATH",
                        path: t
                    })
                })
            }
        },
        846071: function(e, t, n) {
            "use strict";
            n.r(t), n.d(t, {
                default: function() {
                    return i
                }
            });
            var i, s = n("993105"),
                a = n("49111"),
                o = n("782340");
            i = class {
                get displayMessage() {
                    if (null == this.code) return o.default.Messages.NOTICE_DISPATCH_ERROR;
                    let {
                        path: e
                    } = this.context;
                    switch (this.code) {
                        case a.DispatchErrorCodes.DISK_LOW:
                            let {
                                available: t, required: n
                            } = this.context, i = (0, s.formatSize)(t, {
                                useKibibytes: !0
                            }), r = (0, s.formatSize)(n, {
                                useKibibytes: !0
                            });
                            return o.default.Messages.NOTICE_DISPATCH_ERROR_DISK_LOW.format({
                                required: r,
                                available: i
                            });
                        case a.DispatchErrorCodes.POST_INSTALL_FAILED:
                            let {
                                name: l
                            } = this.context;
                            return o.default.Messages.NOTICE_DISPATCH_ERROR_POST_INSTALL_FAILED.format({
                                name: l
                            });
                        case a.DispatchErrorCodes.FILE_NAME_TOO_LONG:
                            return o.default.Messages.NOTICE_DISPATCH_ERROR_FILE_NAME_TOO_LONG;
                        case a.DispatchErrorCodes.POST_INSTALL_CANCELLED:
                            return o.default.Messages.NOTICE_DISPATCH_ERROR_POST_INSTALL_CANCELLED;
                        case a.DispatchErrorCodes.IO_PERMISSION_DENIED:
                            return o.default.Messages.NOTICE_DISPATCH_ERROR_IO_PERMISSION_DENIED;
                        case a.DispatchErrorCodes.NO_MANIFESTS:
                            return o.default.Messages.NOTICE_DISPATCH_ERROR_NO_MANIFESTS;
                        case a.DispatchErrorCodes.NOT_ENTITLED:
                            return o.default.Messages.NOTICE_DISPATCH_ERROR_NOT_ENTITLED;
                        case a.DispatchErrorCodes.NOT_DIRECTORY:
                        case a.DispatchErrorCodes.DISK_PERMISSION_DENIED:
                            return o.default.Messages.NOTICE_DISPATCH_ERROR_UNWRITABLE.format({
                                path: e
                            });
                        case a.DispatchErrorCodes.INVALID_DRIVE:
                            return o.default.Messages.NOTICE_DISPATCH_ERROR_INVALID_DRIVE.format({
                                path: e
                            });
                        case a.DispatchErrorCodes.APPLICATION_LOCK_FAILED:
                            return o.default.Messages.NOTICE_DISPATCH_APPLICATION_LOCK_FAILED;
                        case a.DispatchErrorCodes.DISK_FULL:
                            return o.default.Messages.NOTICE_DISPATCH_ERROR_DISK_FULL;
                        case a.DispatchErrorCodes.API_ERROR:
                        case a.DispatchErrorCodes.MAX_REQUEST_RETRIES_EXCEEDED:
                            return o.default.Messages.NOTICE_DISPATCH_API_ERROR;
                        default:
                            return o.default.Messages.NOTICE_DISPATCH_ERROR_WITH_CODE.format({
                                code: "".concat(this.code)
                            })
                    }
                }
                constructor(e) {
                    this.raw = e, null != e.code && (this.code = e.code), null != e.uuid && (this.uuid = e.uuid), null != e.application_id && (this.applicationId = e.application_id), null != e.branch_id && (this.branchId = e.branch_id), null != e.context ? this.context = e.context : this.context = {}
                }
            }
        },
        226445: function(e, t, n) {
            "use strict";
            n.r(t), n.d(t, {
                Histogram: function() {
                    return s
                }
            }), n("424973"), n("222007");
            var i = n("265042");
            class s {
                addSample(e) {
                    this.digest.push(e)
                }
                getReport() {
                    var e, t, n, i;
                    let s = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : [25, 50, 75, 90, 95],
                        a = {};
                    for (let t of s) a[t] = null !== (e = this.digest.percentile(t / 100)) && void 0 !== e ? e : 0;
                    return {
                        min: null !== (t = this.digest.percentile(0)) && void 0 !== t ? t : 0,
                        max: null !== (n = this.digest.percentile(1)) && void 0 !== n ? n : 0,
                        count: null !== (i = this.digest.size()) && void 0 !== i ? i : 0,
                        percentiles: a
                    }
                }
                constructor() {
                    this.digest = new i.Digest
                }
            }
        },
        316272: function(e, t, n) {
            "use strict";
            var i;
            n.r(t), n.d(t, {
                default: function() {
                    return i
                }
            }), n("222007"), n("704744"), i = class {
                initialize() {
                    for (var e = arguments.length, t = Array(e), n = 0; n < e; n++) t[n] = arguments[n];
                    !this.isInitialized && (this.isInitialized = !0, this._initialize(...t))
                }
                terminate() {
                    this.isInitialized && (this.isInitialized = !1, this._terminate())
                }
                constructor() {
                    this.isInitialized = !1
                }
            }
        },
        497407: function(e, t, n) {
            "use strict";
            n.r(t), n.d(t, {
                default: function() {
                    return i
                }
            });
            var i, s = n("398183"),
                a = n("985365"),
                o = n("49111");

            function r(e) {
                let t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : 0;
                return null != e ? Math.round(e) : t
            }
            i = class {
                _initStats() {
                    let e = {
                        effectiveConnectionSpeedBuckets: {},
                        connectionTypeBuckets: {}
                    };
                    return Object.values(o.NetworkConnectionTypes).forEach(t => {
                        e.connectionTypeBuckets[t] = 0
                    }), Object.values(o.NetworkConnectionSpeeds).forEach(t => {
                        e.effectiveConnectionSpeedBuckets[t] = 0
                    }), e
                }
                getStats() {
                    let {
                        _networkStats: e
                    } = this;
                    return {
                        duration_connection_type_wifi: r(e.connectionTypeBuckets[o.NetworkConnectionTypes.WIFI]),
                        duration_connection_type_cellular: r(e.connectionTypeBuckets[o.NetworkConnectionTypes.CELLULAR]),
                        duration_connection_type_ethernet: r(e.connectionTypeBuckets[o.NetworkConnectionTypes.ETHERNET]),
                        duration_connection_type_bluetooth: r(e.connectionTypeBuckets[o.NetworkConnectionTypes.BLUETOOTH]),
                        duration_connection_type_other: r(e.connectionTypeBuckets[o.NetworkConnectionTypes.OTHER]),
                        duration_connection_type_unknown: r(e.connectionTypeBuckets[o.NetworkConnectionTypes.UNKNOWN]),
                        duration_connection_type_none: r(e.connectionTypeBuckets[o.NetworkConnectionTypes.NONE]),
                        duration_effective_connection_speed_2g: r(e.effectiveConnectionSpeedBuckets[o.NetworkConnectionSpeeds.TWO_G]),
                        duration_effective_connection_speed_3g: r(e.effectiveConnectionSpeedBuckets[o.NetworkConnectionSpeeds.THREE_G]),
                        duration_effective_connection_speed_4g: r(e.effectiveConnectionSpeedBuckets[o.NetworkConnectionSpeeds.FOUR_G]),
                        duration_effective_connection_speed_5g: r(e.effectiveConnectionSpeedBuckets[o.NetworkConnectionSpeeds.FIVE_G]),
                        duration_effective_connection_speed_unknown: r(e.effectiveConnectionSpeedBuckets[o.NetworkConnectionSpeeds.UNKNOWN])
                    }
                }
                incrementNetworkStats(e) {
                    let t = (e - this._lastSampleTimestamp) / 1e3,
                        n = a.default.getEffectiveConnectionSpeed();
                    n === o.NetworkConnectionSpeeds.SLOW_TWO_G && (n = o.NetworkConnectionSpeeds.TWO_G);
                    let i = a.default.getType();
                    i === o.NetworkConnectionTypes.WIMAX && (i = o.NetworkConnectionTypes.WIFI), this._networkStats.effectiveConnectionSpeedBuckets[n] += t, this._networkStats.connectionTypeBuckets[i] += t, this._lastSampleTimestamp = e
                }
                constructor() {
                    this._networkStats = this._initStats(), this._lastSampleTimestamp = (0, s.now)()
                }
            }
        },
        376556: function(e, t, n) {
            "use strict";
            n.r(t), n.d(t, {
                default: function() {
                    return c
                }
            }), n("511434"), n("313619"), n("654714"), n("287168"), n("956660"), n("222007");
            var i = n("917351"),
                s = n.n(i),
                a = n("669491"),
                o = n("691898"),
                r = n("49111");
            let l = [{
                    type: r.PlatformTypes.TWITCH,
                    name: "Twitch",
                    color: a.default.unsafe_rawColors.TWITCH.css,
                    icon: {
                        lightPNG: n("115658"),
                        darkPNG: n("115658"),
                        whitePNG: n("288589"),
                        lightSVG: n("729332"),
                        darkSVG: n("729332"),
                        whiteSVG: n("31439")
                    },
                    enabled: !0,
                    getPlatformUserUrl: e => {
                        let {
                            name: t
                        } = e;
                        return "https://www.twitch.tv/".concat(encodeURIComponent(t))
                    },
                    domains: ["twitch.tv", "twitch.com"]
                }, {
                    type: r.PlatformTypes.YOUTUBE,
                    name: "YouTube",
                    color: a.default.unsafe_rawColors.YOUTUBE.css,
                    icon: {
                        lightPNG: n("299893"),
                        darkPNG: n("299893"),
                        whitePNG: n("255284"),
                        lightSVG: n("997771"),
                        darkSVG: n("997771"),
                        whiteSVG: n("223406")
                    },
                    enabled: !0,
                    getPlatformUserUrl: e => {
                        let {
                            id: t
                        } = e;
                        return "https://www.youtube.com/channel/".concat(encodeURIComponent(t))
                    },
                    domains: ["youtube.com", "youtu.be"]
                }, {
                    type: r.PlatformTypes.BATTLENET,
                    name: "Battle.net",
                    color: a.default.unsafe_rawColors.BATTLENET.css,
                    icon: {
                        lightPNG: n("194175"),
                        darkPNG: n("194175"),
                        whitePNG: n("159142"),
                        lightSVG: n("35024"),
                        darkSVG: n("35024"),
                        whiteSVG: n("671223")
                    },
                    enabled: !0
                }, {
                    type: r.PlatformTypes.SKYPE,
                    name: "Skype",
                    color: a.default.unsafe_rawColors.SKYPE.css,
                    icon: {
                        lightPNG: n("992221"),
                        darkPNG: n("992221"),
                        whitePNG: n("731368"),
                        lightSVG: n("894025"),
                        darkSVG: n("894025"),
                        whiteSVG: n("645496")
                    },
                    enabled: !1,
                    getPlatformUserUrl: e => {
                        let {
                            id: t
                        } = e;
                        return "skype:".concat(encodeURIComponent(t), "?userinfo")
                    }
                }, {
                    type: r.PlatformTypes.LEAGUE_OF_LEGENDS,
                    name: "League of Legends",
                    color: a.default.unsafe_rawColors.LOL.css,
                    icon: {
                        lightPNG: n("530354"),
                        darkPNG: n("530354"),
                        whitePNG: n("925382"),
                        lightSVG: n("667083"),
                        darkSVG: n("667083"),
                        whiteSVG: n("509949")
                    },
                    enabled: !0
                }, {
                    type: r.PlatformTypes.STEAM,
                    name: "Steam",
                    color: a.default.unsafe_rawColors.STEAM.css,
                    icon: {
                        lightPNG: n("777626"),
                        darkPNG: n("877414"),
                        whitePNG: n("877414"),
                        lightSVG: n("566035"),
                        darkSVG: n("309663"),
                        whiteSVG: n("309663")
                    },
                    enabled: !0,
                    getPlatformUserUrl: e => {
                        let {
                            id: t
                        } = e;
                        return "https://steamcommunity.com/profiles/".concat(encodeURIComponent(t))
                    },
                    hasMetadata: !0
                }, {
                    type: r.PlatformTypes.REDDIT,
                    name: "Reddit",
                    color: a.default.unsafe_rawColors.REDDIT.css,
                    icon: {
                        lightPNG: n("373338"),
                        darkPNG: n("373338"),
                        whitePNG: n("479111"),
                        lightSVG: n("977001"),
                        darkSVG: n("977001"),
                        whiteSVG: n("592466")
                    },
                    enabled: !0,
                    getPlatformUserUrl: e => {
                        let {
                            name: t
                        } = e;
                        return "https://www.reddit.com/u/".concat(encodeURIComponent(t))
                    },
                    hasMetadata: !0
                }, {
                    type: r.PlatformTypes.FACEBOOK,
                    name: "Facebook",
                    color: a.default.unsafe_rawColors.FACEBOOK.css,
                    icon: {
                        lightPNG: n("879157"),
                        darkPNG: n("879157"),
                        whitePNG: n("259168"),
                        lightSVG: n("870064"),
                        darkSVG: n("870064"),
                        whiteSVG: n("735638")
                    },
                    enabled: !0
                }, {
                    type: r.PlatformTypes.TWITTER_LEGACY,
                    name: "Twitter",
                    color: a.default.unsafe_rawColors.TWITTER.css,
                    icon: {
                        lightPNG: n("122630"),
                        darkPNG: n("122630"),
                        whitePNG: n("961232"),
                        lightSVG: n("372786"),
                        darkSVG: n("372786"),
                        whiteSVG: n("387628")
                    },
                    enabled: !1,
                    getPlatformUserUrl: e => {
                        let {
                            name: t
                        } = e;
                        return "https://twitter.com/".concat(encodeURIComponent(t))
                    },
                    domains: ["twitter.com"],
                    hasMetadata: !0
                }, {
                    type: r.PlatformTypes.TWITTER,
                    name: "X",
                    color: a.default.unsafe_rawColors.TWITTER.css,
                    icon: {
                        lightPNG: n("483819"),
                        darkPNG: n("980576"),
                        whitePNG: n("192473"),
                        lightSVG: n("955307"),
                        darkSVG: n("552995"),
                        whiteSVG: n("312139")
                    },
                    enabled: !0,
                    getPlatformUserUrl: e => {
                        let {
                            name: t
                        } = e;
                        return "https://x.com/".concat(encodeURIComponent(t))
                    },
                    domains: ["x.com"],
                    hasMetadata: !0
                }, {
                    type: r.PlatformTypes.SPOTIFY,
                    name: "Spotify",
                    color: a.default.unsafe_rawColors.SPOTIFY.css,
                    icon: {
                        lightPNG: n("561050"),
                        darkPNG: n("561050"),
                        whitePNG: n("618077"),
                        lightSVG: n("630528"),
                        darkSVG: n("630528"),
                        whiteSVG: n("662418")
                    },
                    enabled: !0,
                    getPlatformUserUrl: e => {
                        let {
                            id: t
                        } = e;
                        return "https://open.spotify.com/user/".concat(encodeURIComponent(t))
                    }
                }, {
                    type: r.PlatformTypes.XBOX,
                    name: "Xbox",
                    color: a.default.unsafe_rawColors.XBOX.css,
                    icon: {
                        lightPNG: n("599004"),
                        darkPNG: n("956204"),
                        whitePNG: n("956204"),
                        lightSVG: n("713106"),
                        darkSVG: n("946662"),
                        whiteSVG: n("946662"),
                        customPNG: n("272378")
                    },
                    enabled: !0
                }, {
                    type: r.PlatformTypes.SAMSUNG,
                    name: "Samsung Galaxy",
                    color: a.default.unsafe_rawColors.SAMSUNG.css,
                    icon: {
                        lightPNG: n("768935"),
                        darkPNG: n("768935"),
                        whitePNG: n("629132"),
                        lightSVG: n("869872"),
                        darkSVG: n("869872"),
                        whiteSVG: n("301098")
                    },
                    enabled: !1
                }, {
                    type: r.PlatformTypes.GITHUB,
                    name: "GitHub",
                    color: a.default.unsafe_rawColors.GITHUB.css,
                    icon: {
                        lightPNG: n("321223"),
                        darkPNG: n("646994"),
                        whitePNG: n("646994"),
                        lightSVG: n("94470"),
                        darkSVG: n("375518"),
                        whiteSVG: n("375518")
                    },
                    enabled: !0,
                    getPlatformUserUrl: e => {
                        let {
                            name: t
                        } = e;
                        return "https://github.com/".concat(encodeURIComponent(t))
                    },
                    domains: ["github.com"]
                }, {
                    type: r.PlatformTypes.PLAYSTATION,
                    name: "PlayStation Network",
                    color: a.default.unsafe_rawColors.PLAYSTATION.css,
                    icon: {
                        lightPNG: n("322246"),
                        darkPNG: n("964854"),
                        whitePNG: n("964854"),
                        lightSVG: n("154849"),
                        darkSVG: n("895661"),
                        whiteSVG: n("895661")
                    },
                    enabled: !0
                }, {
                    type: r.PlatformTypes.PLAYSTATION_STAGING,
                    name: "PlayStation Network (Staging)",
                    color: a.default.unsafe_rawColors.PLAYSTATION.css,
                    icon: {
                        lightPNG: n("964854"),
                        darkPNG: n("322246"),
                        whitePNG: n("322246"),
                        lightSVG: n("895661"),
                        darkSVG: n("154849"),
                        whiteSVG: n("154849")
                    },
                    enabled: !1
                }, {
                    type: r.PlatformTypes.EPIC_GAMES,
                    name: "Epic Games",
                    icon: {
                        lightPNG: n("1308"),
                        darkPNG: n("396128"),
                        whitePNG: n("396128"),
                        lightSVG: n("746621"),
                        darkSVG: n("497894"),
                        whiteSVG: n("497894")
                    },
                    enabled: !0
                }, {
                    type: r.PlatformTypes.RIOT_GAMES,
                    name: "Riot Games",
                    icon: {
                        lightPNG: n("300525"),
                        darkPNG: n("300525"),
                        whitePNG: n("501653"),
                        lightSVG: n("704777"),
                        darkSVG: n("704777"),
                        whiteSVG: n("940593")
                    },
                    enabled: !0
                }, {
                    type: r.PlatformTypes.PAYPAL,
                    name: "PayPal",
                    icon: {
                        lightPNG: n("347775"),
                        darkPNG: n("347775"),
                        whitePNG: n("770624"),
                        lightSVG: n("524855"),
                        darkSVG: n("524855"),
                        whiteSVG: n("209560")
                    },
                    enabled: !0,
                    hasMetadata: !0
                }, {
                    type: r.PlatformTypes.EBAY,
                    name: "eBay",
                    icon: {
                        lightPNG: n("14366"),
                        darkPNG: n("14366"),
                        whitePNG: n("994873"),
                        lightSVG: n("286611"),
                        darkSVG: n("286611"),
                        whiteSVG: n("376998")
                    },
                    enabled: !0,
                    hasMetadata: !0,
                    getPlatformUserUrl: e => {
                        let {
                            name: t
                        } = e;
                        return "https://www.ebay.com/usr/".concat(encodeURIComponent(t))
                    }
                }, {
                    type: r.PlatformTypes.TIKTOK,
                    name: "TikTok",
                    icon: {
                        lightPNG: n("482311"),
                        darkPNG: n("196135"),
                        whitePNG: n("196135"),
                        lightSVG: n("204844"),
                        darkSVG: n("793866"),
                        whiteSVG: n("793866")
                    },
                    enabled: !0,
                    hasMetadata: !0,
                    getPlatformUserUrl: e => {
                        let {
                            name: t
                        } = e;
                        return "https://www.tiktok.com/@".concat(encodeURIComponent(t))
                    }
                }, {
                    type: r.PlatformTypes.INSTAGRAM,
                    name: "Instagram",
                    icon: {
                        lightPNG: n("299059"),
                        darkPNG: n("299059"),
                        whitePNG: n("612315"),
                        lightSVG: n("496955"),
                        darkSVG: n("496955"),
                        whiteSVG: n("152071")
                    },
                    enabled: !0,
                    getPlatformUserUrl: e => {
                        let {
                            name: t
                        } = e;
                        return "https://www.instagram.com/".concat(encodeURIComponent(t))
                    }
                }, {
                    type: r.PlatformTypes.CRUNCHYROLL,
                    name: "Crunchyroll",
                    color: a.default.unsafe_rawColors.CRUNCHYROLL.css,
                    icon: {
                        lightPNG: n("211689"),
                        darkPNG: n("211689"),
                        whitePNG: n("211689"),
                        lightSVG: n("350043"),
                        darkSVG: n("350043"),
                        whiteSVG: n("698833")
                    },
                    enabled: !0
                }, {
                    type: r.PlatformTypes.DOMAIN,
                    name: "Domain",
                    icon: {
                        lightPNG: n("145159"),
                        darkPNG: n("523403"),
                        whitePNG: n("523403"),
                        lightSVG: n("994912"),
                        darkSVG: n("153846"),
                        whiteSVG: n("153846")
                    },
                    getPlatformUserUrl: e => {
                        let {
                            id: t
                        } = e;
                        return "https://".concat(t, "/")
                    },
                    get enabled() {
                        return o.DomainConnectionExperiment.getCurrentConfig({
                            location: "ed49a3_1"
                        }).enabled
                    }
                }],
                u = s.keyBy(l, "type"),
                d = {};
            l.forEach(e => {
                var t;
                null === (t = e.domains) || void 0 === t || t.forEach(t => {
                    d[t] = e
                })
            });
            var c = {
                get(e) {
                    var t;
                    return null !== (t = u[e]) && void 0 !== t ? t : null
                },
                getByUrl(e) {
                    let t = new URL(e),
                        n = t.hostname,
                        i = n.startsWith("www.") ? n.slice(4) : n;
                    return d[i]
                },
                isSupported: e => Object.prototype.hasOwnProperty.call(u, e),
                map: e => l.map(e),
                filter(e) {
                    let t = l.filter(e);
                    return t.sort((e, t) => {
                        let {
                            name: n
                        } = e, {
                            name: i
                        } = t;
                        return n.localeCompare(i)
                    }), t
                },
                find: e => l.find(e)
            }
        },
        70513: function(e, t, n) {
            "use strict";
            n.r(t), n.d(t, {
                default: function() {
                    return r
                }
            }), n("70102");
            var i = n("605250"),
                s = n("773336"),
                a = n("49671");
            let o = new i.default("ProgressBarManager");
            var r = new class e {
                setProgress(e, t) {
                    if (!(0, s.isDesktop)()) throw Error("cannot set progress from non-native");
                    if (null != this.taskID && this.taskID !== e) {
                        o.warn("".concat(this.taskID, " is already running. cannot set ").concat(e));
                        return
                    }
                    this.taskID = e, a.default.window.setProgressBar(t)
                }
                clearProgress(e) {
                    if (!(0, s.isDesktop)()) throw Error("cannot clear progress from non-native");
                    if (null == this.taskID) {
                        o.warn("cannot clear progress. No current progress running.");
                        return
                    }
                    if (this.taskID !== e) {
                        o.warn("cannot clear progress of ".concat(e, " when ").concat(this.taskID, " is running"));
                        return
                    }
                    this.taskID = null, a.default.window.setProgressBar(-1)
                }
            }
        },
        199948: function(e, t, n) {
            "use strict";
            n.r(t), n.d(t, {
                default: function() {
                    return i
                }
            }), n("424973"), n("222007");
            var i, s = n("917351"),
                a = n.n(s);
            let o = [];
            i = class e {
                static create() {
                    let t = new e;
                    return o.push(t), t.record
                }
                getTotalBytes() {
                    return a.sum(Object.values(this.bytes))
                }
                constructor() {
                    this.bytes = {}, this.record = e => {
                        if (null != e) {
                            for (let t in e.rtp.inbound) {
                                let n = e.rtp.inbound[t];
                                for (let e of n) {
                                    let n = "inbound-".concat(t, "-").concat(e.type);
                                    !(n in this.bytes) && (this.bytes[n] = 0), this.bytes[n] = e.bytesReceived
                                }
                            }
                            for (let t of e.rtp.outbound) {
                                let e = "outbound-".concat(t.type);
                                !(e in this.bytes) && (this.bytes[e] = 0), this.bytes[e] = t.bytesSent
                            }
                        }
                    }
                }
            }
        },
        997722: function(e, t, n) {
            "use strict";
            n.r(t), n.d(t, {
                default: function() {
                    return s
                }
            }), n("70102"), n("808653"), n("424973"), n("222007");
            var i, s, a = n("552442"),
                o = n.n(a),
                r = n("210696"),
                l = n.n(r),
                u = n("746379"),
                d = n.n(u),
                c = n("748820"),
                h = n("981980"),
                p = n("595275"),
                f = n("773364"),
                m = n("398183"),
                E = n("913144"),
                g = n("673777"),
                S = n("605250"),
                _ = n("808122"),
                v = n("601222"),
                C = n("469543"),
                T = n("967039"),
                I = n("834604"),
                A = n("355014");
            n("222920");
            var N = n("901946"),
                D = n("42203"),
                O = n("42887"),
                R = n("661919"),
                b = n("590401"),
                y = n("599110"),
                P = n("35468"),
                L = n("773336"),
                k = n("49671"),
                w = n("199948"),
                V = n("422791"),
                M = n("642099"),
                U = n("417040"),
                x = n("716380"),
                F = n("157547"),
                B = n("88313"),
                G = n("531748"),
                H = n("760406"),
                W = n("478696"),
                K = n("49111"),
                Y = n("353927");
            let Q = /^https/.test((i = "https:", "https:")) ? "wss:" : "ws:";
            s = class extends p.default {
                get quality() {
                    let e = this.getLastPing();
                    if (this.state !== K.RTCConnectionStates.RTC_CONNECTED || void 0 === e) return K.RTCConnectionQuality.UNKNOWN;
                    if (e > 500 || null != this._outboundLossRate && this._outboundLossRate > 10) return K.RTCConnectionQuality.BAD;
                    if (e > 250 || null != this._outboundLossRate && this._outboundLossRate > 5) return K.RTCConnectionQuality.AVERAGE;
                    else return K.RTCConnectionQuality.FINE
                }
                get endpoint() {
                    return this._endpoint
                }
                set endpoint(e) {
                    if (null == e) this._endpoint = null, this.hostname = null;
                    else {
                        e = "".concat(Q, "//").concat(e);
                        let {
                            hostname: t,
                            port: n
                        } = d.parse(e), i = null != n ? parseInt(n) : NaN;
                        null != t && (80 === i || 443 === i) && (e = "".concat(Q, "//").concat(t)), this._endpoint = e + "/", this.hostname = t
                    }
                }
                connect(e, t) {
                    if (this._destroyed) throw Error("RTCConnection.connect(...): Attempting to connect on destroyed instance.");
                    this._backoff.cancel();
                    let {
                        endpoint: n,
                        token: i
                    } = this;
                    if (this.endpoint = e, this.token = t, (n !== this.endpoint || i !== t) && (this._cleanupSocket(), this._mediaSessionId = null, null != n && (this._rtcConnectionId = (0, c.v4)(), E.default.dispatch({
                            type: "RTC_CONNECTION_UPDATE_ID",
                            connection: this
                        }))), null == this.endpoint) {
                        this.setState(K.RTCConnectionStates.AWAITING_ENDPOINT);
                        return
                    }
                    let s = this._socket;
                    null != s && this._cleanupSocket(), (s = this._socket = new U.default(this.endpoint)).on(U.SocketEvent.Connecting, this._handleConnecting.bind(this, s)), s.on(U.SocketEvent.Connect, this._handleConnect.bind(this, s)), s.on(U.SocketEvent.Disconnect, this._handleDisconnect.bind(this, s)), s.on(U.SocketEvent.Resuming, this._handleResuming.bind(this, s)), s.on(U.SocketEvent.Ready, this._handleReady.bind(this, s)), s.on(U.SocketEvent.Speaking, this._handleSpeaking.bind(this, s)), s.on(U.SocketEvent.Video, this._handleVideo.bind(this, s)), s.on(U.SocketEvent.Ping, this._handleControlPing.bind(this)), s.on(U.SocketEvent.ClientDisconnect, this._handleClientDisconnect.bind(this)), s.on(U.SocketEvent.Codecs, this._handleCodecs.bind(this)), s.on(U.SocketEvent.MediaSessionId, this._handleMediaSessionId.bind(this)), s.on(U.SocketEvent.MediaSinkWants, this._handleMediaSinkWants.bind(this)), s.on(U.SocketEvent.VoiceBackendVersion, this._handleCodeVersion.bind(this)), s.on(U.SocketEvent.KeyframeInterval, this._handleKeyframeInterval.bind(this)), s.on(U.SocketEvent.ChannelOptionsUpdateRtcLog, this._handleUpdateRtcLog.bind(this)), s.on(U.SocketEvent.Flags, this.handleFlags.bind(this)), s.on(U.SocketEvent.Platform, this.handlePlatform.bind(this)), s.on(U.SocketEvent.BandwidthEstimationExperiment, this._handleBandwidthEstimationExperiment.bind(this)), s.on(U.SocketEvent.SecureFramesInit, this._handleSecureFramesInit.bind(this)), s.on(U.SocketEvent.SecureFramesPrepareTransition, this._handleSecureFramesPrepareTransition.bind(this, s)), s.on(U.SocketEvent.SecureFramesExecuteTransition, this._handleSecureFramesExecuteTransition.bind(this)), this._connectStartTime = (0, m.now)(), this._connectCount++, this._connecting = !0, null != s && this._socket === s && (this._trackVoiceConnectionConnecting(), this._encountered_socket_failure = !1, s.connect())
                }
                destroy() {
                    var e, t, n, i, s;
                    if (this.logger.info("Destroy RTCConnection"), P.default.removeOnlineCallback(this._handleNetworkOnline), P.default.removeOfflineCallback(this._handleNetworkOffline), (0, L.isDesktop)() && (null === (s = this.powerMonitorListener) || void 0 === s || s.call(this)), this._backoff.cancel(), this._cleanupSocket(), null === (e = this._voiceQuality) || void 0 === e || e.stop(), this._voiceQuality = null, clearInterval(this._voiceQualityPeriodicStatsInterval), this._voiceQualityPeriodicStatsInterval = null, this._voiceQualityPeriodicStatsSequenceId = 0, null === (t = this._voiceDuration) || void 0 === t || t.stop(), this._voiceDuration = null, null === (n = this._videoQuality) || void 0 === n || n.stop(), this._videoQuality = null, this._videoHealthManager = null, null === (i = this._localMediaSinkWantsManager) || void 0 === i || i.reset(), null != this._connection) {
                        let e = this._connection;
                        this._connection = null, e.destroy()
                    }
                    this.removeAllListeners(), this._destroyed = !0
                }
                sendSpeaking(e, t) {
                    let n = this._socket;
                    if (null != n) {
                        let i = O.default.getPacketDelay();
                        n.speaking(e, i, t)
                    }
                }
                sendVideo(e, t, n, i) {
                    let s = this._socket;
                    null != s && (0 !== t && (this._sentVideo = !0), this._sentVideo && s.video(e, t, n, i))
                }
                getPings() {
                    return this._pings
                }
                getAveragePing() {
                    let e = this._pings.slice(0, Math.min(this._pings.length, 20));
                    return 0 === e.length || null == this._socket ? 0 : e.reduce((e, t) => e + t.value, 0) / e.length
                }
                getLastPing() {
                    var e;
                    return null === (e = this._pings[this._pings.length - 1]) || void 0 === e ? void 0 : e.value
                }
                getOutboundLossRate() {
                    return this._outboundLossRate
                }
                getMediaSessionId() {
                    return this._mediaSessionId
                }
                getRTCConnectionId() {
                    return this._rtcConnectionId
                }
                getVoiceVersion() {
                    return this.voiceVersion
                }
                getRtcWorkerVersion() {
                    return this.rtcWorkerVersion
                }
                getDuration() {
                    let e = this._connectCompletedTime > 0 ? (0, m.now)() - this._connectCompletedTime : 0;
                    return e > 0 ? e : 0
                }
                getPacketStats() {
                    var e;
                    return null === (e = this._voiceQuality) || void 0 === e ? void 0 : e.getPacketStats()
                }
                getCreatedTime() {
                    return this._createdTime
                }
                getVideoHealthManager() {
                    return this._videoHealthManager
                }
                getBandwidthEstimationExperiment() {
                    return this._bandwidthEstimationExperiment
                }
                pauseStatsCollectionForUser(e, t) {
                    let n = this.getOrCreateVideoQuality();
                    if (null == n) {
                        this.logger.error("pauseStatsCollectionForUser: Unable to create videoQuality.");
                        return
                    }
                    t ? n.addUserToStatsCollectionPausedSet(e) : n.removeUserFromStatsCollectionPausedSet(e)
                }
                setState(e) {
                    let t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {};
                    this.logger.info("RTC connection state: ".concat(this.state, " => ").concat(e)), this.state = e, this.stateHistory.update(this.state), this.emit(V.RTCConnectionEvent.State, e, {
                        hostname: this.hostname,
                        channelId: null != this.rtcServerId ? o(this.rtcServerId).prev().toString() : this.channelId,
                        context: this.context,
                        rtcLogEphemeralKey: this.rtcLogEphemeralKey
                    }, t)
                }
                expeditedHeartbeat(e) {
                    let t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : "",
                        n = !(arguments.length > 2) || void 0 === arguments[2] || arguments[2],
                        i = this._socket;
                    null != i && i.expeditedHeartbeat(e, t, n) && this._backoff.cancel()
                }
                resetBackoff() {
                    let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : "",
                        t = this._socket;
                    null != t && t.resetBackoff(e) && this._backoff.cancel()
                }
                setAppBackgrounded(e, t) {
                    var n;
                    null === (n = this._localMediaSinkWantsManager) || void 0 === n || n.setAppBackgrounded(e, t)
                }
                setSelectedParticipant(e) {
                    var t;
                    null === (t = this._localMediaSinkWantsManager) || void 0 === t || t.setSelectedParticipant(e)
                }
                setPipOpen(e) {
                    var t;
                    null === (t = this._localMediaSinkWantsManager) || void 0 === t || t.setPipOpen(e)
                }
                setRtcLogMarker(e) {
                    var t;
                    null === (t = this._connection) || void 0 === t || t.setRtcLogMarker(e)
                }
                getSSRCsForUser(e) {
                    return null == this._connection ? null : [this._connection.getRemoteVideoSSRCsForUser(e), this._connection.getRemoteAudioSSRCForUser(e)]
                }
                setClipRecordSSRC(e, t, n, i, s) {
                    var a;
                    let o = (() => {
                        var i, a, o;
                        if (null != s) return s;
                        if ("outbound" === n) throw Error("Do not use setClipRecordSSRC for outbound streams!");
                        if ("audio" === t) return null === (i = this._connection) || void 0 === i ? void 0 : i.getRemoteAudioSSRCForUser(e);
                        if ("video" === t) {
                            let t = null === (a = this._connection) || void 0 === a ? void 0 : a.getRemoteVideoSSRCsForUser(e);
                            return (null !== (o = null == t ? void 0 : t.length) && void 0 !== o ? o : 0) > 1 && this.logger.warn("setClipRecordSSRC: More than one video SSRC for user ".concat(e, "! Behavior undefined.")), null == t ? void 0 : t[0]
                        }
                    })();
                    null != o && (null === (a = this._connection) || void 0 === a || a.setClipRecordSsrc(o, t, n, i))
                }
                set channelId(e) {
                    this._channelId = e, this.channelIds.add(e)
                }
                get channelId() {
                    return this._channelId
                }
                _cleanupSocket() {
                    let e = this._socket;
                    null != e && (e.close(), e.removeAllListeners(), this._socket = null)
                }
                _chooseExperiments(e) {
                    let t = [];
                    if (this._recordingEnabled && t.push("connection_log"), O.default.supports(Y.Features.FIXED_KEYFRAME_INTERVAL) && t.push("fixed_keyframe_interval"), 0 !== this._supportedBandwidthEstimationExperiments.length) {
                        let {
                            enabled: e,
                            fullname: n
                        } = T.default.getConfig(!0, this._supportedBandwidthEstimationExperiments);
                        e && t.push(n)
                    }
                    this._selectedExperiments = t
                }
                _handleConnecting(e) {
                    null != this.endpoint && this.logger.info("Connecting to RTC server ".concat(this.endpoint, ", rtc-connection-id: ").concat(this.getRTCConnectionId())), this.setState(K.RTCConnectionStates.CONNECTING)
                }
                _handleConnect(e) {
                    var t, n;
                    let i = this.token;
                    if (null == i) throw Error("RTCConnection._handleConnect(...): Token is missing.");
                    this.logger.info("Connected to RTC server."), e.identify({
                        serverId: null !== (n = null !== (t = this.rtcServerId) && void 0 !== t ? t : this.guildId) && void 0 !== n ? n : this.channelId,
                        userId: this.userId,
                        sessionId: this.sessionId,
                        token: i,
                        maxSecureFramesVersion: O.default.getSupportedSecureFramesProtocolVersion(this.guildId),
                        video: O.default.supports(Y.Features.VIDEO),
                        streamParameters: O.default.getVideoStreamParameters(this.context)
                    }), this.setState(K.RTCConnectionStates.AUTHENTICATING)
                }
                _handleDisconnect(e, t, n, i) {
                    var s, a, o, r, l;
                    this.logger.info("Disconnected from RTC server, clean: ".concat(t, ", code: ").concat(n, ", reason: ").concat(i, ", state: ").concat(this.state)), !t && this._connecting && !this._encountered_socket_failure && (y.default.track(K.AnalyticEvents.VOICE_CONNECTION_SOCKET_FAILURE, {
                        guild_id: this.guildId,
                        channel_id: this.channelId,
                        rtc_connection_id: this.getRTCConnectionId(),
                        hostname: this.hostname,
                        connect_count: this._connectCount,
                        code: n,
                        reason: i
                    }), this._encountered_socket_failure = !0);
                    let u = "Force Close" !== i;
                    if (u) {
                        let e = this._backoff.fail(this.reconnect);
                        this.logger.warn("Disconnect was not clean! reason=".concat(i, ". Reconnecting in ").concat((e / 1e3).toFixed(2), " seconds."))
                    }
                    if (this.state !== K.RTCConnectionStates.DISCONNECTED) {
                        let e = D.default.getChannel(this.channelId),
                            t = null != e ? e.type : null,
                            n = this._videoQuality;
                        if (null != n && this.context === Y.MediaEngineContextTypes.DEFAULT) {
                            if (n.stop(), this._sentVideo) {
                                let e = n.getOutboundStats();
                                e.forEach(e => {
                                    var s;
                                    let a = null !== (s = e.num_frames) && void 0 !== s ? s : 0;
                                    a > 0 && y.default.track(K.AnalyticEvents.VIDEO_STREAM_ENDED, {
                                        ...this._getAnalyticsProperties(),
                                        media_session_id: this.getMediaSessionId(),
                                        sender_user_id: this.userId,
                                        channel_type: t,
                                        reason: i,
                                        participant_type: "sender",
                                        guild_region: b.default.getRegion(this.hostname),
                                        hostname: this.hostname,
                                        ...e,
                                        ...n.getNetworkStats(),
                                        ...n.getCodecUsageStats("sender", this.userId),
                                        ...this._soundshareStats.getStats(),
                                        device_performance_class: (0, _.getMediaPerformanceClass)()
                                    })
                                })
                            }
                            let e = n.getInboundParticipants();
                            e.forEach(e => {
                                var s;
                                let a = n.getInboundStats(e),
                                    o = null !== (s = null == a ? void 0 : a.num_frames) && void 0 !== s ? s : 0;
                                o > 0 && y.default.track(K.AnalyticEvents.VIDEO_STREAM_ENDED, {
                                    ...this._getAnalyticsProperties(),
                                    media_session_id: this.getMediaSessionId(),
                                    sender_user_id: e,
                                    channel_type: t,
                                    reason: i,
                                    participant_type: "receiver",
                                    guild_region: b.default.getRegion(this.hostname),
                                    hostname: this.hostname,
                                    ...a,
                                    ...n.getNetworkStats(),
                                    ...n.getCodecUsageStats("receiver", e)
                                })
                            })
                        }
                        let s = b.default.shouldIncludePreferredRegion() ? b.default.getPreferredRegion() : null,
                            a = O.default.getSettings();
                        y.default.track(K.AnalyticEvents.VOICE_DISCONNECT, {
                            ...this._getAnalyticsProperties(),
                            hostname: this.hostname,
                            port: this.port,
                            protocol: this.protocol,
                            reconnect: u,
                            reason: i,
                            duration: this.getDuration(),
                            ...null != this._voiceQuality ? this._voiceQuality.getMosStats() : null,
                            ...null != this._voiceQuality ? this._voiceQuality.getPacketStats() : null,
                            ...null != this._voiceQuality ? this._voiceQuality.getBytesStats() : null,
                            ...null != this._voiceQuality ? this._voiceQuality.getBufferStats() : null,
                            ...null != this._voiceQuality ? this._voiceQuality.getNetworkStats() : null,
                            ...null != this._voiceQuality ? this._voiceQuality.getFrameOpStats() : null,
                            ...null != this._voiceQuality ? this._voiceQuality.getDurationStats() : null,
                            ...null != this._voiceQuality ? this._voiceQuality.getTransportStats() : null,
                            ...null != this._voiceDuration ? this._voiceDuration.getDurationStats() : null,
                            media_session_id: this.getMediaSessionId(),
                            channel_type: t,
                            channel_bitrate: null != e ? e.bitrate : null,
                            cloudflare_best_region: s,
                            connect_count: this._connectCount,
                            ping_average: Math.round(this.getAveragePing()),
                            ping_bad_count: this._pingBadCount,
                            ping_timeout: this._pingTimeouts.length,
                            input_detected: this._inputDetected,
                            no_input_detected_notice: O.default.getNoInputDetectedNotice(),
                            audio_input_mode: a.mode,
                            automatic_audio_input_sensitivity_enabled: a.modeOptions.autoThreshold,
                            audio_input_sensitivity: a.modeOptions.threshold,
                            echo_cancellation_enabled: a.echoCancellation,
                            noise_suppression_enabled: a.noiseSuppression,
                            noise_cancellation_enabled: a.noiseCancellation,
                            automatic_gain_control_enabled: a.automaticGainControl,
                            voice_output_volume: a.outputVolume,
                            encryption_mode: this._encryptionMode,
                            channel_count: this.channelIds.size,
                            input_device: this.getInputDeviceName(),
                            output_device: this.getOutputDeviceName(),
                            device_performance_class: (0, _.getMediaPerformanceClass)(),
                            num_fast_udp_reconnects: null != this._connection ? null === (l = this._connection) || void 0 === l ? void 0 : l.getNumFastUdpReconnects() : null
                        });
                        let o = this.getMediaSessionId();
                        O.default.getMediaEngine().getCodecSurvey().then(e => {
                            let t = JSON.parse(e);
                            if (null == t || null == t.available_video_encoders || null == t.available_video_decoders) throw Error("codec survey is not available");
                            y.default.track(K.AnalyticEvents.VOICE_CODEC_DETECTED, {
                                ...t,
                                rtc_connection_id: this.getRTCConnectionId(),
                                media_session_id: o
                            })
                        }).catch(e => {
                            this.logger.warn(e)
                        })
                    }
                    if (this._pingTimeouts = [], this._pings = [], this._connectCompletedTime = 0, this._pingBadCount = 0, this._inputDetected = !1, this._mediaSessionId = null, null === (s = this._voiceQuality) || void 0 === s || s.stop(), this._voiceQuality = null, clearInterval(this._voiceQualityPeriodicStatsInterval), this._voiceQualityPeriodicStatsInterval = null, this._voiceQualityPeriodicStatsSequenceId = 0, null === (a = this._voiceDuration) || void 0 === a || a.stop(), this._voiceDuration = null, null === (o = this._videoQuality) || void 0 === o || o.stop(), this._videoQuality = null, this._videoHealthManager = null, null === (r = this._localMediaSinkWantsManager) || void 0 === r || r.reset(), null != this._connection) {
                        let e = this._connection;
                        this._connection = null, e.destroy()
                    }
                    this.setState(K.RTCConnectionStates.DISCONNECTED, {
                        willReconnect: u
                    })
                }
                _handleResuming(e) {
                    var t, n;
                    null === (t = this._connection) || void 0 === t || t.fastUdpReconnect(), null === (n = this._connection) || void 0 === n || n.clearAllSpeaking()
                }
                _handleReady(e, t, n, i, s, a, r) {
                    var l;
                    this.setState(K.RTCConnectionStates.RTC_CONNECTING), this.port = n, null != r && this._chooseExperiments(r), 0 === a.length && a.push({
                        type: Y.MediaTypes.VIDEO,
                        rid: "100",
                        ssrc: s + 1,
                        rtxSsrc: s + 2,
                        quality: 100,
                        active: !1
                    });
                    let u = O.default.getMediaEngine(),
                        d = u.connect(this.context, {
                            userId: this.userId,
                            channelId: null != this.rtcServerId ? o(this.rtcServerId).prev().toString() : this._channelId,
                            guildId: null !== (l = this.rtcServerId) && void 0 !== l ? l : this.guildId
                        }, {
                            ssrc: s,
                            address: t,
                            port: n,
                            modes: i,
                            experiments: this._selectedExperiments,
                            streamParameters: a,
                            qosEnabled: O.default.getQoS(),
                            ...this._getExtraConnectionOptions()
                        });
                    if (d.setUseElectronVideo(u.supports(Y.Features.ELECTRON_VIDEO)), O.default.supports(Y.Features.IMAGE_QUALITY_MEASUREMENT)) {
                        let {
                            enabled: e,
                            measurement: t
                        } = I.default.getConfig(!0), {
                            enabled: n
                        } = A.default.getCurrentConfig({
                            location: "handleReady"
                        }, {
                            autoTrackExposure: !0
                        });
                        e && d.setVideoQualityMeasurement(t + (n ? ",hwdec" : ""))
                    }
                    let c = ["unk"];
                    if (O.default.supports(Y.Features.AMD_EXPERIMENTAL_RATE_CONTROL)) {
                        let {
                            amdRelaxedRc: e
                        } = C.default.getCurrentConfig({
                            location: "handleReady"
                        }, {
                            autoTrackExposure: !0
                        });
                        e && c.push("amdRelaxRc")
                    }
                    d.setVideoEncoderExperiments(c.join(",")), d.on(f.BaseConnectionEvent.Speaking, (e, t, n) => {
                        this.userId === e && this.sendSpeaking(t, n), this.emit(V.RTCConnectionEvent.Speaking, e, t)
                    }), d.on(f.BaseConnectionEvent.Video, (e, t, n, i, s, a) => {
                        this._handleVideoStreamId({
                            userId: e,
                            streamId: t,
                            audioSsrc: n,
                            videoSsrc: null != i ? i : 0,
                            rtxSsrc: s,
                            videoStreamParameters: a
                        }), this.userId === e && (this.sendVideo(null != n ? n : 0, null != i ? i : 0, null != s ? s : 0, a), null == a || a.forEach(t => {
                            100 === t.quality && this.emit(V.RTCConnectionEvent.VideoSourceQualityChanged, this.guildId, this.channelId, e, t.maxResolution, t.maxFrameRate, this.context)
                        }))
                    }), d.on(f.BaseConnectionEvent.FirstFrame, (e, t, n) => {
                        null != this._localMediaSinkWantsManager && (this._localMediaSinkWantsManager.setFirstFrameReceived(t), this.emit(V.RTCConnectionEvent.Video, this.guildId, this.channelId, e, n, this.rtcServerId))
                    }), d.on(f.BaseConnectionEvent.Silence, e => {
                        this._inputDetected = this._inputDetected || !e
                    }), d.on(f.BaseConnectionEvent.Connected, (i, s) => {
                        if (this.logger.info("RTC connected to media server: ".concat(t, ":").concat(n)), e !== this._socket) {
                            this.logger.warn("Socket mismatch, disconnecting");
                            return
                        }
                        switch (this._voiceQuality = new W.default(d), this._voiceQuality.start(), this._voiceQualityPeriodicStatsSequenceId = 0, this._voiceQualityPeriodicStatsInterval = setInterval(this._handleVoiceQualityPeriodicsStats, 3e5), this._voiceDuration = new H.default(this.userId, d), this._voiceDuration.start(), this.protocol = i, i) {
                            case "udp":
                                this.logger.info("Sending UDP info to RTC server.", s, this._selectedExperiments), e.once(U.SocketEvent.Encryption, (e, t) => {
                                    d === this._connection && (d.setEncryption(e, t), this._encryptionMode = e)
                                }), e.selectProtocol(i, this.getRTCConnectionId(), s, this._selectedExperiments);
                                break;
                            case "webrtc":
                                this.logger.info("Sending local SDP to RTC server."), e.once(U.SocketEvent.SDP, this._handleSDP.bind(this)), e.selectProtocol(i, this.getRTCConnectionId(), s);
                                break;
                            default:
                                this.logger.error("Unable to determine protocol.");
                                return
                        }
                        this._backoff.succeed()
                    }), d.on(f.BaseConnectionEvent.VideoEncoderFallback, t => {
                        let n = t.filter(e => "video" === e.type).map(e => e.name).join(",");
                        this.logger.info("The originally selected video encoder is not working, fallback to the other available encoders:" + n), e.updateSession({
                            codecs: t
                        })
                    }), d.on(f.BaseConnectionEvent.Error, t => {
                        if (e !== this._socket) return;
                        let n = b.default.shouldIncludePreferredRegion() ? b.default.getPreferredRegion() : null;
                        this.logger.error("Error occurred while connecting to RTC server: ".concat(t)), y.default.track(K.AnalyticEvents.VOICE_CONNECTION_FAILURE, {
                            ...this._getAnalyticsProperties(),
                            hostname: this.hostname,
                            port: this.port,
                            protocol: this.protocol,
                            error: t,
                            cloudflare_best_region: n,
                            connect_count: this._connectCount
                        })
                    }), d.on(f.BaseConnectionEvent.ConnectionStateChange, t => {
                        if (this.logger.info("RTC media connection state change: ".concat(this.state, " => ").concat(t)), e !== this._socket) return;
                        let n = this.state;
                        switch (t) {
                            case Y.ConnectionStates.DISCONNECTED:
                                this.setState(K.RTCConnectionStates.RTC_DISCONNECTED);
                                break;
                            case Y.ConnectionStates.CONNECTING:
                                this.setState(K.RTCConnectionStates.RTC_CONNECTING);
                                break;
                            case Y.ConnectionStates.CONNECTED:
                                this.setState(K.RTCConnectionStates.RTC_CONNECTED);
                                break;
                            case Y.ConnectionStates.NO_ROUTE:
                                this.setState(K.RTCConnectionStates.NO_ROUTE);
                                break;
                            case Y.ConnectionStates.ICE_CHECKING:
                                this.setState(K.RTCConnectionStates.ICE_CHECKING);
                                break;
                            case Y.ConnectionStates.DTLS_CONNECTING:
                                this.setState(K.RTCConnectionStates.DTLS_CONNECTING)
                        }
                        if (n === K.RTCConnectionStates.RTC_CONNECTING && this.state === K.RTCConnectionStates.RTC_DISCONNECTED ? this.reconnect() : this.state === K.RTCConnectionStates.NO_ROUTE && this._backoff.fail(this.reconnect), this.state === K.RTCConnectionStates.RTC_CONNECTED) {
                            var i;
                            let e = b.default.shouldIncludePreferredRegion() ? b.default.getPreferredRegion() : null;
                            this._connecting && y.default.track(K.AnalyticEvents.VOICE_CONNECTION_SUCCESS, {
                                ...this._getAnalyticsProperties(),
                                hostname: this.hostname,
                                port: this.port,
                                protocol: this.protocol,
                                cloudflare_best_region: e,
                                connect_time: (0, m.now)() - (this._connected ? this._connectStartTime : this._createdTime),
                                connect_count: this._connectCount,
                                audio_subsystem: O.default.getMediaEngine().getAudioSubsystem(),
                                audio_layer: O.default.getMediaEngine().getAudioLayer(),
                                media_session_id: this.getMediaSessionId(),
                                ...this.stateHistory.getVoiceConnectionSuccessStats()
                            }), null === (i = this._localMediaSinkWantsManager) || void 0 === i || i.setConnection(d), this._connectCompletedTime = (0, m.now)(), this._connected = !0, this._connecting = !1, this._encountered_socket_failure = !1
                        } else n === K.RTCConnectionStates.RTC_CONNECTED && this.stateHistory.reset(this.state)
                    }), d.on(f.BaseConnectionEvent.Ping, this._handlePing.bind(this)), d.on(f.BaseConnectionEvent.PingTimeout, this._handlePingTimeout.bind(this)), d.on(f.BaseConnectionEvent.OutboundLossRate, this._handleOutboundLossRate.bind(this)), d.on(f.BaseConnectionEvent.SoundshareTrace, this._handleSoundshareTrace.bind(this)), d.on(f.BaseConnectionEvent.LocalVideoDisabled, this._handleLocalVideoDisabled.bind(this)), d.on(f.BaseConnectionEvent.Stats, w.default.create()), d.on(f.BaseConnectionEvent.RemoteStreamsReady, this._handleRemoteStreamsReady.bind(this)), d.setRemoteVideoSinkWants(this._remoteVideoSinkWants), this._connection = d
                }
                _handleSpeaking(e, t, n, i) {
                    let s = this._connection;
                    if (null != s && this.userId !== t) {
                        var a;
                        i !== Y.SpeakingFlags.NONE && (s.createUser(t, n), E.default.dispatch({
                            type: "RTC_CONNECTION_USER_CREATE_SSRC",
                            userId: t,
                            ssrc: n,
                            context: this.context
                        })), null === (a = this._localMediaSinkWantsManager) || void 0 === a || a.setAudioSSRC(t, n)
                    }
                }
                handleFlags(e, t) {
                    this.emit(V.RTCConnectionEvent.Flags, e, t)
                }
                handlePlatform(e, t) {
                    this.emit(V.RTCConnectionEvent.Platform, e, t, this.channelId)
                }
                getOrCreateVideoQuality() {
                    if (null != this._connection && null == this._videoQuality) {
                        var e, t, n, i;
                        this._videoQuality = new G.VideoQuality(this._connection), this._videoQuality.start()
                    }
                    return this._videoQuality
                }
                _handleVideoStreamId(e) {
                    var t, n, i, s;
                    let {
                        userId: a,
                        streamId: o,
                        videoSsrc: r,
                        videoStreamParameters: l
                    } = e;
                    if (this.emit(V.RTCConnectionEvent.Video, this.guildId, this.channelId, a, o, this.rtcServerId), null != o && null == this.getOrCreateVideoQuality() && this.logger.error("_handleVideoStreamId: Unable to create videoQuality."), null != this._videoQuality && this.userId === a && l.forEach(e => {
                            var t, n;
                            let i = null !== (t = e.ssrc) && void 0 !== t ? t : 0;
                            i > 0 && !0 === e.active && (null === (n = this._videoQuality) || void 0 === n || n.setOutboundSsrc(i))
                        }), this.userId !== a) {
                        let e = 0 === r && null === o,
                            s = !e || e && (null === (t = this._videoQuality) || void 0 === t ? void 0 : t.getInboundParticipants().includes(a));
                        s && (null === (n = this._videoQuality) || void 0 === n || n.setInboundUser(a, r), null === (i = this._videoHealthManager) || void 0 === i || i.createUser(a))
                    }
                    null != this._connection && this.userId !== a && (null === (s = this._localMediaSinkWantsManager) || void 0 === s || s.setStreamId(a, o))
                }
                _handleLocalVideoDisabled(e, t) {
                    if (this.userId !== e) {
                        let n = this.getOrCreateVideoQuality();
                        if (null == n) {
                            this.logger.error("_handleLocalVideoDisabled: Unable to create videoQuality.");
                            return
                        }
                        n.setUserVideoDisabled(e, t)
                    }
                }
                _handleRemoteStreamsReady(e) {
                    let t = (0, m.now)() - this._connectStartTime;
                    y.default.track(K.AnalyticEvents.VOICE_CONNECTION_REMOTE_STREAMS_CREATED, {
                        number_of_users: e,
                        duration_ms: t,
                        guild_id: this.guildId,
                        channel_id: this.channelId,
                        rtc_connection_id: this.getRTCConnectionId()
                    })
                }
                _handleVideo(e, t, n, i, s) {
                    let a = this._connection;
                    if (null != a && this.userId !== t) {
                        if (null != this._localMediaSinkWantsManager) {
                            this._localMediaSinkWantsManager.setAudioSSRC(t, n);
                            let e = s.map(e => ({
                                type: Y.MediaTypes.VIDEO,
                                rid: e.rid,
                                ssrc: e.ssrc,
                                rtxSsrc: e.rtxSsrc,
                                quality: e.quality,
                                active: i > 0
                            }));
                            0 === e.length && e.push({
                                type: Y.MediaTypes.VIDEO,
                                rid: "100",
                                ssrc: i,
                                rtxSsrc: i + 1,
                                quality: 100,
                                active: i > 0
                            }), this._localMediaSinkWantsManager.setVideoSSRCs(t, e)
                        } else a.createUser(t, n, [i]);
                        null == s || s.forEach(e => {
                            100 === e.quality && this.emit(V.RTCConnectionEvent.VideoSourceQualityChanged, this.guildId, this.channelId, t, e.maxResolution, e.maxFrameRate, this.context)
                        })
                    }
                }
                _handleControlPing(e) {
                    !O.default.supports(Y.Features.NATIVE_PING) && this._handlePing(e)
                }
                _handlePing(e) {
                    if (void 0 !== e) {
                        for (this._pings.push({
                                time: Date.now(),
                                value: e
                            }); this._pings.length >= 200;) this._pings.shift();
                        e > 500 && this._pingBadCount++, this.emit(V.RTCConnectionEvent.Ping, this._pings, this.quality)
                    }
                }
                _handlePingTimeout(e, t) {
                    this._pingTimeouts.push(e);
                    let n = this._pingTimeouts.length;
                    n >= 3 && this._pingTimeouts[n - 1] === this._pingTimeouts[n - 2] + 1 && this._pingTimeouts[n - 2] === this._pingTimeouts[n - 3] + 1 && this._handlePing(t)
                }
                _handleOutboundLossRate(e) {
                    this._outboundLossRate = e, this.emit(V.RTCConnectionEvent.OutboundLossRate, e)
                }
                _handleSoundshareTrace(e) {
                    this._soundshareStats.traceEvent(void 0, e)
                }
                _getAnalyticsProperties() {
                    return {
                        guild_id: this.guildId,
                        channel_id: this.channelId,
                        rtc_connection_id: this.getRTCConnectionId(),
                        context: this.context,
                        voice_backend_version: this.voiceVersion,
                        rtc_worker_backend_version: this.rtcWorkerVersion
                    }
                }
                _handleClientDisconnect(e) {
                    var t, n, i;
                    let s = this._videoQuality;
                    if (null != s && this.context === Y.MediaEngineContextTypes.DEFAULT) {
                        let t = s.getInboundStats(e),
                            a = null !== (n = null == t ? void 0 : t.num_frames) && void 0 !== n ? n : 0;
                        null != t && a > 0 && (y.default.track(K.AnalyticEvents.VIDEO_STREAM_ENDED, {
                            ...this._getAnalyticsProperties(),
                            media_session_id: this.getMediaSessionId(),
                            sender_user_id: e,
                            reason: "User disconnected",
                            participant_type: "receiver",
                            guild_region: b.default.getRegion(this.hostname),
                            hostname: this.hostname,
                            ...t,
                            ...s.getNetworkStats(),
                            ...s.getCodecUsageStats("receiver", e)
                        }), s.destroyUser(e), null === (i = this._videoHealthManager) || void 0 === i || i.deleteUser(e))
                    }
                    let a = this._connection;
                    null != a && a.destroyUser(e), null === (t = this._localMediaSinkWantsManager) || void 0 === t || t.destroyUser(e)
                }
                _handleCodecs(e, t) {
                    let n = this._connection;
                    null != n && null != this.protocol ? n.setCodecs(null != e && "" !== e ? e : Y.Codecs.OPUS, null != t && "" !== t ? t : Y.Codecs.H264, this.context) : this.logger.warn("Cannot set codecs on connection with protocol:", this.protocol)
                }
                _handleSDP(e) {
                    let t = this._connection;
                    null != t && null != this.protocol ? t.setSDP(e) : this.logger.warn("Cannot set SDP on connection with protocol:", this.protocol)
                }
                async _handleMediaSessionId(e) {
                    var t;
                    this._mediaSessionId = e, this.logger.info("Setting media-session-id: ".concat(e, " for rtc-connection-id: ").concat(this.getRTCConnectionId()));
                    let n = await (0, v.default)();
                    y.default.track(K.AnalyticEvents.MEDIA_SESSION_JOINED, {
                        ...this._getAnalyticsProperties(),
                        media_session_id: this.getMediaSessionId(),
                        parent_media_session_id: this.parentMediaSessionId,
                        channel_type: null === (t = D.default.getChannel(this.channelId)) || void 0 === t ? void 0 : t.type,
                        raw_thermal_state: n
                    }), E.default.dispatch({
                        type: "MEDIA_SESSION_JOINED",
                        mediaSessionId: this.getMediaSessionId(),
                        context: this.context
                    })
                }
                _handleMediaSinkWants(e) {
                    let t = this._connection;
                    this.logger.info("Remote media sink wants: ".concat(JSON.stringify(e))), this._remoteVideoSinkWants = e, null == t || t.setRemoteVideoSinkWants(e)
                }
                _handleCodeVersion(e, t) {
                    this.voiceVersion = e, this.rtcWorkerVersion = t
                }
                _handleKeyframeInterval(e) {
                    let t = this._connection;
                    null != t && null != this.protocol ? t.setKeyframeInterval(e) : this.logger.warn("Cannot set keyframe interval on connection with protocol:", this.protocol)
                }
                _handleUpdateRtcLog(e) {
                    var t;
                    this.rtcLogEphemeralKey = e, null === (t = this._connection) || void 0 === t || t.setRtcLogEphemeralKey(e)
                }
                _handleBandwidthEstimationExperiment(e) {
                    this._bandwidthEstimationExperiment = e;
                    let t = T.default.getMediaEngineExperiments(e);
                    if (null !== t && 0 !== t.length) {
                        var n;
                        null === (n = this._connection) || void 0 === n || n.setBandwidthEstimationExperiments(t)
                    }
                }
                _trackSecureFrameTransition(e, t) {
                    y.default.track(K.AnalyticEvents.SECURE_FRAMES_TRANSITION, {
                        ...this._getAnalyticsProperties(),
                        media_session_id: this.getMediaSessionId(),
                        parent_media_session_id: this.parentMediaSessionId,
                        sender_user_id: this.userId,
                        transition_id: e,
                        protocol_version: t
                    })
                }
                _handleSecureFramesInit(e) {
                    var t;
                    e > 0 && this.logger.info("Secure frames init with protocol version: ".concat(e)), null === (t = this._connection) || void 0 === t || t.prepareSecureFramesTransition(0, e, () => {
                        var t;
                        e > 0 && this._trackSecureFrameTransition(0, e), null === (t = this._connection) || void 0 === t || t.executeSecureFramesTransition(0)
                    })
                }
                _handleSecureFramesPrepareTransition(e, t, n) {
                    var i;
                    this.logger.info("Preparing secure frames transition: ".concat(t, ", protocol version: ").concat(n)), null === (i = this._connection) || void 0 === i || i.prepareSecureFramesTransition(t, n, () => {
                        this.logger.info("Sending secure frames ready for transition: ".concat(t)), e.secureFramesReadyForTransition(t), this._trackSecureFrameTransition(t, n)
                    })
                }
                _handleSecureFramesExecuteTransition(e) {
                    var t;
                    this.logger.info("Executing secure frames transition: ".concat(e)), null === (t = this._connection) || void 0 === t || t.executeSecureFramesTransition(e)
                }
                _getExtraConnectionOptions() {
                    return {}
                }
                shouldReportPeriodicStats(e) {
                    if (e.length > 10) return !1;
                    let {
                        enableSendingVoiceStats: t,
                        percentageOfCalls: n
                    } = N.default.getCurrentConfig({
                        location: "104dee_3"
                    }, {
                        autoTrackExposure: !1
                    });
                    if (!t) return !1;
                    let i = this.getMediaSessionId();
                    if (null == i) return !1;
                    let s = l.v3(i);
                    return !!(s % 100 <= n) || !1
                }
                getInputDeviceName() {
                    var e;
                    let t = O.default.getInputDeviceId(),
                        n = null === (e = O.default.getInputDevices()[t]) || void 0 === e ? void 0 : e.name;
                    return n
                }
                getOutputDeviceName() {
                    var e;
                    let t = O.default.getOutputDeviceId(),
                        n = null === (e = O.default.getOutputDevices()[t]) || void 0 === e ? void 0 : e.name;
                    return n
                }
                getGoLiveSource() {
                    return O.default.getGoLiveSource()
                }
                constructor({
                    userId: e,
                    sessionId: t,
                    guildId: n,
                    channelId: i,
                    context: s = Y.MediaEngineContextTypes.DEFAULT,
                    rtcServerId: a,
                    parentMediaSessionId: o
                }) {
                    var r, l;
                    if (super(), this.reconnect = () => {
                            let e = this._socket;
                            null != e && (this._connected && (this._connectStartTime = (0, m.now)()), !this._connecting && (this._trackVoiceConnectionConnecting(), this._connecting = !0, this._encountered_socket_failure = !1), this._connectCount++, e.close(), e.connect())
                        }, this._handleNetworkOnline = () => {
                            this.expeditedHeartbeat(5e3, "network detected online.")
                        }, this._handleNetworkOffline = () => {
                            this.expeditedHeartbeat(15e3, "network detected offline.", !1)
                        }, this._handlePowerResume = () => {
                            this.expeditedHeartbeat(5e3, "power monitor resumed")
                        }, this._handleVoiceQualityPeriodicsStats = () => {
                            if (null != this._voiceQuality) {
                                let e = this._voiceQuality.getPeriodicStats();
                                if (this.shouldReportPeriodicStats(e)) {
                                    let t = D.default.getChannel(this.channelId),
                                        n = null != t ? t.type : null;
                                    for (let t of e) y.default.track(K.AnalyticEvents.VOICE_QUALITY_PERIODIC_STATS, {
                                        ...this._getAnalyticsProperties(),
                                        media_session_id: this.getMediaSessionId(),
                                        sender_user_id: t.userId,
                                        channel_type: n,
                                        hostname: this.hostname,
                                        frame_op_silent: t.silent,
                                        frame_op_normal: t.normal,
                                        frame_op_merged: t.merged,
                                        frame_op_expanded: t.expanded,
                                        frame_op_accelerated: t.accelerated,
                                        frame_op_preemptive_expanded: t.preemptiveExpanded,
                                        frame_op_cng: t.cng,
                                        accelerate_rate: t.accelerateRate,
                                        expand_rate: t.expandRate,
                                        preemptive_expand_rate: t.preemptiveExpandRate,
                                        speech_expand_rate: t.speechExpandRate,
                                        duration_ms: t.durationMs,
                                        sequence_id: this._voiceQualityPeriodicStatsSequenceId,
                                        input_device: this.getInputDeviceName(),
                                        output_device: this.getOutputDeviceName(),
                                        ping_average: Math.round(this.getAveragePing()),
                                        ping_bad_count: this._pingBadCount
                                    })
                                }
                                this._voiceQualityPeriodicStatsSequenceId++
                            }
                        }, this._trackVoiceConnectionConnecting = () => {
                            y.default.track(K.AnalyticEvents.VOICE_CONNECTION_CONNECTING, {
                                guild_id: this.guildId,
                                channel_id: this.channelId,
                                rtc_connection_id: this.getRTCConnectionId(),
                                hostname: this.hostname,
                                connect_count: this._connectCount,
                                context: this.context
                            })
                        }, this.context = s, this.logger = new S.default("RTCConnection(".concat(null !== (r = null != a ? a : n) && void 0 !== r ? r : i, ", ").concat(this.context, ")")), this.userId = e, this.sessionId = t, this.guildId = n, this._channelId = i, this.channelIds = new Set([i]), this.rtcServerId = a, this.parentMediaSessionId = o, this._endpoint = null, this.hostname = null, this.port = null, this.token = null, this.voiceVersion = null, this.rtcWorkerVersion = null, this.state = K.RTCConnectionStates.AWAITING_ENDPOINT, this.stateHistory = new M.StateHistory(this.state), this._socket = null, this._backoff = new h.default(1e3, 1e4), this._destroyed = !1, this._pings = [], this._pingBadCount = 0, this._pingTimeouts = [], this._mediaSessionId = null, this._voiceQuality = null, this._voiceQualityPeriodicStatsInterval = null, this._voiceQualityPeriodicStatsSequenceId = 0, this._voiceDuration = null, this._videoQuality = null, this._videoHealthManager = null, this._sentVideo = !1, this._outboundLossRate = null, this._createdTime = (0, m.now)(), this._connectStartTime = 0, this._connectCompletedTime = 0, this._rtcConnectionId = (0, c.v4)(), this._connectCount = 0, this._connected = !1, this._connecting = !1, this._encountered_socket_failure = !1, this._inputDetected = !1, this._selectedExperiments = [], s === Y.MediaEngineContextTypes.DEFAULT) {
                        let t = O.default.supports(Y.Features.FIRST_FRAME_CALLBACK) && O.default.supports(Y.Features.REMOTE_USER_MULTI_STREAM),
                            n = (null === (l = D.default.getChannel(this.channelId)) || void 0 === l ? void 0 : l.type) === K.ChannelTypes.GUILD_STAGE_VOICE;
                        this._localMediaSinkWantsManager = new x.default(e, n, t), this._localMediaSinkWantsManager.on(x.RTCMediaSinkWantsManagerEvent.Update, e => {
                            if (this.state === K.RTCConnectionStates.RTC_CONNECTED && null != this._socket) {
                                var t;
                                this.logger.info("Media sink wants: ".concat(JSON.stringify(e))), this._socket.mediaSinkWants(e), null === (t = this._connection) || void 0 === t || t.setLocalVideoSinkWants(e)
                            }
                        }), this._localMediaSinkWantsManager.on(x.RTCMediaSinkWantsManagerEvent.UserSSRCUpdate, (e, t, n) => {
                            var i;
                            null === (i = this._connection) || void 0 === i || i.createUser(e, t, n)
                        })
                    }
                    this._remoteVideoSinkWants = x.DEFAULT_WANTS_FULL, R.default.shouldRecordNextConnection() ? (this._recordingEnabled = !0, g.setShouldRecordNextConnection(!1)) : this._recordingEnabled = !1, this._soundshareStats = new F.default, P.default.addOnlineCallback(this._handleNetworkOnline), P.default.addOfflineCallback(this._handleNetworkOffline), (0, L.isDesktop)() && (this.powerMonitorListener = k.default.remotePowerMonitor.on("resume", this._handlePowerResume)), this._supportedBandwidthEstimationExperiments = [], this._bandwidthEstimationExperiment = null, O.default.getMediaEngine().getSupportedBandwidthEstimationExperiments(e => {
                        this._supportedBandwidthEstimationExperiments = e
                    })
                }
            }
        },
        422791: function(e, t, n) {
            "use strict";
            var i, s;
            n.r(t), n.d(t, {
                RTCConnectionEvent: function() {
                    return i
                }
            }), (s = i || (i = {})).State = "state", s.Speaking = "speaking", s.VideoSourceQualityChanged = "video-source-quality-changed", s.Video = "video", s.Flags = "flags", s.Platform = "platform", s.Ping = "ping", s.OutboundLossRate = "outboundlossrate"
        },
        642099: function(e, t, n) {
            "use strict";
            n.r(t), n.d(t, {
                StateHistory: function() {
                    return l
                }
            }), n("424973");
            var i = n("917351"),
                s = n.n(i),
                a = n("398183"),
                o = n("713725"),
                r = n("49111");
            class l {
                reset(e) {
                    this.current = null, this.history = [], null != e && this.update(e)
                }
                update(e) {
                    this.current !== e && (this.current = e, this.history.push({
                        state: e,
                        startTime: (0, a.now)()
                    }))
                }
                getVoiceConnectionSuccessStats() {
                    let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : (0, a.now)(),
                        t = this.getStateDurations(e),
                        n = e => s.sumBy(t, t => t.state === e ? t.durationMs : 0);
                    return {
                        state_awaiting_endpoint_ms: n(r.RTCConnectionStates.AWAITING_ENDPOINT),
                        state_authenticating_ms: n(r.RTCConnectionStates.AUTHENTICATING),
                        state_connecting_ms: n(r.RTCConnectionStates.CONNECTING),
                        state_disconnected_ms: n(r.RTCConnectionStates.DISCONNECTED),
                        state_ice_checking_ms: n(r.RTCConnectionStates.ICE_CHECKING),
                        state_no_route_ms: n(r.RTCConnectionStates.NO_ROUTE),
                        state_rtc_connecting_ms: n(r.RTCConnectionStates.RTC_CONNECTING),
                        state_rtc_disconnected_ms: n(r.RTCConnectionStates.RTC_DISCONNECTED)
                    }
                }
                getStateDurations(e) {
                    if (0 === this.history.length) return [];
                    let t = (0, o.default)(this.history, (e, t) => ({
                        state: e.state,
                        durationMs: t.startTime - e.startTime
                    }));
                    return t.push((() => {
                        let t = s.last(this.history);
                        return {
                            state: t.state,
                            durationMs: e - t.startTime
                        }
                    })()), t
                }
                constructor(e) {
                    this.current = null, this.history = [], null != e && this.update(e)
                }
            }
        },
        417040: function(e, t, n) {
            "use strict";
            n.r(t), n.d(t, {
                SocketEvent: function() {
                    return o
                },
                default: function() {
                    return r
                }
            }), n("702976");
            var i, s, a, o, r, l, u, d, c, h = n("627445"),
                p = n.n(h),
                f = n("981980"),
                m = n("595275"),
                E = n("605250"),
                g = n("313915"),
                S = n("773336"),
                _ = n("353927");

            function v() {}(l = i || (i = {}))[l.IDENTIFY = 0] = "IDENTIFY", l[l.SELECT_PROTOCOL = 1] = "SELECT_PROTOCOL", l[l.READY = 2] = "READY", l[l.HEARTBEAT = 3] = "HEARTBEAT", l[l.SELECT_PROTOCOL_ACK = 4] = "SELECT_PROTOCOL_ACK", l[l.SPEAKING = 5] = "SPEAKING", l[l.HEARTBEAT_ACK = 6] = "HEARTBEAT_ACK", l[l.RESUME = 7] = "RESUME", l[l.HELLO = 8] = "HELLO", l[l.RESUMED = 9] = "RESUMED", l[l.VIDEO = 12] = "VIDEO", l[l.CLIENT_DISCONNECT = 13] = "CLIENT_DISCONNECT", l[l.SESSION_UPDATE = 14] = "SESSION_UPDATE", l[l.MEDIA_SINK_WANTS = 15] = "MEDIA_SINK_WANTS", l[l.VOICE_BACKEND_VERSION = 16] = "VOICE_BACKEND_VERSION", l[l.CHANNEL_OPTIONS_UPDATE = 17] = "CHANNEL_OPTIONS_UPDATE", l[l.FLAGS = 18] = "FLAGS", l[l.SPEED_TEST = 19] = "SPEED_TEST", l[l.PLATFORM = 20] = "PLATFORM", l[l.SECURE_FRAMES_ANNOUNCE_TRANSITION = 21] = "SECURE_FRAMES_ANNOUNCE_TRANSITION", l[l.SECURE_FRAMES_EXECUTE_TRANSITION = 22] = "SECURE_FRAMES_EXECUTE_TRANSITION", l[l.SECURE_FRAMES_READY_FOR_TRANSITION = 23] = "SECURE_FRAMES_READY_FOR_TRANSITION", (u = s || (s = {}))[u.AUTHENTICATION_FAILED = 4004] = "AUTHENTICATION_FAILED", u[u.INVALID_SESSION = 4006] = "INVALID_SESSION", u[u.SERVER_NOT_FOUND = 4011] = "SERVER_NOT_FOUND", u[u.SERVER_CRASH = 4015] = "SERVER_CRASH", u[u.CANCELED = 4016] = "CANCELED", u[u.HEARTBEAT_TIMEOUT = 4800] = "HEARTBEAT_TIMEOUT", u[u.UNRESUMABLE = 4801] = "UNRESUMABLE", u[u.RESET_BACKOFF = 4802] = "RESET_BACKOFF", (d = a || (a = {}))[d.DISCONNECTED = 0] = "DISCONNECTED", d[d.CONNECTING = 1] = "CONNECTING", d[d.IDENTIFYING = 2] = "IDENTIFYING", d[d.RESUMING = 3] = "RESUMING", d[d.CONNECTED = 4] = "CONNECTED", d[d.RECONNECTING = 5] = "RECONNECTING";

            function C(e) {
                return e.map(e => ({
                    name: e.name,
                    type: e.type,
                    priority: 1e3 * e.priority,
                    payload_type: e.payloadType,
                    rtx_payload_type: e.rtxPayloadType,
                    encode: e.encode,
                    decode: e.decode
                }))
            }

            function T(e) {
                return null == e ? void 0 : e.map(e => ({
                    type: e.type,
                    rid: e.rid,
                    ssrc: e.ssrc,
                    active: e.active,
                    quality: e.quality,
                    rtx_ssrc: e.rtxSsrc,
                    max_bitrate: e.maxBitrate,
                    max_framerate: e.maxFrameRate,
                    max_resolution: null != e.maxResolution ? {
                        type: e.maxResolution.type,
                        width: e.maxResolution.width,
                        height: e.maxResolution.height
                    } : void 0
                }))
            }

            function I(e) {
                var t;
                return null !== (t = null == e ? void 0 : e.map(e => ({
                    type: function(e) {
                        if ("audio" === e) return _.MediaTypes.AUDIO;
                        if ("test" === e) return _.MediaTypes.TEST;
                        if ("screen" === e) return _.MediaTypes.SCREEN;
                        else return _.MediaTypes.VIDEO
                    }(e.type),
                    rid: e.rid,
                    ssrc: e.ssrc,
                    rtxSsrc: e.rtx_ssrc,
                    active: e.active,
                    quality: e.quality,
                    maxBitrate: e.max_bitrate,
                    maxFrameRate: e.max_framerate,
                    maxResolution: null != e.max_resolution ? {
                        type: e.max_resolution.type,
                        width: e.max_resolution.width,
                        height: e.max_resolution.height
                    } : void 0
                }))) && void 0 !== t ? t : []
            }(c = o || (o = {})).Connecting = "connecting", c.Connect = "connect", c.Disconnect = "disconnect", c.Resuming = "resuming", c.Ready = "ready", c.Speaking = "speaking", c.Video = "video", c.Ping = "ping", c.ClientDisconnect = "client-disconnect", c.Codecs = "codecs", c.MediaSessionId = "media-session-id", c.MediaSinkWants = "media-sink-wants", c.VoiceBackendVersion = "voice-backend-version", c.KeyframeInterval = "keyframe-interval", c.ChannelOptionsUpdateRtcLog = "channel-options-update-rtc-log", c.ChannelOptionsUpdateSecureFramesProtocol = "update-secure-frames-protocol", c.Flags = "flags", c.Platform = "platform", c.SDP = "sdp", c.Encryption = "encryption", c.SpeedTest = "speed-test", c.BandwidthEstimationExperiment = "bandwidth-estimation-experiment", c.SecureFramesInit = "secure-frames-init", c.SecureFramesPrepareTransition = "secure-frames-prepare-transition", c.SecureFramesExecuteTransition = "secure-frames-execute-transition", r = class extends m.default {
                createWebSocket() {
                    this.logger.info("[CONNECT] ".concat(this.url)), null !== this.webSocket && (this.logger.error("Connect called with already existing websocket"), this.cleanupWebSocket(e => e.close(4e3))), this.connectionStartTime = Date.now(), this.helloTimeout = setTimeout(() => {
                        let e = Date.now() - this.connectionStartTime;
                        this.handleClose(!1, 0, "The connection timed out after ".concat(e, " ms - did not receive OP_HELLO in time."))
                    }, 2e4);
                    let e = this.webSocket = new WebSocket("".concat(this.url, "?v=").concat(7));
                    e.onopen = () => {
                        1 === this.connectionState ? this.emit("connect") : 5 === this.connectionState && this.doResumeOrClose(), this.connectionState = 4;
                        let e = Date.now() - this.connectionStartTime;
                        this.logger.info("[CONNECTED] ".concat(this.url, " in ").concat(e, " ms")), this.emit("ping", Math.round(e / 2))
                    }, e.onmessage = e => {
                        let {
                            op: t,
                            d: n
                        } = this.parseWebSocketMessage(e);
                        switch (g.default.isLoggingGatewayEvents && this.logger.info("~> ".concat(t, ": ").concat(JSON.stringify(n))), t) {
                            case 8:
                                this.clearHelloTimeout(), this.handleHello(n);
                                break;
                            case 2:
                                this.handleReady(n);
                                break;
                            case 9:
                                this.handleResumed(n);
                                break;
                            case 4:
                                n.bandwidth_estimation_experiment && this.emit("bandwidth-estimation-experiment", n.bandwidth_estimation_experiment), this.emit("codecs", n.audio_codec, n.video_codec), n.media_session_id && this.emit("media-session-id", n.media_session_id), n.sdp ? this.emit("sdp", n.sdp) : n.mode && this.emit("encryption", n.mode, n.secret_key), n.keyframe_interval && this.emit("keyframe-interval", n.keyframe_interval), this.emit("secure-frames-init", n.secure_frames_version || 0), this.resumable = !0;
                                break;
                            case 5:
                                let i = n.speaking;
                                "boolean" == typeof i && (i = i ? _.SpeakingFlags.VOICE : _.SpeakingFlags.NONE), this.emit("speaking", n.user_id, n.ssrc, i);
                                break;
                            case 3:
                                this.sendHeartbeat();
                                break;
                            case 6:
                                this.emit("ping", Date.now() - n), this.handleHeartbeatAck(n);
                                break;
                            case 12:
                                this.emit("video", n.user_id, n.audio_ssrc, n.video_ssrc, I(n.streams));
                                break;
                            case 13:
                                this.emit("client-disconnect", n.user_id);
                                break;
                            case 14:
                                (null != n.audio_codec || null != n.video_codec) && this.emit("codecs", n.audio_codec, n.video_codec), null != n.media_session_id && this.emit("media-session-id", n.media_session_id), n.keyframe_interval && this.emit("keyframe-interval", n.keyframe_interval);
                                break;
                            case 15:
                                this.emit("media-sink-wants", n);
                                break;
                            case 16:
                                null != n.voice && null != n.rtc_worker && this.emit("voice-backend-version", n.voice, n.rtc_worker);
                                break;
                            case 17:
                                n.rtc_log_ephemeral_key && this.emit("channel-options-update-rtc-log", n.rtc_log_ephemeral_key);
                                break;
                            case 19:
                                this.emit("speed-test", n.op, n);
                                break;
                            case 18:
                                null != n.flags && null != n.user_id && this.emit("flags", n.user_id, n.flags);
                                break;
                            case 20:
                                null != n.platform && null != n.user_id && this.emit("platform", n.user_id, n.platform);
                                break;
                            case 21:
                                null != n.transition_id && null != n.protocol_version && this.emit("secure-frames-prepare-transition", n.transition_id, n.protocol_version);
                                break;
                            case 22:
                                null != n.transition_id && this.emit("secure-frames-execute-transition", n.transition_id);
                                break;
                            default:
                                this.logger.info("Unhandled op ".concat(t))
                        }
                    }, e.onerror = () => this.handleClose(!1, 0, "An error with the websocket occurred"), e.onclose = e => {
                        let {
                            wasClean: t,
                            code: n,
                            reason: i
                        } = e;
                        return this.handleClose(t, n, i)
                    }
                }
                send(e) {
                    let t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : null,
                        n = this.webSocket;
                    if (null == n || n.readyState !== WebSocket.OPEN) return;
                    let i = JSON.stringify({
                        op: e,
                        d: t
                    });
                    g.default.isLoggingGatewayEvents && this.logger.info("<~ ".concat(i));
                    try {
                        n.send(i)
                    } catch (e) {}
                }
                ping() {
                    this.sendHeartbeat()
                }
                doResumeOrClose() {
                    let e = Date.now(),
                        t = null !== this.serverId && null !== this.token && null !== this.sessionId && this.resumable && (null == this.lastHeartbeatAckTime || e - this.lastHeartbeatAckTime <= 6e4);
                    t ? (this.doResume(), this.lastHeartbeatAckTime = e) : this.disconnect(!1, 4801, "Cannot resume connection.")
                }
                doResume() {
                    var e, t;
                    this.logger.info("[RESUME] resuming session. serverId=".concat(null !== (e = this.serverId) && void 0 !== e ? e : "", " sessionId=").concat(null !== (t = this.sessionId) && void 0 !== t ? t : "")), this.emit("resuming"), this.connectionState = 3, this.send(7, {
                        token: this.token,
                        session_id: this.sessionId,
                        server_id: this.serverId
                    })
                }
                handleHello(e) {
                    var t, n, i;
                    if (this.serverVersion = null !== (t = e.v) && void 0 !== t ? t : 3, this.serverVersion <= 3) {
                        let t = S.isPlatformEmbedded ? .25 : .1;
                        this.heartbeatInterval = e.heartbeat_interval * t
                    } else this.heartbeatInterval = e.heartbeat_interval * this.heartbeatIntervalModifier, !S.isPlatformEmbedded && (this.heartbeatInterval = Math.min(5e3, null !== (n = this.heartbeatInterval) && void 0 !== n ? n : NaN));
                    let s = Date.now() - this.connectionStartTime;
                    this.logger.info("[HELLO] heartbeat interval: ".concat(null !== (i = this.heartbeatInterval) && void 0 !== i ? i : "??", ", version: ").concat(this.serverVersion, ", took ").concat(s, " ms")), this.startHeartbeater()
                }
                handleReady(e) {
                    this.backoff.succeed();
                    let t = Date.now() - this.connectionStartTime;
                    this.logger.info("[READY] took ".concat(t, " ms")), this.serverVersion >= 6 && this.send(16, {}), this.emit("ready", e.ip, e.port, e.modes, e.ssrc, I(e.streams), e.experiments)
                }
                handleResumed(e) {
                    this.backoff.succeed()
                }
                handleClose(e, t, n) {
                    if (this.connectionState = 0, e = e || !1, this.cleanupWebSocket(), 4004 === t || 4015 === t || 4011 === t || 4006 === t) return this.disconnect(e, t, n);
                    if (this.backoff.fails > 3) this.logger.warn("[WS CLOSED] Backoff exceed. Resetting."), this.disconnect(e, t, n);
                    else {
                        let i = this.backoff.fail(() => this.reconnect(e, t, n));
                        this.logger.warn("[WS CLOSED] (clean: ".concat(e.toString(), ", code: ").concat(t, ", reason: ").concat(n, ") retrying in ").concat((i / 1e3).toFixed(2), " seconds."))
                    }
                }
                disconnect(e, t, n) {
                    this.logger.warn("[DISCONNECT] (".concat(e.toString(), ", ").concat(t, ", ").concat(n, ")")), this.cleanupWebSocket(), this.cleanupState(), this.connectionState = 0, this.emit("disconnect", e, t, n)
                }
                reconnect(e, t, n) {
                    this.logger.info("[RECONNECT] wasClean=".concat(e.toString(), " code=").concat(t, " reason=").concat(n)), this.cleanupWebSocket(e => e.close(4e3)), this.connectionState = 5, this.createWebSocket()
                }
                cleanupWebSocket(e) {
                    this.stopHeartbeater(), this.clearHelloTimeout();
                    let t = this.webSocket;
                    this.webSocket = null, null != t && (t.onopen = v, t.onmessage = v, t.onerror = v, t.onclose = v, null == e || e(t)), this.backoff.cancel()
                }
                cleanupState() {
                    this.serverId = null, this.sessionId = null, this.token = null, this.resumable = !1
                }
                parseWebSocketMessage(e) {
                    return JSON.parse(e.data)
                }
                clearHelloTimeout() {
                    null != this.helloTimeout && (clearTimeout(this.helloTimeout), this.helloTimeout = null)
                }
                handleHeartbeatAck(e) {
                    this.logger.info("Heartbeat ACK received"), this.lastHeartbeatAckTime = Date.now(), this.heartbeatAck = !0, null !== this.expeditedHeartbeatTimeout && (clearTimeout(this.expeditedHeartbeatTimeout), this.expeditedHeartbeatTimeout = null, this.logger.info("Expedited heartbeat succeeded"))
                }
                handleHeartbeatTimeout() {
                    this.cleanupWebSocket(e => e.close(4e3));
                    let e = this.backoff.fail(() => this.reconnect(!1, 4800, "Heartbeat timeout."));
                    this.logger.warn("[HEARTBEAT ACK TIMEOUT] reconnecting in ".concat((e / 1e3).toFixed(2), " seconds."))
                }
                startHeartbeater() {
                    p(null != this.heartbeatInterval, "RTCControlSocket: Heartbeat interval should never null here."), this.logger.info("Starting heartbeat with interval: ".concat(this.heartbeatInterval)), null !== this.heartbeater && clearInterval(this.heartbeater), this.heartbeatAck = !0, this.heartbeater = setInterval(() => {
                        this.heartbeatAck ? (this.heartbeatAck = !1, this.sendHeartbeat()) : null === this.expeditedHeartbeatTimeout && this.handleHeartbeatTimeout()
                    }, this.heartbeatInterval)
                }
                sendHeartbeat() {
                    this.logger.info("Sending heartbeat"), this.send(3, Date.now())
                }
                stopHeartbeater() {
                    null !== this.heartbeater && (clearInterval(this.heartbeater), this.heartbeater = null), null !== this.expeditedHeartbeatTimeout && (clearTimeout(this.expeditedHeartbeatTimeout), this.expeditedHeartbeatTimeout = null)
                }
                connect() {
                    return 0 !== this.connectionState ? (this.logger.error("Cannot start a new connection, connection state is not disconnected"), !1) : (this.connectionState = 1, this.createWebSocket(), this.emit("connecting"), !0)
                }
                identify(e) {
                    let {
                        serverId: t,
                        userId: n,
                        sessionId: i,
                        token: s,
                        maxSecureFramesVersion: a,
                        video: o = !1,
                        streamParameters: r
                    } = e;
                    this.serverId = t, this.sessionId = i, this.token = s, this.connectionState = 2, this.send(0, {
                        server_id: t,
                        user_id: n,
                        session_id: i,
                        token: s,
                        max_secure_frames_version: a,
                        video: o,
                        streams: T(r)
                    })
                }
                expeditedHeartbeat(e) {
                    let t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : "",
                        n = !(arguments.length > 2) || void 0 === arguments[2] || arguments[2];
                    if (null != this.webSocket) this.logger.info("Performing an expedited heartbeat ".concat("" !== t ? "reason: " + t : "")), this.heartbeatAck = !1, this.sendHeartbeat(), null !== this.expeditedHeartbeatTimeout && clearTimeout(this.expeditedHeartbeatTimeout), this.expeditedHeartbeatTimeout = setTimeout(() => {
                        this.expeditedHeartbeatTimeout = null, !1 === this.heartbeatAck && this.handleHeartbeatTimeout()
                    }, e);
                    else {
                        if (n) return this.resetBackoff(t);
                        this.logger.info("Expedited heartbeat requested, but is disconnected and a reset was not " + "requested ".concat("" !== t ? "reason: " + t : ""))
                    }
                    return !1
                }
                resetBackoff() {
                    let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : "";
                    return !!(this.backoff.fails > 0) && null == this.webSocket && (this.logger.info("Connection backoff reset ".concat("" !== e ? "for reason: " + e : "")), this.backoff.succeed(), this.reconnect(!1, 4802, "Reset backoff."), !0)
                }
                close() {
                    this.logger.info("CLOSE"), this.cleanupWebSocket(e => e.close(4e3)), this.cleanupState(), this.connectionState = 0, this.emit("disconnect", !0, 1e3, "Force Close")
                }
                destroy() {
                    this.close()
                }
                selectProtocol(e, t, n, i) {
                    let s;
                    let a = {};
                    null == n ? s = null : "sdp" in n && null != n.sdp && "" !== n.sdp ? (s = n.sdp, a = {
                        ...n,
                        codecs: C(n.codecs),
                        rtc_connection_id: t
                    }) : "address" in n && null != n.address && "" !== n.address && n.port && null != n.mode && "" !== n.mode && (s = {
                        address: n.address,
                        port: n.port,
                        mode: n.mode
                    }, a = {
                        ...n,
                        codecs: C(n.codecs),
                        rtc_connection_id: t,
                        experiments: i
                    }), this.send(1, {
                        protocol: e,
                        data: s,
                        ...a
                    })
                }
                updateSession(e) {
                    this.send(14, {
                        codecs: C(e.codecs)
                    })
                }
                speaking(e) {
                    let t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : 0,
                        n = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : 0;
                    this.send(5, {
                        speaking: this.serverVersion <= 3 ? !!e : e,
                        delay: t,
                        ssrc: n
                    })
                }
                video(e, t, n, i) {
                    this.send(12, {
                        audio_ssrc: e,
                        video_ssrc: t,
                        rtx_ssrc: n,
                        streams: T(i)
                    })
                }
                mediaSinkWants(e) {
                    this.serverVersion >= 5 && this.send(15, e)
                }
                speedTest(e, t) {
                    this.send(19, {
                        op: e,
                        ...t
                    })
                }
                secureFramesReadyForTransition(e) {
                    this.send(23, {
                        transition_id: e
                    })
                }
                setHeartbeatIntervalModifier(e) {
                    this.heartbeatIntervalModifier = e
                }
                constructor(e) {
                    super(), this.logger = new E.default("RTCControlSocket"), this.backoff = new f.default(1e3, 5e3), this.serverVersion = 0, this.url = e, this.webSocket = null, this.connectionState = 0, this.helloTimeout = null, this.lastHeartbeatAckTime = null, this.heartbeatInterval = null, this.heartbeater = null, this.heartbeatAck = !0, this.expeditedHeartbeatTimeout = null, this.heartbeatIntervalModifier = 1, this.connectionStartTime = 0, this.sessionId = null, this.serverId = null, this.token = null, this.resumable = !1
                }
            }
        },
        716380: function(e, t, n) {
            "use strict";
            n.r(t), n.d(t, {
                DEFAULT_WANTS_FULL: function() {
                    return p
                },
                RTCMediaSinkWantsManagerEvent: function() {
                    return i
                },
                default: function() {
                    return s
                }
            }), n("222007"), n("424973");
            var i, s, a, o = n("595275"),
                r = n("773364"),
                l = n("582663"),
                u = n("233736"),
                d = n("862337"),
                c = n("560528"),
                h = n("49111");
            let p = {
                    any: 100
                },
                f = -1 !== (0, c.getFirefoxVersion)();
            (a = i || (i = {})).UserSSRCUpdate = "user-ssrc-update", a.Update = "update", s = class extends o.default {
                getWantsLevel() {
                    let e = this.getVideoParticipantCount();
                    return this.ladder.getMaxSinkValue(e)
                }
                userVideoDisabled(e) {
                    return this.offscreenDisabledUsers[e]
                }
                getAudioSSRCs() {
                    return this.audioSsrcs
                }
                setConnection(e) {
                    var t, n, i, s, a, o;
                    let l = !(arguments.length > 1) || void 0 === arguments[1] || arguments[1];
                    null === (t = this.connection) || void 0 === t || t.removeListener(r.BaseConnectionEvent.LocalVideoDisabled, this.handleLocalVideoDisabled), null === (n = this.connection) || void 0 === n || n.removeListener(r.BaseConnectionEvent.LocalMute, this.handleLocalMute), null === (i = this.connection) || void 0 === i || i.removeListener(r.BaseConnectionEvent.ActiveSinksChange, this.delayedUpdate), this.connection = e, null === (s = this.connection) || void 0 === s || s.addListener(r.BaseConnectionEvent.LocalVideoDisabled, this.handleLocalVideoDisabled), null === (a = this.connection) || void 0 === a || a.addListener(r.BaseConnectionEvent.LocalMute, this.handleLocalMute), null === (o = this.connection) || void 0 === o || o.addListener(r.BaseConnectionEvent.ActiveSinksChange, this.delayedUpdate), l && this.update()
                }
                setAudioSSRC(e, t) {
                    return t > 0 ? this.audioSsrcs[e] = t : delete this.audioSsrcs[e], this.update()
                }
                setVideoSSRCs(e, t) {
                    let n = t.filter(e => {
                        var t;
                        return e.active && (null !== (t = e.ssrc) && void 0 !== t ? t : 0) > 0
                    }).map(e => {
                        var t;
                        return {
                            quality: null !== (t = e.quality) && void 0 !== t ? t : 100,
                            ssrc: e.ssrc
                        }
                    });
                    if (n.length > 0) this.videoSsrcs[e] = n, this.participants.add(e);
                    else {
                        if (void 0 !== this.videoSsrcs[e])
                            for (let {
                                    ssrc: t
                                }
                                of this.videoSsrcs[e]) delete this.framesReceived[t];
                        delete this.remoteVideoSsrcs[e], delete this.videoSsrcs[e], this.participants.delete(e), this.emit("user-ssrc-update", e, this.audioSsrcs[e], [])
                    }
                    return this.update(Array.from(this.participants))
                }
                setFirstFrameReceived(e) {
                    return this.framesReceived[e] = !0, this.update()
                }
                setStreamId(e, t) {
                    return null != t ? this.streamIds[e] = t : delete this.streamIds[e], this.update()
                }
                destroyUser(e) {
                    return delete this.audioSsrcs[e], delete this.videoSsrcs[e], this.participants.delete(e), delete this.streamIds[e], this.update(Array.from(this.participants))
                }
                reset() {
                    this.setConnection(null, !1), this.audioSsrcs = {}, this.videoSsrcs = {}, this.remoteVideoSsrcs = {}, this.framesReceived = {}, this.streamIds = {}, this.latestWants = p
                }
                setSelectedParticipant(e) {
                    if (e === this.selectedParticipantId) return this.latestWants;
                    let t = [];
                    if (null != this.selectedParticipantId && this.selectedParticipantId !== this.userId && t.push(this.selectedParticipantId), null != e) {
                        if (this.participants.has(e)) this.selectedParticipantId = e, t.push(e);
                        else {
                            if (this.userId !== e) return console.warn("Participant not found: ".concat(e)), this.latestWants;
                            this.selectedParticipantId = e
                        }
                    } else this.selectedParticipantId = null;
                    return this.update(t.filter(e => {
                        var t;
                        return (null === (t = this.videoSsrcs[e]) || void 0 === t ? void 0 : t.length) > 1
                    }))
                }
                setPipOpen(e) {
                    return (this.pipOpen = e, null != this.selectedParticipantId) ? this.update([this.selectedParticipantId]) : this.latestWants
                }
                setAppBackgrounded(e) {
                    let t = arguments.length > 1 && void 0 !== arguments[1] && arguments[1];
                    for (let [i, s] of Object.entries(this.streamIds))
                        if (this.offscreenDisabledUsers[i] = e, null != s) {
                            var n;
                            let i = !e || t;
                            null === (n = this.connection) || void 0 === n || n.setHasActiveVideoOutputSink(s, i)
                        } return this.update()
                }
                getOffscreenDisabledUsers() {
                    return this.offscreenDisabledUsers
                }
                getVideoParticipantCount() {
                    let e = 0;
                    for (let n of Object.keys(this.videoSsrcs)) {
                        var t;
                        !(null === (t = this.connection) || void 0 === t ? void 0 : t.getLocalVideoDisabled(n)) && e++
                    }
                    return e
                }
                getOffscreenTimeoutMs() {
                    return this.isStageChannel ? 12e4 : 3e4
                }
                constructor(e, t, n, i = new l.MediaSinkWantsLadder) {
                    var s;
                    super(), s = this, this.userId = e, this.isStageChannel = t, this.supportsSeamless = n, this.ladder = i, this.connection = null, this.audioSsrcs = {}, this.videoSsrcs = {}, this.remoteVideoSsrcs = {}, this.framesReceived = {}, this.streamIds = {}, this.offscreenUsers = {}, this.offscreenDisabledUsers = {}, this.latestWants = p, this.participants = new Set, this.selectedParticipantId = null, this.pipOpen = !1, this.videoHealthManager = null, this.delayedUpdate = () => {
                        this.delayedCall.delay()
                    }, this.addLru = (e, t, n) => {
                        if (n.push(e), n.length <= 3) return;
                        let i = -1,
                            s = -1;
                        for (let e = 0; e < n.length; e++) {
                            let a = n[e],
                                o = t - this.offscreenUsers[a];
                            o > i && (i = o, s = e)
                        }
                        this.offscreenDisabledUsers[n[s]] = !0, n.splice(s, 1)
                    }, this.updateOffscreenUsers = () => {
                        var e, t;
                        if (!(null === (e = this.connection) || void 0 === e ? void 0 : e.getActiveOutputSinkTrackingEnabled())) return;
                        let n = Date.now(),
                            i = [];
                        for (let [e, s] of Object.entries(this.streamIds))
                            if (null != s) {
                                if (null === (t = this.connection) || void 0 === t ? void 0 : t.getHasActiveVideoOutputSink(s)) delete this.offscreenUsers[e], delete this.offscreenDisabledUsers[e];
                                else if (null == this.offscreenUsers[e]) this.offscreenUsers[e] = n, this.addLru(e, n, i);
                                else if (!this.offscreenDisabledUsers[e]) {
                                    let t = n - this.offscreenUsers[e];
                                    t >= this.getOffscreenTimeoutMs() ? this.offscreenDisabledUsers[e] = !0 : this.addLru(e, n, i)
                                }
                            } if (i.length > 0) {
                            let e = n + this.getOffscreenTimeoutMs();
                            for (let t of i) e = Math.min(e, this.offscreenUsers[t] + this.getOffscreenTimeoutMs());
                            this.offscreenTimeout.start(e - n, this.update)
                        } else this.offscreenTimeout.stop()
                    }, this.handleLocalVideoDisabled = (e, t) => {
                        this.update()
                    }, this.handleLocalMute = (e, t) => {
                        this.update()
                    }, this.update = function() {
                        var e, t, n;
                        let i = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : [],
                            a = s.getWantsLevel(),
                            o = {
                                any: a
                            };
                        for (let [n, r] of(s.updateOffscreenUsers(), Object.entries(s.videoSsrcs))) {
                            let l = [],
                                d = !1,
                                c = r[0].ssrc;
                            if ((null === (e = s.connection) || void 0 === e ? void 0 : e.getLocalVideoDisabled(n)) || s.userVideoDisabled(n) && (null === (t = s.videoHealthManager) || void 0 === t ? void 0 : t.getCurrentVideoToggleState(n)) !== h.VideoToggleState.AUTO_PROBING)
                                for (let e of r) o[e.ssrc] = 0;
                            else {
                                let e = n === s.selectedParticipantId && 100 !== a && !s.pipOpen;
                                if (r.length > 1) {
                                    for (let t of r) 100 === t.quality ? e ? (o[t.ssrc] = 100, c = t.ssrc) : o[t.ssrc] = 0 : e ? o[t.ssrc] = 0 : c = t.ssrc;
                                    if (s.supportsSeamless && !s.framesReceived[c])
                                        for (let e of (d = !0, l = [c], r)) e.ssrc !== c && s.framesReceived[e.ssrc] && (100 === e.quality ? o[e.ssrc] = 100 : o[e.ssrc] = a, l.push(e.ssrc))
                                } else e && (o[c] = 100)
                            }
                            for (let e of ((!s.supportsSeamless || !d) && (l = [c]), r)) !l.includes(e.ssrc) && delete s.framesReceived[e.ssrc];
                            (i.includes(n) || void 0 !== s.remoteVideoSsrcs[n] && !(0, u.default)(s.remoteVideoSsrcs[n], l)) && (s.remoteVideoSsrcs[n] = [...l], s.emit("user-ssrc-update", n, s.audioSsrcs[n], l))
                        }
                        for (let [e, t] of Object.entries(s.audioSsrcs))(null === (n = s.connection) || void 0 === n ? void 0 : n.getLocalMute(e)) && (o[t] = 0);
                        return f ? s.latestWants : (null != s.connection && !(0, u.default)(s.latestWants, o) && (s.latestWants = o, s.emit("update", o)), o)
                    }, this.delayedCall = new d.DelayedCall(100, this.update), this.offscreenTimeout = new d.Timeout
                }
            }
        },
        157547: function(e, t, n) {
            "use strict";
            var i;
            n.r(t), n.d(t, {
                default: function() {
                    return i
                }
            }), n("222007"), i = class {
                traceEvent(e, t) {
                    let n;
                    let i = this._report;
                    void 0 !== i[n = "soundshare_state_transition" === t.type ? "soundshare_state_transition_".concat(["detached", "waiting", "attached", "started", "playing", "silence"][t.newState], "_count") : "".concat(t.type, "_count")] ? i[n] < 32767 && i[n]++ : i.soundshare_unknown_event_count++, "pid" in t && (0 === i.soundshare_first_pid && (i.soundshare_first_pid = t.pid), i.soundshare_last_pid = t.pid, this._pids.add(t.pid)), null != e && (null == i.soundshare_first_session && (i.soundshare_first_session = e), i.soundshare_last_session = e)
                }
                getStats() {
                    return {
                        ...this._report,
                        soundshare_unique_pids: this._pids.size
                    }
                }
                constructor() {
                    this._report = {
                        soundshare_attach_requested_count: 0,
                        soundshare_capturing_count: 0,
                        soundshare_capture_stopped_count: 0,
                        soundshare_hooked_count: 0,
                        soundshare_recv_connect_count: 0,
                        soundshare_recv_disconnect_count: 0,
                        soundshare_recv_started_count: 0,
                        soundshare_recv_stopped_count: 0,
                        soundshare_recv_failed_count: 0,
                        soundshare_recv_format_count: 0,
                        soundshare_send_announce_count: 0,
                        soundshare_send_start_count: 0,
                        soundshare_send_stop_count: 0,
                        soundshare_malformed_trace_count: 0,
                        soundshare_audio_detected_count: 0,
                        soundshare_state_transition_detached_count: 0,
                        soundshare_state_transition_waiting_count: 0,
                        soundshare_state_transition_attached_count: 0,
                        soundshare_state_transition_started_count: 0,
                        soundshare_state_transition_playing_count: 0,
                        soundshare_state_transition_silence_count: 0,
                        soundshare_unknown_event_count: 0,
                        soundshare_first_pid: 0,
                        soundshare_last_pid: 0,
                        soundshare_unique_pids: 0,
                        soundshare_first_session: null,
                        soundshare_last_session: null
                    }, this._pids = new Set
                }
            }
        },
        88313: function(e, t, n) {
            "use strict";
            n.r(t), n.d(t, {
                VideoHealthManager: function() {
                    return l
                }
            }), n("424973"), n("222007");
            var i = n("917351"),
                s = n("811022"),
                a = n("398183"),
                o = n("591883"),
                r = n("49111");
            class l {
                calculateFps(e, t, n) {
                    if (-1 === this.prevFramesCodec[e]) return this.prevFramesCodec[e] = t, this.prevAggDuration[e] = n, t / n;
                    let i = n - this.prevAggDuration[e];
                    this.prevAggDuration[e] = n;
                    let s = (t - this.prevFramesCodec[e]) / i;
                    return this.prevFramesCodec[e] = t, s
                }
                updateFps(e, t, n) {
                    if (!this.disabled && !this.streamDisabledUsers.has(e)) {
                        let s = this.calculateFps(e, t, n);
                        if ((0, i.isNaN)(s)) return;
                        if (this.perUserFpsWindow[e].push(s), this.perUserFpsWindow[e].length < this.windowLength) return;
                        this.perUserFpsWindow[e].length > this.windowLength && this.perUserFpsWindow[e].shift();
                        let a = this.perUserFpsWindow[e].filter(e => e < this.fpsThreshold).length;
                        a >= this.fpsWindowBorderlineCount ? (this.acceptableConditionsCounter[e] = Math.max(0, --this.acceptableConditionsCounter[e]), 0 === this.acceptableConditionsCounter[e] && (this.logger.info("".concat(e, ": detected poor network quality, turning off video")), this.streamDisabledUsers.add(e), this.currentVideoAutoToggleState[e] = r.VideoToggleState.DISABLED, (0, o.default)(e, r.VideoToggleState.DISABLED), this.startReenableBackoffTimer(e))) : (this.acceptableConditionsCounter[e] = Math.min(1, ++this.acceptableConditionsCounter[e]), this.acceptableConditionsCounter[e] >= 1 && this.currentVideoAutoToggleState[e] === r.VideoToggleState.AUTO_PROBING && (this.currentVideoAutoToggleState[e] = r.VideoToggleState.AUTO_ENABLED, this.logger.info("acceptableConditionsCounter reached threshold 1, will reset and send a AUTO_ENABLED for user ".concat(e)), (0, o.default)(e, r.VideoToggleState.AUTO_ENABLED)))
                    }
                }
                startReenableBackoffTimer(e) {
                    if (this.disabled) return;
                    this.logger.info("startReenableBackoffTimer for user ".concat(e));
                    let {
                        lastBackoffTime: t,
                        expBackoffFactor: n
                    } = this.retryBackoffCache[e];
                    null === t || n > 16 || this.elapsedSeconds((0, a.now)(), t) > 600 ? n = 1 : n *= 2, this.retryBackoffCache[e] = {
                        lastBackoffTime: (0, a.now)(),
                        expBackoffFactor: n
                    };
                    let i = n * this.backoffTimeSec * 1e3;
                    this.logger.info("starting backoff timer with time = ".concat(i, " milliseconds")), this.timeoutIdCache[e] = setTimeout(() => {
                        this.reenableVideo(e)
                    }, i)
                }
                reenableVideo(e) {
                    e in this.perUserFpsWindow && (this.logger.info("reenableVideo called for user ".concat(e, " - time = ").concat((0, a.now)())), this.stateCleanupBeforeEnable(e), this.currentVideoAutoToggleState[e] = r.VideoToggleState.AUTO_PROBING, (0, o.default)(e, r.VideoToggleState.AUTO_PROBING))
                }
                elapsedSeconds(e, t) {
                    return (e - t) / 1e3
                }
                stateCleanupBeforeEnable(e) {
                    this.logger.info("VideoHealthManager::stateCleanupBeforeEnable"), this.perUserFpsWindow[e] = [], this.prevFramesCodec[e] = -1, this.streamDisabledUsers.delete(e)
                }
                getCurrentVideoToggleState(e) {
                    return this.currentVideoAutoToggleState[e]
                }
                createUser(e) {
                    this.logger.info("VideoHealthManager::createUser ".concat(e)), !(e in this.perUserFpsWindow) && (this.perUserFpsWindow[e] = [], this.prevFramesCodec[e] = -1, this.acceptableConditionsCounter[e] = 0, this.currentVideoAutoToggleState[e] = r.VideoToggleState.NONE, this.retryBackoffCache[e] = {
                        lastBackoffTime: null,
                        expBackoffFactor: 1
                    })
                }
                deleteUser(e) {
                    this.logger.info("VideoHealthManager::deleteUser ".concat(e)), delete this.perUserFpsWindow[e], delete this.prevFramesCodec[e], delete this.retryBackoffCache[e], delete this.acceptableConditionsCounter[e], delete this.currentVideoAutoToggleState[e], this.streamDisabledUsers.delete(e), clearTimeout(this.timeoutIdCache[e]), delete this.timeoutIdCache[e]
                }
                disable() {
                    for (let e in this.disabled = !0, this.perUserFpsWindow) this.deleteUser(e)
                }
                constructor(e, t, n, a) {
                    this.logger = new s.default("VideoHealthManager"), this.disabled = !1, this.perUserFpsWindow = {}, this.prevFramesCodec = {}, this.prevAggDuration = {}, this.streamDisabledUsers = new Set, this.retryBackoffCache = {}, this.timeoutIdCache = {}, this.acceptableConditionsCounter = {}, this.currentVideoAutoToggleState = {}, this.windowLength = e, this.fpsThreshold = n, this.fpsWindowBorderlineCount = (0, i.ceil)(e * t), this.backoffTimeSec = a, this.logger.info("constructor with windowLength = ".concat(this.windowLength, ",\n      fpsWindowBorderlineCount = ").concat(this.fpsWindowBorderlineCount, ",\n      fpsThreshold = ").concat(this.fpsThreshold, ",\n      backoffTimeSec = ").concat(a))
                }
            }
        },
        531748: function(e, t, n) {
            "use strict";
            n.r(t), n.d(t, {
                VideoQualityEvent: function() {
                    return i
                },
                VideoQuality: function() {
                    return f
                }
            }), n("222007"), n("424973");
            var i, s = n("917351"),
                a = n.n(s),
                o = n("595275"),
                r = n("773364"),
                l = n("398183"),
                u = n("773336"),
                d = n("497407"),
                c = n("44642");

            function h(e) {
                let t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : 0;
                return null != e ? Math.round(e) : t
            }
            class p {
                set value(e) {
                    e && !this.state && (this.begin = this.timestampProducer.now()), !e && this.state && (this.total += this.timestampProducer.now() - Number(this.begin), this.begin = null), this.state = e
                }
                get value() {
                    return this.state
                }
                totalDuration() {
                    return null != this.begin ? this.total + this.timestampProducer.now() - this.begin : this.total
                }
                constructor(e, t) {
                    this.timestampProducer = t, this.total = 0, this.state = e, this.begin = e ? t.now() : null
                }
            }(i || (i = {})).FpsUpdate = "fps-update";
            class f extends o.default {
                addUserToStatsCollectionPausedSet(e) {
                    this.statCollectionPausedUsers.add(e)
                }
                removeUserFromStatsCollectionPausedSet(e) {
                    this.statCollectionPausedUsers.delete(e)
                }
                start() {
                    this.streamStart = this.timestampProducer.now(), this.connection.on(r.BaseConnectionEvent.Stats, this.sampleStats)
                }
                setOutboundSsrc(e) {
                    null == this.outboundStats[e] && (this.outboundStats[e] = new c.OutboundStats(this.timestampProducer))
                }
                getOrCreateInboundStats(e) {
                    return null == this.inboundStats[e] && (this.inboundStats[e] = new c.InboundStats(this.timestampProducer)), this.inboundStats[e]
                }
                setInboundUser(e, t) {
                    let n = this.getOrCreateInboundStats(e);
                    n.setVideoStopped(0 === t, c.VideoStoppedReasons.SenderStopped)
                }
                setUserVideoDisabled(e, t) {
                    let n = this.getOrCreateInboundStats(e);
                    n.setVideoStopped(t, c.VideoStoppedReasons.ClientSideDisableVideo), !t && n.statsWindow.length > 0 && 0 === n.statsWindow[0].packets && (n.startTime = this.timestampProducer.now())
                }
                pause() {
                    !this.paused.value && this.pausedCount++, a.forEach(this.outboundStats, e => {
                        e.statsWindow = []
                    }), a.forEach(this.inboundStats, e => {
                        e.statsWindow = []
                    }), this.updateSendState({
                        paused: !0
                    })
                }
                resume() {
                    this.updateSendState({
                        paused: !1
                    })
                }
                stop() {
                    this.connection.off(r.BaseConnectionEvent.Stats, this.sampleStats), this.streamEnd = this.timestampProducer.now(), this.removeAllListeners()
                }
                getNetworkStats() {
                    return this.networkQuality.getStats()
                }
                getEncoderUsageStats() {
                    let e = new Map;
                    for (let t in this.outboundStats) {
                        let n = new Map;
                        for (let i of this.outboundStats[t].getCodecsUsed()) {
                            let s = i.toUpperCase();
                            n.set(s, h(this.outboundStats[t].codecBuckets[s])), e.set(parseInt(t), n)
                        }
                    }
                    return e
                }
                getDecoderUsageStats() {
                    let e = new Map;
                    for (let t in this.inboundStats) {
                        let n = new Map;
                        for (let i of this.inboundStats[t].getCodecsUsed()) {
                            let s = i.toUpperCase();
                            n.set(s, h(this.inboundStats[t].codecBuckets[s])), e.set(t, n)
                        }
                    }
                    return e
                }
                getCodecUsageStats(e, t) {
                    var n, i, s, a, o, r, l, u, d, h;
                    let p = this.asymmetricCodecUpdates > this.symmetricCodecUpdates,
                        f = new Map;
                    if ("sender" === e || "streamer" === e) {
                        let e = this.getEncoderUsageStats();
                        if (e.size > 0) {
                            let t = [...e.keys()].sort()[0];
                            f = e.get(t)
                        }
                        return {
                            codec_asymmetric_session: p,
                            codec_h264_encode_duration_sec: null !== (n = f.get(c.CodecTypes.H264)) && void 0 !== n ? n : 0,
                            codec_h265_encode_duration_sec: null !== (i = f.get(c.CodecTypes.H265)) && void 0 !== i ? i : 0,
                            codec_vp8_encode_duration_sec: null !== (s = f.get(c.CodecTypes.VP8)) && void 0 !== s ? s : 0,
                            codec_vp9_encode_duration_sec: null !== (a = f.get(c.CodecTypes.VP9)) && void 0 !== a ? a : 0,
                            codec_av1_encode_duration_sec: null !== (o = f.get(c.CodecTypes.AV1)) && void 0 !== o ? o : 0
                        }
                    } {
                        let e = this.getDecoderUsageStats();
                        return e.has(t) && (f = e.get(t)), {
                            codec_asymmetric_session: p,
                            codec_h264_decode_duration_sec: null !== (r = f.get(c.CodecTypes.H264)) && void 0 !== r ? r : 0,
                            codec_h265_decode_duration_sec: null !== (l = f.get(c.CodecTypes.H265)) && void 0 !== l ? l : 0,
                            codec_vp8_decode_duration_sec: null !== (u = f.get(c.CodecTypes.VP8)) && void 0 !== u ? u : 0,
                            codec_vp9_decode_duration_sec: null !== (d = f.get(c.CodecTypes.VP9)) && void 0 !== d ? d : 0,
                            codec_av1_decode_duration_sec: null !== (h = f.get(c.CodecTypes.AV1)) && void 0 !== h ? h : 0
                        }
                    }
                }
                getOutboundStats() {
                    let e = [];
                    return a.forEach(this.outboundStats, (t, n) => {
                        var i, s, a, o;
                        let r;
                        let l = null === (i = this.connection) || void 0 === i ? void 0 : i.getStreamParameters();
                        l.length > 1 && l.forEach(e => {
                            if (parseInt(n) === e.ssrc) {
                                var t;
                                r = null !== (t = e.quality) && void 0 !== t ? t : 50
                            }
                        });
                        let u = [1, 5, 10, 25, 50, 75],
                            d = t.vmafHistogram.getReport(u),
                            p = t.psnrHistogram.getReport(u),
                            f = t.aggregationDuration / 1e3;
                        e.push({
                            ...this.getStats(t),
                            target_fps: f > 0 ? Math.round((null !== (s = t.targetFrames) && void 0 !== s ? s : 0) / f) : 0,
                            target_bitrate_network: f > 0 ? Math.round((null !== (a = t.targetBytesNetwork) && void 0 !== a ? a : 0) * 8 / f) : 0,
                            target_bitrate_max: f > 0 ? Math.round((null !== (o = t.targetBytesMax) && void 0 !== o ? o : 0) * 8 / f) : 0,
                            duration_encoder_nvidia_cuda: h(t.encoderBuckets[c.Encoders.NVIDIA_CUDA]),
                            duration_encoder_nvidia_direct3d: h(t.encoderBuckets[c.Encoders.NVIDIA_DIRECT_3D]),
                            duration_encoder_openh264: h(t.encoderBuckets[c.Encoders.OPENH264]),
                            duration_encoder_videotoolbox: h(t.encoderBuckets[c.Encoders.VIDEOTOOLBOX]),
                            duration_encoder_amd_direct3d: h(t.encoderBuckets[c.Encoders.AMD_DIRECT_3D]),
                            duration_encoder_intel: h(t.encoderBuckets[c.Encoders.INTEL]),
                            duration_encoder_intel_direct3d: h(t.encoderBuckets[c.Encoders.INTEL_DIRECT_3D]),
                            duration_encoder_vp8_libvpx: h(t.encoderBuckets[c.Encoders.VP8_LIBVPX]),
                            duration_encoder_uncategorized: h(t.encoderBuckets[c.Encoders.UNCATEGORIZED]),
                            duration_encoder_unknown: h(t.encoderBuckets[c.Encoders.UNKNOWN]),
                            quality: r,
                            average_encode_time_ms: t.averageEncodeTime,
                            average_encoder_vmaf_score: t.vmafScoreNum > 0 ? t.vmafScoreSum / t.vmafScoreNum : null,
                            encoder_vmaf_score_percentile1: d.count > 0 ? d.percentiles[1] : null,
                            encoder_vmaf_score_percentile5: d.count > 0 ? d.percentiles[5] : null,
                            encoder_vmaf_score_percentile10: d.count > 0 ? d.percentiles[10] : null,
                            encoder_vmaf_score_percentile25: d.count > 0 ? d.percentiles[25] : null,
                            encoder_vmaf_score_percentile50: d.count > 0 ? d.percentiles[50] : null,
                            encoder_vmaf_score_percentile75: d.count > 0 ? d.percentiles[75] : null,
                            average_encoder_psnr_db: t.psnrDbNum > 0 ? t.psnrDbSum / t.psnrDbNum : null,
                            encoder_psnr_db_percentile1: p.count > 0 ? p.percentiles[1] : null,
                            encoder_psnr_db_percentile5: p.count > 0 ? p.percentiles[5] : null,
                            encoder_psnr_db_percentile10: p.count > 0 ? p.percentiles[10] : null,
                            encoder_psnr_db_percentile25: p.count > 0 ? p.percentiles[25] : null,
                            encoder_psnr_db_percentile50: p.count > 0 ? p.percentiles[50] : null,
                            encoder_psnr_db_percentile75: p.count > 0 ? p.percentiles[75] : null,
                            average_outbound_want: t.outboundSinkWantNum > 0 ? t.outboundSinkWantSum / t.outboundSinkWantNum : null,
                            frames_dropped_rate_limiter: t.framesDroppedRateLimiter,
                            frames_dropped_encoder_queue: t.framesDroppedEncoderQueue,
                            frames_dropped_congestion_window: t.framesDroppedCongestionWindow
                        })
                    }), e
                }
                getInboundStats(e) {
                    return this.getStats(this.inboundStats[e])
                }
                destroyUser(e) {
                    delete this.inboundStats[e]
                }
                getInboundParticipants() {
                    return Object.keys(this.inboundStats)
                }
                updateSendState(e) {
                    null != e.paused && (this.paused.value = e.paused), null != e.receivers && (this.zeroReceivers.value = 0 === e.receivers);
                    let t = this.paused.value || this.zeroReceivers.value,
                        n = this.videoStopped.value;
                    this.videoStopped.value = t, t !== n && a.forEach(this.outboundStats, e => e.statsWindow = [])
                }
                getStats(e) {
                    if (null == e) return;
                    let t = Number(this.streamStart),
                        n = null != this.streamEnd ? this.streamEnd - t : this.timestampProducer.now() - t,
                        i = Math.max(e.aggregationDuration, 0),
                        s = i / 1e3,
                        a = [1, 5, 10, 25, 50, 75],
                        o = e.cpuHistogram.getReport(),
                        r = e.memoryHistogram.getReport(),
                        l = e.fpsHistogram.getReport(a),
                        u = e.bitrateHistogram.getReport(a),
                        d = e.resolutionHistogram.getReport(a),
                        c = {
                            duration: Math.floor(n / 1e3),
                            duration_aggregation: h(s),
                            duration_stopped_receiving: h(e.videoStoppedDuration.asSeconds()),
                            duration_stream_under_8mbps: h(e.bitrateBuckets[8e6]),
                            duration_stream_under_7mbps: h(e.bitrateBuckets[7e6]),
                            duration_stream_under_6mbps: h(e.bitrateBuckets[6e6]),
                            duration_stream_under_5mbps: h(e.bitrateBuckets[5e6]),
                            duration_stream_under_4mbps: h(e.bitrateBuckets[4e6]),
                            duration_stream_under_3mbps: h(e.bitrateBuckets[3e6]),
                            duration_stream_under_2mbps: h(e.bitrateBuckets[2e6]),
                            duration_stream_under_1_5mbps: h(e.bitrateBuckets[15e5]),
                            duration_stream_under_1mbps: h(e.bitrateBuckets[1e6]),
                            duration_stream_under_0_5mbps: h(e.bitrateBuckets[5e5]),
                            duration_stream_at_0mbps: h(e.bitrateBuckets[0]),
                            duration_fps_under_60: h(e.fpsBuckets[60]),
                            duration_fps_under_55: h(e.fpsBuckets[55]),
                            duration_fps_under_50: h(e.fpsBuckets[50]),
                            duration_fps_under_45: h(e.fpsBuckets[45]),
                            duration_fps_under_40: h(e.fpsBuckets[40]),
                            duration_fps_under_35: h(e.fpsBuckets[35]),
                            duration_fps_under_30: h(e.fpsBuckets[30]),
                            duration_fps_under_25: h(e.fpsBuckets[25]),
                            duration_fps_under_20: h(e.fpsBuckets[20]),
                            duration_fps_under_15: h(e.fpsBuckets[15]),
                            duration_fps_under_10: h(e.fpsBuckets[10]),
                            duration_fps_under_5: h(e.fpsBuckets[5]),
                            duration_fps_at_0: h(e.fpsBuckets[0]),
                            avg_resolution: e.intervalTotal > 0 ? Math.round(e.resolutionTotal / e.intervalTotal) : 0,
                            avg_minor_resolution: e.intervalTotal > 0 ? Math.round(e.minorResolutionTotal / e.intervalTotal) : 0,
                            avg_major_resolution: e.intervalTotal > 0 ? Math.round(e.majorResolutionTotal / e.intervalTotal) : 0,
                            duration_resolution_under_720: h(e.resolutionBuckets[720]),
                            duration_resolution_under_480: h(e.resolutionBuckets[480]),
                            duration_resolution_under_360: h(e.resolutionBuckets[360]),
                            num_pauses: this.pausedCount,
                            duration_paused: h(this.paused.totalDuration() / 1e3),
                            duration_zero_receivers: h(this.zeroReceivers.totalDuration() / 1e3),
                            duration_video_stopped: h(this.videoStopped.totalDuration() / 1e3),
                            client_performance_cpu_percentile25: o.percentiles[25],
                            client_performance_cpu_percentile50: o.percentiles[50],
                            client_performance_cpu_percentile75: o.percentiles[75],
                            client_performance_cpu_percentile90: o.percentiles[90],
                            client_performance_cpu_percentile95: o.percentiles[95],
                            client_performance_memory_percentile25: r.percentiles[25],
                            client_performance_memory_percentile50: r.percentiles[50],
                            client_performance_memory_percentile75: r.percentiles[75],
                            client_performance_memory_percentile90: r.percentiles[90],
                            client_performance_memory_percentile95: r.percentiles[95],
                            client_performance_memory_min: r.min,
                            client_performance_memory_max: r.max,
                            fps_percentile1: l.percentiles[1],
                            fps_percentile5: l.percentiles[5],
                            fps_percentile10: l.percentiles[10],
                            fps_percentile25: l.percentiles[25],
                            fps_percentile50: l.percentiles[50],
                            fps_percentile75: l.percentiles[75],
                            bitrate_percentile1: u.percentiles[1],
                            bitrate_percentile5: u.percentiles[5],
                            bitrate_percentile10: u.percentiles[10],
                            bitrate_percentile25: u.percentiles[25],
                            bitrate_percentile50: u.percentiles[50],
                            bitrate_percentile75: u.percentiles[75],
                            resolution_percentile1: d.percentiles[1],
                            resolution_percentile5: d.percentiles[5],
                            resolution_percentile10: d.percentiles[10],
                            resolution_percentile25: d.percentiles[25],
                            resolution_percentile50: d.percentiles[50],
                            resolution_percentile75: d.percentiles[75],
                            duration_video_effect: h(this.videoEffectDuration.totalDuration() / 1e3)
                        },
                        {
                            bytes: p,
                            framesDropped: f,
                            framesCodecError: m,
                            framesCodec: E,
                            framesNetwork: g,
                            packets: S,
                            packetsLost: _,
                            nackCount: v,
                            pliCount: C,
                            qpSum: T,
                            pauseCount: I,
                            freezeCount: A,
                            totalPausesDuration: N,
                            totalFreezesDuration: D,
                            totalFramesDuration: O,
                            keyframes: R
                        } = e.aggregatedProperties;
                    return {
                        ...c,
                        avg_bitrate: s > 0 ? Math.round((null != p ? p : 0) * 8 / s) : 0,
                        avg_fps: s > 0 ? Math.round((null != E ? E : 0) / s) : 0,
                        num_bytes: p,
                        num_packets_lost: _,
                        num_packets: S,
                        num_frames: g,
                        num_frames_codec_error: m,
                        time_to_first_frame_ms: e.timeToFirstFrame,
                        num_frames_dropped: f,
                        num_nacks: v,
                        num_plis: C,
                        qp_sum: T,
                        receiver_pause_count: I,
                        receiver_freeze_count: A,
                        receiver_total_pauses_duration: N,
                        receiver_total_freezes_duration: D,
                        receiver_total_frames_duration: O,
                        num_keyframes: R
                    }
                }
                receivedStats(e, t, n) {
                    var i, s, o, r;
                    let l = t.transport,
                        d = (0, u.isWeb)() ? 1 : null !== (s = null === (i = l.receiverReports) || void 0 === i ? void 0 : i.length) && void 0 !== s ? s : 0,
                        h = new Set,
                        p = new Set;
                    if (this.updateSendState({
                            receivers: d
                        }), t.rtp.outbound.filter(e => "video" === e.type).forEach(t => {
                            if (null != t) {
                                var i, s, a, o, r, u, d, p, f;
                                let m = t.ssrc,
                                    E = this.outboundStats[m];
                                if (null == E && (console.warn("Unknown outbound video stream with SSRC: ".concat(m)), E = new c.OutboundStats(this.timestampProducer), this.outboundStats[m] = E), null == E.timeToFirstFrame && (t.framesEncoded > 0 || (null !== (i = t.frameRateInput) && void 0 !== i ? i : 0) > 0) && (E.timeToFirstFrame = Math.max(0, e - E.startTime)), !this.videoStopped.value) {
                                    E.appendAndIncrementStats(c.RawVideoStats.parseOutboundStats(t, e)), E.encoderCodec !== c.CodecTypes.UNKNOWN && h.add(E.encoderCodec);
                                    let i = null === (s = n.find(e => e.ssrc === m)) || void 0 === s ? void 0 : s.maxBitrate;
                                    E.appendTargetRates(null === (a = n.find(e => e.ssrc === m)) || void 0 === a ? void 0 : a.maxFrameRate, null !== (r = t.bitrateTarget) && void 0 !== r ? r : Math.min(null !== (o = l.availableOutgoingBitrate) && void 0 !== o ? o : 0, null != i ? i : 0), i), E.averageEncodeTime = null !== (u = t.averageEncodeTime) && void 0 !== u ? u : 0, E.framesDroppedRateLimiter = null !== (d = t.framesDroppedRateLimiter) && void 0 !== d ? d : null, E.framesDroppedEncoderQueue = null !== (p = t.framesDroppedEncoderQueue) && void 0 !== p ? p : null, E.framesDroppedCongestionWindow = null !== (f = t.framesDroppedCongestionWindow) && void 0 !== f ? f : null
                                }
                            }
                        }), !this.paused.value && a.forEach(t.rtp.inbound, (t, n) => {
                            let i = t.find(e => "video" === e.type);
                            if (null != i) {
                                let t = this.inboundStats[n];
                                null == t && (console.warn("Unknown inbound video stream for user: ".concat(n)), t = new c.InboundStats(this.timestampProducer), this.inboundStats[n] = t);
                                let s = 0,
                                    a = 0,
                                    o = c.RawVideoStats.parseInboundStats(i, e);
                                this.statCollectionPausedUsers.has(n) ? [s, a] = t.collectFpsDataDuringProbe(o) : (t.resetAuxillaryStats(), t.appendAndIncrementStats(o), [s, a] = [t.aggregatedProperties.framesCodec, t.aggregationDuration]), this.emit("fps-update", n, s, a / 1e3), t.decoderCodec !== c.CodecTypes.UNKNOWN && p.add(t.decoderCodec), null == t.timeToFirstFrame && i.framesDecoded > 0 && (t.timeToFirstFrame = e - t.startTime)
                            }
                        }), 0 !== h.size && 0 !== p.size) {
                        ;
                        if (o = h, r = p, o.size === r.size && Array.from(o).every(e => r.has(e))) this.symmetricCodecUpdates++;
                        else this.asymmetricCodecUpdates++
                    }
                }
                updateSystemResourceStats() {
                    for (let e in this.outboundStats) this.outboundStats[e].addSystemResources();
                    for (let e in this.inboundStats) this.inboundStats[e].addSystemResources()
                }
                updateVideoEffectStats(e) {
                    let t = null == e ? void 0 : e.rtp.outbound.find(e => "video" === e.type);
                    this.videoEffectDuration.value = (null == t ? void 0 : t.type) === "video" && null != t.filter
                }
                constructor(e, t = l.TimeStampProducer) {
                    super(), this.connection = e, this.timestampProducer = t, this.networkQuality = new d.default, this.pausedCount = 0, this.outboundStats = {}, this.inboundStats = {}, this.symmetricCodecUpdates = 0, this.asymmetricCodecUpdates = 0, this.statCollectionPausedUsers = new Set, this.sampleStats = e => {
                        if (null == e) return;
                        let t = this.timestampProducer.now();
                        if (this.networkQuality.incrementNetworkStats(t), this.updateSystemResourceStats(), this.updateVideoEffectStats(e), null == e) return;
                        let n = this.connection.getStreamParameters();
                        this.receivedStats(t, e, n)
                    }, this.paused = new p(!1, t), this.zeroReceivers = new p(!1, t), this.videoStopped = new p(!1, t), this.videoEffectDuration = new p(!1, t)
                }
            }
        },
        44642: function(e, t, n) {
            "use strict";
            n.r(t), n.d(t, {
                CodecTypes: function() {
                    return i
                },
                Encoders: function() {
                    return s
                },
                VideoStoppedReasons: function() {
                    return o
                },
                parseEncoder: function() {
                    return v
                },
                RawVideoStats: function() {
                    return T
                },
                InboundStats: function() {
                    return I
                },
                OutboundStats: function() {
                    return A
                }
            }), n("222007"), n("424973");
            var i, s, a, o, r, l, u, d, c = n("398183"),
                h = n("872507"),
                p = n("226445");
            let f = [0, 5e5, 1e6, 15e5, 2e6, 3e6, 4e6, 5e6, 6e6, 7e6, 8e6],
                m = [0, 5, 10, 15, 20, 25, 30, 35, 40, 45, 50, 55, 60],
                E = [720, 480, 360],
                g = ["framesCodec", "framesNetwork", "packets", "packetsLost", "framesDropped", "framesCodecError", "bytes", "nackCount", "pliCount", "qpSum", "freezeCount", "pauseCount", "totalFreezesDuration", "totalPausesDuration", "totalFramesDuration", "keyframes"];
            (r = i || (i = {})).H264 = "H264", r.H265 = "H265", r.VP8 = "VP8", r.VP9 = "VP9", r.AV1 = "AV1", r.UNKNOWN = "UNKNOWN", (l = s || (s = {})).NVIDIA_CUDA = "nvidia_cuda", l.NVIDIA_DIRECT_3D = "nvidia_direct_3d", l.OPENH264 = "openh264", l.VIDEOTOOLBOX = "videotoolbox", l.AMD_DIRECT_3D = "amd_direct_3d", l.INTEL = "intel", l.INTEL_DIRECT_3D = "intel_direct_3d", l.VP8_LIBVPX = "vp8_libvpx", l.UNCATEGORIZED = "uncategorized", l.UNKNOWN = "unknown", (u = a || (a = {})).NVIDIA_DIRECT_3D = "nvidia_direct_3d", u.OPENH264 = "openh264", u.VIDEOTOOLBOX = "videotoolbox", u.AMD_DIRECT_3D = "amd_direct_3d", u.INTEL = "intel", u.INTEL_DIRECT_3D = "intel_direct_3d", u.VP8_LIBVPX = "vp8_libvpx", u.UNCATEGORIZED = "uncategorized", u.UNKNOWN = "unknown";
            let S = Object.freeze({
                    "nvidia: cuda": "nvidia_cuda",
                    "nvidia: direct3d": "nvidia_direct_3d",
                    "amd: direct3d": "amd_direct_3d",
                    "intel: direct3d": "intel_direct_3d",
                    intel: "intel",
                    VideoToolbox: "videotoolbox",
                    OpenH264: "openh264",
                    libvpx: "vp8_libvpx"
                }),
                _ = Object.freeze({
                    "nvidia: direct3d": "nvidia_direct_3d",
                    "amd: direct3d": "amd_direct_3d",
                    "intel: direct3d": "intel_direct_3d",
                    intel: "intel",
                    VideoToolbox: "videotoolbox",
                    OpenH264: "openh264",
                    libvpx: "vp8_libvpx"
                });

            function v(e) {
                if (null == e) return "unknown";
                for (let t of Object.keys(S))
                    if (e.includes(t)) return S[t];
                return "uncategorized"
            }(d = o || (o = {}))[d.None = 0] = "None", d[d.ClientSideDisableVideo = 1] = "ClientSideDisableVideo", d[d.SenderStopped = 2] = "SenderStopped";

            function C(e) {
                if (null == e) return "UNKNOWN";
                if ("H264" === (e = e.toUpperCase())) return "H264";
                if ("H265" === e) return "H265";
                if ("VP8" === e) return "VP8";
                else if ("VP9" === e) return "VP9";
                else if ("AV1" === e || "AV1X" === e) return "AV1";
                else return "UNKNOWN"
            }
            class T {
                static parseInboundStats(e, t) {
                    var n, i;
                    let s = new T;
                    return null == e ? s : (s.bytes = e.bytesReceived, s.framesCodec = e.framesDecoded, s.framesCodecError = null !== (n = e.framesDecodeErrors) && void 0 !== n ? n : null, s.framesNetwork = e.framesReceived, s.packets = e.packetsReceived, s.packetsLost = e.packetsLost, s.framesDropped = e.framesDropped, s.resolution = null != e.resolution ? e.resolution.height : 0, s.minorResolution = null != e.resolution ? Math.min(e.resolution.height, e.resolution.width) : 0, s.majorResolution = null != e.resolution ? Math.max(e.resolution.height, e.resolution.width) : 0, s.timestamp = t, s.nackCount = e.nackCount, s.pliCount = e.pliCount, s.decoder = function(e) {
                        if (null == e) return "unknown";
                        for (let t of Object.keys(_))
                            if (e.includes(t)) return _[t];
                        return "uncategorized"
                    }(e.decoderImplementationName), s.codecType = C(e.codec.name), s.qpSum = 0, s.freezeCount = e.freezeCount, s.pauseCount = e.pauseCount, s.totalFreezesDuration = e.totalFreezesDuration, s.totalPausesDuration = e.totalPausesDuration, s.totalFramesDuration = e.totalFramesDuration, s.keyframes = null !== (i = e.keyFramesDecoded) && void 0 !== i ? i : null, s)
                }
                static parseOutboundStats(e, t) {
                    var n, i, s, a, o, r, l, u, d;
                    let c = new T;
                    return null == e ? c : {
                        bytes: e.bytesSent,
                        framesCodec: e.framesEncoded,
                        framesCodecError: null,
                        framesNetwork: null !== (n = e.framesSent) && void 0 !== n ? n : 0,
                        packets: e.packetsSent,
                        packetsLost: null !== (i = e.packetsLost) && void 0 !== i ? i : 0,
                        framesDropped: 0,
                        resolution: null != e.resolution ? e.resolution.height : 0,
                        minorResolution: null != e.resolution ? Math.min(e.resolution.height, e.resolution.width) : 0,
                        majorResolution: null != e.resolution ? Math.max(e.resolution.height, e.resolution.width) : 0,
                        timestamp: t,
                        encoder: v(e.encoderImplementationName),
                        decoder: null,
                        codecType: C(e.codec.name),
                        nackCount: e.nackCount,
                        pliCount: e.pliCount,
                        qpSum: e.qpSum,
                        freezeCount: 0,
                        pauseCount: 0,
                        totalFreezesDuration: 0,
                        totalPausesDuration: 0,
                        totalFramesDuration: 0,
                        outboundSinkWant: null !== (s = e.sinkWantAsInt) && void 0 !== s ? s : null,
                        vmafScore: null !== (a = e.encoderQualityVmaf) && void 0 !== a ? a : null,
                        psnrDb: null !== (o = e.encoderQualityPsnr) && void 0 !== o ? o : null,
                        keyframes: null !== (r = e.keyFramesEncoded) && void 0 !== r ? r : null,
                        framesDroppedRateLimiter: null !== (l = e.framesDroppedRateLimiter) && void 0 !== l ? l : null,
                        framesDroppedEncoderQueue: null !== (u = e.framesDroppedEncoderQueue) && void 0 !== u ? u : null,
                        framesDroppedCongestionWindow: null !== (d = e.framesDroppedCongestionWindow) && void 0 !== d ? d : null
                    }
                }
                constructor() {
                    this.bytes = 0, this.framesCodec = 0, this.framesCodecError = null, this.framesNetwork = 0, this.resolution = 0, this.minorResolution = 0, this.majorResolution = 0, this.timestamp = 0, this.packets = 0, this.packetsLost = 0, this.framesDropped = 0, this.nackCount = 0, this.pliCount = 0, this.encoder = null, this.decoder = null, this.codecType = null, this.qpSum = 0, this.freezeCount = 0, this.pauseCount = 0, this.totalFreezesDuration = 0, this.totalPausesDuration = 0, this.totalFramesDuration = 0, this.vmafScore = null, this.psnrDb = null, this.outboundSinkWant = null, this.keyframes = null, this.framesDroppedRateLimiter = null, this.framesDroppedEncoderQueue = null, this.framesDroppedCongestionWindow = null
                }
            }
            class I {
                get isVideoStopped() {
                    return 0 !== this.videoStoppedReason
                }
                get videoStoppedDuration() {
                    return this.videoStoppedWatch.elapsed()
                }
                collectAggregationStats(e, t) {
                    for (let i of g) {
                        var n;
                        let s = e[i];
                        if (null === s) continue;
                        let a = null !== (n = t[i]) && void 0 !== n ? n : 0;
                        a > s ? this.aggregatedProperties[i] += s : this.aggregatedProperties[i] += s - a
                    }
                    this.aggregationDuration += e.timestamp - t.timestamp
                }
                collectFpsDataDuringProbe(e) {
                    var t, n;
                    if (this.auxillaryStatsWindow.push(e), this.auxillaryStatsWindow.length < 2) return [0, 0];
                    let i = this.auxillaryStatsWindow[this.auxillaryStatsWindow.length - 1],
                        s = this.auxillaryStatsWindow[this.auxillaryStatsWindow.length - 2];
                    return this.auxillaryAggFramesCodec += (null !== (t = i.framesCodec) && void 0 !== t ? t : 0) - (null !== (n = s.framesCodec) && void 0 !== n ? n : 0), this.auxillaryAggregationDuration += i.timestamp - s.timestamp, this.auxillaryStatsWindow.shift(), [this.auxillaryAggFramesCodec, this.auxillaryAggregationDuration]
                }
                resetAuxillaryStats() {
                    this.auxillaryStatsWindow.length > 0 && (this.auxillaryStatsWindow.splice(0), this.auxillaryAggFramesCodec = 0, this.auxillaryAggregationDuration = 0)
                }
                setVideoStopped(e, t) {
                    if (e) {
                        this.videoStoppedReason |= t, this.videoStoppedWatch.start();
                        return
                    }
                    this.videoStoppedReason &= ~t, 0 === this.videoStoppedReason && (this.statsWindow.splice(0), this.videoStoppedWatch.stop())
                }
                appendAndIncrementStats(e) {
                    if (this.isVideoStopped) return;
                    if (this.statsWindow.push(e), this.statsWindow.length < 2) return;
                    let t = this.statsWindow[this.statsWindow.length - 1],
                        n = this.statsWindow[this.statsWindow.length - 2];
                    this.collectAggregationStats(t, n);
                    let {
                        bytes: i,
                        framesCodec: s,
                        timestamp: a,
                        resolution: o,
                        minorResolution: r,
                        majorResolution: l,
                        encoder: u,
                        decoder: d,
                        codecType: c
                    } = t, {
                        timestamp: h
                    } = n, p = (a - h) / 1e3;
                    if (this.intervalTotal += p, this.resolutionTotal += o * p, this.minorResolutionTotal += r * p, this.majorResolutionTotal += l * p, null != u && null != c && "encoderBuckets" in this && (this.encoderBuckets[u] += p, this.codecBuckets[c] += p, null != t.codecType && "UNKNOWN" !== t.codecType && (this.encoderCodec = t.codecType), null != e.vmafScore && e.vmafScore >= 0 && (this.vmafScoreNum += 1, this.vmafScoreSum += e.vmafScore, this.vmafHistogram.addSample(e.vmafScore)), null != e.psnrDb && (this.psnrDbNum += 1, this.psnrDbSum += e.psnrDb, this.psnrHistogram.addSample(e.psnrDb)), null != e.outboundSinkWant && 0 !== e.outboundSinkWant && (this.outboundSinkWantNum += 1, this.outboundSinkWantSum += e.outboundSinkWant)), null != d && null != c && "decoderBuckets" in this && (this.decoderBuckets[d] += p, this.codecBuckets[c] += p, null != t.codecType && "UNKNOWN" !== t.codecType && (this.decoderCodec = t.codecType)), this.statsWindow.length < 6) return;
                    let {
                        bytes: g,
                        framesCodec: S,
                        timestamp: _
                    } = this.statsWindow[this.statsWindow.length - 3];
                    E.forEach(e => {
                        o <= e && (this.resolutionBuckets[e] += p)
                    });
                    let v = (a - _) / 1e3,
                        C = (i - g) * 8 / v,
                        T = (s - S) / v;
                    f.forEach(e => {
                        C <= e && (this.bitrateBuckets[e] += p)
                    }), m.forEach(e => {
                        T <= e && (this.fpsBuckets[e] += p)
                    }), this.resolutionHistogram.addSample(o), this.bitrateHistogram.addSample(C), this.fpsHistogram.addSample(T), this.statsWindow.shift()
                }
                addSystemResources() {
                    let e = h.default.getCurrentCPUUsagePercent(),
                        t = h.default.getCurrentMemoryUsageKB();
                    null != e && this.cpuHistogram.addSample(e), null != t && this.memoryHistogram.addSample(t)
                }
                getCodecsUsed() {
                    let e = new Set;
                    for (let [t, n] of Object.entries(this.codecBuckets)) n > 0 && e.add(t);
                    return e
                }
                constructor(e) {
                    this.decoderBuckets = {
                        nvidia_direct_3d: 0,
                        openh264: 0,
                        videotoolbox: 0,
                        amd_direct_3d: 0,
                        intel: 0,
                        intel_direct_3d: 0,
                        vp8_libvpx: 0,
                        uncategorized: 0,
                        unknown: 0
                    }, this.codecBuckets = {
                        H264: 0,
                        H265: 0,
                        VP8: 0,
                        VP9: 0,
                        AV1: 0,
                        UNKNOWN: 0
                    }, this.statsWindow = [], this.cpuHistogram = new p.Histogram, this.memoryHistogram = new p.Histogram, this.fpsHistogram = new p.Histogram, this.bitrateHistogram = new p.Histogram, this.resolutionHistogram = new p.Histogram, this.decoderCodec = "UNKNOWN", this.aggregatedProperties = {
                        framesCodec: 0,
                        framesNetwork: 0,
                        packets: 0,
                        packetsLost: 0,
                        framesDropped: 0,
                        framesCodecError: 0,
                        bytes: 0,
                        nackCount: 0,
                        pliCount: 0,
                        qpSum: 0,
                        freezeCount: 0,
                        pauseCount: 0,
                        totalFreezesDuration: 0,
                        totalPausesDuration: 0,
                        totalFramesDuration: 0,
                        keyframes: 0
                    }, this.aggregationDuration = 0, this.bitrateBuckets = {}, this.fpsBuckets = {}, this.resolutionBuckets = {}, this.resolutionTotal = 0, this.minorResolutionTotal = 0, this.majorResolutionTotal = 0, this.intervalTotal = 0, this.auxillaryStatsWindow = [], this.auxillaryAggFramesCodec = 0, this.auxillaryAggregationDuration = 0, this.videoStoppedReason = 0, this.startTime = e.now(), this.videoStoppedWatch = new c.StopWatch(e), f.forEach(e => {
                        this.bitrateBuckets[e] = 0
                    }), m.forEach(e => {
                        this.fpsBuckets[e] = 0
                    }), E.forEach(e => {
                        this.resolutionBuckets[e] = 0
                    })
                }
            }
            class A extends I {
                appendTargetRates(e, t, n) {
                    if (this.statsWindow.length < 2) return;
                    e = null != e ? e : 0, t = null != t ? t : 0, n = null != n ? n : 0;
                    let i = (this.statsWindow[this.statsWindow.length - 1].timestamp - this.statsWindow[this.statsWindow.length - 2].timestamp) / 1e3;
                    this.targetFrames = this.targetFrames + e * i, this.targetBytesNetwork = this.targetBytesNetwork + t / 8 * i, this.targetBytesMax = this.targetBytesMax + n / 8 * i
                }
                constructor(...e) {
                    super(...e), this.encoderBuckets = {
                        nvidia_cuda: 0,
                        nvidia_direct_3d: 0,
                        openh264: 0,
                        videotoolbox: 0,
                        amd_direct_3d: 0,
                        intel: 0,
                        intel_direct_3d: 0,
                        vp8_libvpx: 0,
                        uncategorized: 0,
                        unknown: 0
                    }, this.encoderCodec = "UNKNOWN", this.targetFrames = 0, this.targetBytesMax = 0, this.targetBytesNetwork = 0, this.averageEncodeTime = 0, this.vmafScoreSum = 0, this.vmafScoreNum = 0, this.vmafHistogram = new p.Histogram, this.psnrDbSum = 0, this.psnrDbNum = 0, this.psnrHistogram = new p.Histogram, this.outboundSinkWantSum = 0, this.outboundSinkWantNum = 0, this.framesDroppedRateLimiter = null, this.framesDroppedEncoderQueue = null, this.framesDroppedCongestionWindow = null
                }
            }
        },
        760406: function(e, t, n) {
            "use strict";
            n.r(t), n.d(t, {
                default: function() {
                    return i
                }
            }), n("222007");
            var i, s = n("614276"),
                a = n("398183");
            i = class {
                start() {
                    this.listeningUsers.clear(), this.listening.reset(), this.speaking.reset(), this.participation.reset(), this.connected.reset(), this.connected.start(), this.connection.on(s.BaseConnectionEvent.Speaking, (e, t, n) => {
                        this.userId === e ? this.onSpeaking(0 !== t) : this.onListening(0 !== t, e)
                    })
                }
                onSpeaking(e) {
                    e ? (this.speaking.start(), this.participation.start()) : (this.speaking.stop(), !this.listening.isRunning() && this.participation.stop())
                }
                onListening(e, t) {
                    e ? (this.listeningUsers.add(t), this.listening.start(), this.participation.start()) : this.listeningUsers.delete(t) && 0 === this.listeningUsers.size && (this.listening.stop(), !this.speaking.isRunning() && this.participation.stop())
                }
                stop() {
                    this.speaking.stop(), this.listening.stop(), this.participation.stop(), this.connected.stop()
                }
                getDurationStats() {
                    return {
                        duration_listening_ms: this.listening.elapsed().asMilliseconds(),
                        duration_speaking_ms: this.speaking.elapsed().asMilliseconds(),
                        duration_participation_ms: this.participation.elapsed().asMilliseconds(),
                        duration_connected_ms: this.connected.elapsed().asMilliseconds()
                    }
                }
                constructor(e, t, n = a.TimeStampProducer) {
                    this.userId = e, this.connection = t, this.timestampProducer = n, this.listeningUsers = new Set, this.listening = new a.StopWatch(this.timestampProducer), this.speaking = new a.StopWatch(this.timestampProducer), this.participation = new a.StopWatch(this.timestampProducer), this.connected = new a.StopWatch(this.timestampProducer)
                }
            }
        },
        478696: function(e, t, n) {
            "use strict";
            n.r(t), n.d(t, {
                default: function() {
                    return i
                }
            }), n("808653"), n("222007"), n("424973");
            var i, s = n("917351"),
                a = n.n(s),
                o = n("773364"),
                r = n("398183"),
                l = n("497407");
            i = class {
                start() {
                    this.connection.on(o.BaseConnectionEvent.Stats, this.sampleStats)
                }
                stop() {
                    this.connection.off(o.BaseConnectionEvent.Stats, this.sampleStats)
                }
                getMosStats() {
                    let e = a.reduce(this.inboundStats, (e, t) => {
                        e.mosSum += t.mosSum, e.mosCount += t.mosCount;
                        for (var n = 0; n < 5; n++) e.mosBuckets[n] += t.mosBuckets[n];
                        return e
                    }, {
                        mosSum: 0,
                        mosCount: 0,
                        mosBuckets: [0, 0, 0, 0, 0]
                    });
                    return {
                        mos_mean: e.mosCount > 0 ? e.mosSum / e.mosCount : 0,
                        mos_1: e.mosBuckets[1],
                        mos_2: e.mosBuckets[2],
                        mos_3: e.mosBuckets[3],
                        mos_4: e.mosBuckets[4]
                    }
                }
                getPacketStats() {
                    let e = a.reduce(this.inboundStats, (e, t) => (e.packetsReceived += t.packetsReceived, e.packetsReceivedLost += t.packetsLost, null != e.fecPacketsReceived && (e.fecPacketsReceived += t.fecPacketsReceived), null != e.fecPacketsDiscarded && (e.fecPacketsDiscarded += t.fecPacketsDiscarded), e), {
                        packetsReceived: 0,
                        packetsReceivedLost: 0,
                        fecPacketsReceived: 0,
                        fecPacketsDiscarded: 0
                    });
                    return {
                        packets_sent: this.outboundStats.packetsSent,
                        packets_sent_lost: this.outboundStats.packetsLost,
                        packets_received: e.packetsReceived,
                        packets_received_lost: e.packetsReceivedLost,
                        fec_packets_received: e.fecPacketsReceived,
                        fec_packets_discarded: e.fecPacketsDiscarded
                    }
                }
                getBytesStats() {
                    let e = a.reduce(this.inboundStats, (e, t) => e + t.bytesReceived, 0);
                    return {
                        bytes_sent: this.outboundStats.bytesSent,
                        bytes_received: e
                    }
                }
                getNetworkStats() {
                    return this.networkQuality.getStats()
                }
                getBufferStats() {
                    let e = a.reduce(this.inboundStats, (e, t) => ((null == e || null != t.bufferStats.audioJitterBuffer && null != e.audioJitterBuffer && t.bufferStats.audioJitterBuffer.p75 > e.audioJitterBuffer.p75) && (e = t.bufferStats), e), null);
                    return {
                        ... function(e) {
                            let t = {};
                            for (let n in e) {
                                let i = e[n];
                                t[n + "_mean"] = null != i ? i.mean : 0, t[n + "_p75"] = null != i ? i.p75 : 0, t[n + "_p95"] = null != i ? i.p95 : 0, t[n + "_p99"] = null != i ? i.p99 : 0, t[n + "_max"] = null != i ? i.max : 0
                            }
                            return t
                        }({
                            audio_jitter_buffer: null != e ? e.audioJitterBuffer : null,
                            audio_jitter_target: null != e ? e.audioJitterTarget : null,
                            audio_jitter_delay: null != e ? e.audioJitterDelay : null,
                            relative_reception_delay: null != e ? e.relativeReceptionDelay : null,
                            relative_playout_delay: null != e ? e.relativePlayoutDelay : null
                        })
                    }
                }
                getFrameOpStats() {
                    let e = a.reduce(this.inboundStats, (e, t) => (null != t.frameOpStats.silent && (e.silent += t.frameOpStats.silent), null != t.frameOpStats.normal && (e.normal += t.frameOpStats.normal), null != t.frameOpStats.merged && (e.merged += t.frameOpStats.merged), null != t.frameOpStats.expanded && (e.expanded += t.frameOpStats.expanded), null != t.frameOpStats.accelerated && (e.accelerated += t.frameOpStats.accelerated), null != t.frameOpStats.preemptiveExpanded && (e.preemptiveExpanded += t.frameOpStats.preemptiveExpanded), null != t.frameOpStats.cng && (e.cng += t.frameOpStats.cng), e), {
                        silent: 0,
                        normal: 0,
                        merged: 0,
                        expanded: 0,
                        accelerated: 0,
                        preemptiveExpanded: 0,
                        cng: 0
                    });
                    return {
                        frame_op_silent: e.silent,
                        frame_op_normal: e.normal,
                        frame_op_merged: e.merged,
                        frame_op_expanded: e.expanded,
                        frame_op_accelerated: e.accelerated,
                        frame_op_preemptive_expanded: e.preemptiveExpanded,
                        frame_op_cng: e.cng
                    }
                }
                getDurationStats() {
                    return {
                        duration_listening: this.duration.listening,
                        duration_speaking: this.duration.speaking,
                        duration_participation: this.duration.participation,
                        duration_connected: this.duration.connected
                    }
                }
                getTransportStats() {
                    return {
                        decryption_failures: this.decryptionFailures,
                        routing_failures: this.routingFailures
                    }
                }
                getPeriodicStats() {
                    let e = [];
                    for (let [m, E] of Object.entries(this.periodicInboundStats)) {
                        let {
                            previous: g,
                            current: S,
                            currentTimestampMs: _,
                            previousTimestampMs: v,
                            numRateSamples: C
                        } = E;
                        if (void 0 !== v && _ > v) {
                            var t, n, i, s, a, o, r, l, u, d, c, h, p, f;
                            let T = _ - v,
                                I = {
                                    userId: m,
                                    silent: null !== (n = S.silent) && void 0 !== n ? n : 0 - (null !== (t = g.silent) && void 0 !== t ? t : 0),
                                    normal: null !== (s = S.normal) && void 0 !== s ? s : 0 - (null !== (i = g.normal) && void 0 !== i ? i : 0),
                                    merged: null !== (o = S.merged) && void 0 !== o ? o : 0 - (null !== (a = g.merged) && void 0 !== a ? a : 0),
                                    expanded: null !== (l = S.expanded) && void 0 !== l ? l : 0 - (null !== (r = g.expanded) && void 0 !== r ? r : 0),
                                    accelerated: null !== (d = S.accelerated) && void 0 !== d ? d : 0 - (null !== (u = g.accelerated) && void 0 !== u ? u : 0),
                                    preemptiveExpanded: null !== (h = S.preemptiveExpanded) && void 0 !== h ? h : 0 - (null !== (c = g.preemptiveExpanded) && void 0 !== c ? c : 0),
                                    cng: null !== (f = S.cng) && void 0 !== f ? f : 0 - (null !== (p = g.cng) && void 0 !== p ? p : 0),
                                    accelerateRate: E.accelerateRateSum / C,
                                    expandRate: E.expandRateSum / C,
                                    preemptiveExpandRate: E.preemptiveExpandRateSum / C,
                                    speechExpandRate: E.speechExpandRateSum / C,
                                    durationMs: T
                                };
                            I.normal + I.merged + I.expanded + I.accelerated + I.preemptiveExpanded > 0 && e.push(I)
                        }
                        this.periodicInboundStats[m].accelerateRateSum = 0, this.periodicInboundStats[m].expandRateSum = 0, this.periodicInboundStats[m].preemptiveExpandRateSum = 0, this.periodicInboundStats[m].speechExpandRateSum = 0, this.periodicInboundStats[m].numRateSamples = 0, this.periodicInboundStats[m].previous = S, this.periodicInboundStats[m].previousTimestampMs = _
                    }
                    return e
                }
                calculateMos(e, t) {
                    let n = this.calculateR(e, t);
                    return n < 0 ? 1 : n > 100 ? 4.5 : 1 + .035 * n + 71e-7 * n * (n - 60) * (100 - n)
                }
                calculateR(e, t) {
                    return 93.4 - (.024 * e + (e > 177.3 ? .11 * (e - 177.3) : 0)) - (10 + 122 * t / (t + 10))
                }
                constructor(e) {
                    this.connection = e, this.sampleStats = e => {
                        if (null == e) return;
                        this.networkQuality.incrementNetworkStats((0, r.now)()), this.decryptionFailures = e.transport.decryptionFailures, this.routingFailures = e.transport.routingFailures, this.duration.connected++;
                        let t = this.outboundStats.packetsSent,
                            n = a.reduce(this.inboundStats, (e, t) => (e.packetsReceived += t.packetsReceived, e), {
                                packetsReceived: 0
                            });
                        a.forEach(e.rtp.outbound, e => {
                            if ("audio" === e.type) {
                                var t;
                                this.outboundStats = {
                                    packetsSent: e.packetsSent,
                                    bytesSent: e.bytesSent,
                                    packetsLost: null !== (t = e.packetsLost) && void 0 !== t ? t : 0
                                }
                            }
                        }), a.forEach(e.rtp.inbound, (t, n) => {
                            a.forEach(t, t => {
                                if ("audio" === t.type) {
                                    var i, s, o, r, l, u, d, c, h, p, f, m;
                                    let E = null !== (i = e.transport.ping) && void 0 !== i ? i : 0,
                                        g = t.packetsReceived,
                                        S = t.packetsLost,
                                        _ = t.bytesReceived,
                                        v = null !== (s = t.fecPacketsReceived) && void 0 !== s ? s : 0,
                                        C = null !== (o = t.fecPacketsDiscarded) && void 0 !== o ? o : 0,
                                        T = null !== (r = t.jitterBuffer) && void 0 !== r ? r : 0,
                                        I = {
                                            audioJitterBuffer: t.audioJitterBuffer,
                                            audioJitterTarget: t.audioJitterTarget,
                                            audioJitterDelay: t.audioJitterDelay,
                                            relativeReceptionDelay: t.relativeReceptionDelay,
                                            relativePlayoutDelay: t.relativePlayoutDelay
                                        },
                                        A = {
                                            silent: t.opSilence,
                                            normal: t.opNormal,
                                            merged: t.opMerge,
                                            expanded: t.opExpand,
                                            accelerated: t.opAccelerate,
                                            preemptiveExpanded: t.opPreemptiveExpand,
                                            cng: t.opCNG
                                        };
                                    if (null != this.inboundStats[n]) {
                                        let e = g - this.inboundStats[n].packetsReceived,
                                            i = S - this.inboundStats[n].packetsLost,
                                            s = 0,
                                            o = this.inboundStats[n].mosBuckets;
                                        e > 0 && i >= 0 && (s = this.calculateMos(E + T, a.clamp(i / (e + i), 0, 1)), o[Math.floor(s)]++), this.inboundStats[n] = {
                                            packetsReceived: g,
                                            bytesReceived: _,
                                            packetsLost: S,
                                            fecPacketsReceived: v,
                                            fecPacketsDiscarded: C,
                                            mos: s,
                                            mosSum: this.inboundStats[n].mosSum + s,
                                            mosCount: this.inboundStats[n].mosCount + (s > 0 ? 1 : 0),
                                            mosBuckets: o,
                                            bufferStats: I,
                                            frameOpStats: A
                                        }, this.periodicInboundStats[n] = {
                                            previousTimestampMs: this.periodicInboundStats[n].previousTimestampMs,
                                            previous: this.periodicInboundStats[n].previous,
                                            currentTimestampMs: Date.now(),
                                            current: A,
                                            accelerateRateSum: this.periodicInboundStats[n].accelerateRateSum + (null !== (l = t.accelerateRate) && void 0 !== l ? l : 0),
                                            expandRateSum: this.periodicInboundStats[n].expandRateSum + (null !== (u = t.expandRate) && void 0 !== u ? u : 0),
                                            preemptiveExpandRateSum: this.periodicInboundStats[n].preemptiveExpandRateSum + (null !== (d = t.preemptiveExpandRate) && void 0 !== d ? d : 0),
                                            speechExpandRateSum: this.periodicInboundStats[n].speechExpandRateSum + (null !== (c = t.speechExpandRate) && void 0 !== c ? c : 0),
                                            numRateSamples: this.periodicInboundStats[n].numRateSamples + 1
                                        }
                                    } else this.inboundStats[n] = {
                                        packetsReceived: g,
                                        bytesReceived: _,
                                        packetsLost: S,
                                        fecPacketsReceived: v,
                                        fecPacketsDiscarded: C,
                                        mos: 0,
                                        mosSum: 0,
                                        mosCount: 0,
                                        mosBuckets: [0, 0, 0, 0, 0],
                                        bufferStats: I,
                                        frameOpStats: A
                                    }, this.periodicInboundStats[n] = {
                                        previousTimestampMs: Date.now(),
                                        previous: A,
                                        currentTimestampMs: Date.now(),
                                        current: A,
                                        accelerateRateSum: null !== (h = t.accelerateRate) && void 0 !== h ? h : 0,
                                        expandRateSum: null !== (p = t.expandRate) && void 0 !== p ? p : 0,
                                        preemptiveExpandRateSum: null !== (f = t.preemptiveExpandRate) && void 0 !== f ? f : 0,
                                        speechExpandRateSum: null !== (m = t.speechExpandRate) && void 0 !== m ? m : 0,
                                        numRateSamples: 1
                                    }
                                }
                            })
                        });
                        let i = !1,
                            s = !1;
                        this.outboundStats.packetsSent > t && (i = !0, this.duration.speaking++);
                        let o = a.reduce(this.inboundStats, (e, t) => (e.packetsReceived += t.packetsReceived, e), {
                            packetsReceived: 0
                        });
                        o.packetsReceived > n.packetsReceived && (s = !0, this.duration.listening++), (i || s) && this.duration.participation++
                    }, this.networkQuality = new l.default, this.inboundStats = {}, this.outboundStats = {
                        packetsSent: 0,
                        bytesSent: 0,
                        packetsLost: 0
                    }, this.duration = {
                        listening: 0,
                        speaking: 0,
                        participation: 0,
                        connected: 0
                    }, this.periodicInboundStats = {}
                }
            }
        },
        241718: function(e, t, n) {
            "use strict";
            n.r(t), n.d(t, {
                default: function() {
                    return i
                }
            }), n("222007");
            var i, s = n("800762"),
                a = n("316133"),
                o = n("353927");
            i = class {
                updateVoiceStates(e, t) {
                    t === this.channelId ? (this.totalParticipants.add(e), this.maxVoiceStateCount = Math.max(a.default.countVoiceStatesForChannel(t), this.maxVoiceStateCount)) : (null == t && e in this.totalSpeakers && (this.totalSpeakers[e] = o.SpeakingFlags.NONE), e === this.userId && null != t && this.setChannelId(t))
                }
                getStats() {
                    return {
                        max_voice_state_count: this.maxVoiceStateCount,
                        total_voice_state_count: this.totalParticipants.size,
                        max_listener_count: this.maxListenerCount,
                        total_listener_count: this.totalListeners.size,
                        max_speaker_count: this.maxSpeakerCount,
                        total_speaker_count: Object.keys(this.totalSpeakers).length
                    }
                }
                setSpeaking(e, t) {
                    if (t !== o.SpeakingFlags.NONE) {
                        let n = s.default.getVoiceStateForChannel(this.channelId, e);
                        if (null != n && !n.selfMute && !n.mute) {
                            this.totalSpeakers[e] = t;
                            let n = Object.values(this.totalSpeakers).filter(e => e !== o.SpeakingFlags.NONE).length;
                            this.maxSpeakerCount = Math.max(this.maxSpeakerCount, n)
                        }
                    } else e in this.totalSpeakers && (this.totalSpeakers[e] = o.SpeakingFlags.NONE);
                    if (this.userId === e) {
                        if (t === this.speaking) return;
                        if (t !== o.SpeakingFlags.NONE) {
                            let e = Object.values(s.default.getVoiceStatesForChannel(this.channelId)).filter(e => e.userId !== this.userId && !e.selfDeaf && !e.deaf);
                            e.forEach(e => this.totalListeners.add(e.userId)), this.maxListenerCount = Math.max(e.length, this.maxListenerCount)
                        }
                        this.speaking = t
                    }
                }
                setChannelId(e) {
                    if (e === this.channelId) return;
                    this.channelId = e, this.totalParticipants = new Set([this.userId]);
                    let t = Object.keys(s.default.getVoiceStatesForChannel(this.channelId));
                    t.forEach(e => this.totalParticipants.add(e)), this.maxVoiceStateCount = t.length, this.speaking = o.SpeakingFlags.NONE, this.maxListenerCount = 0, this.totalListeners = new Set, this.maxSpeakerCount = 0, this.totalSpeakers = {}
                }
                constructor(e, t) {
                    this.maxVoiceStateCount = 1, this.speaking = o.SpeakingFlags.NONE, this.maxListenerCount = 0, this.maxSpeakerCount = 0, this.userId = e, this.setChannelId(t)
                }
            }
        },
        6193: function(e, t, n) {
            "use strict";
            n.r(t), n.d(t, {
                isHookModuleTooOld: function() {
                    return g
                },
                attachToProcess: function() {
                    return _
                },
                cancelAttachToProcess: function() {
                    return v
                }
            }), n("424973"), n("70102");
            var i, s, a = n("913144"),
                o = n("363658"),
                r = n("115718"),
                l = n("546463"),
                u = n("568307"),
                d = n("697218"),
                c = n("599110"),
                h = n("773336"),
                p = n("50885"),
                f = n("688225"),
                m = n("49111");
            let E = {
                development: [0, 0, 0, 0],
                canary: [1, 0, 30, 10],
                ptb: [1, 0, 1005, 2],
                stable: [1, 0, 9001, 2]
            };

            function g() {
                var e, t, n;
                let i = null !== (t = p.default.version) && void 0 !== t ? t : [0, 0, 0];
                (null === p.default || void 0 === p.default ? void 0 : null === (e = p.default.moduleVersions) || void 0 === e ? void 0 : e.discord_hook) != null ? i.push(p.default.moduleVersions.discord_hook) : i.push(0);
                let s = null !== (n = E[p.default.releaseChannel]) && void 0 !== n ? n : E.stable;
                return i < s
            }
            async function S() {
                if (!(0, h.isWindows)()) return Promise.reject(Error("Hook is only available on Windows"));
                if (g()) return Promise.reject(Error("Hook module is too old"));
                await p.default.ensureModule("discord_hook");
                let e = await p.default.requireModule("discord_hook");
                return function(e) {
                    if (null == e.setFlags) return;
                    let t = 0,
                        n = f.default.getCurrentConfig({
                            location: "edd7d3_1"
                        }, {
                            autoTrackExposure: !1
                        });
                    n.enableCrashReporting && (console.log("Hook: Enabling crash reporting."), t |= 1);
                    let i = d.default.getCurrentUser();
                    null != i && (i.isStaff() || n.enableCrashTrigger) && (console.log("Hook: Enabling crash trigger."), t |= 2), e.setFlags(t)
                }(e), e
            }(s = i || (i = {}))[s.None = 0] = "None", s[s.EnableCrashReporting = 1] = "EnableCrashReporting", s[s.EnableCrashTrigger = 2] = "EnableCrashTrigger";

            function _(e, t) {
                return S().then(n => {
                    var i;
                    let s = null === (i = u.default.getGameForPID(e)) || void 0 === i ? void 0 : i.name,
                        d = l.default.getGameByName(s);
                    return new Promise(i => {
                        let l = u.default.getOverlayOptionsForPID(e),
                            h = {
                                ...r.DEFAULT_OVERLAY_OPTIONS,
                                ...l,
                                elevate: u.default.shouldElevateProcessForPID(e)
                            };
                        null == h.allowHook || h.allowHook ? (n.attachToProcess(e, h, (e, n) => {
                            c.default.track(m.AnalyticEvents.HOOK_RESULT, {
                                game_name: s,
                                game_id: null == d ? null : d.id,
                                success: n,
                                error: e,
                                ...t
                            }), n ? i() : i(e = null != e ? e : "Unknown hook error")
                        }), a.default.wait(() => o.default.clearElevatedProcess())) : i("Hook is disabled for this game")
                    })
                })
            }

            function v(e) {
                return S().then(t => {
                    t.cancelAttachToProcess(e)
                })
            }
        },
        688225: function(e, t, n) {
            "use strict";
            n.r(t), n.d(t, {
                default: function() {
                    return i
                }
            });
            var i = (0, n("862205").createExperiment)({
                kind: "user",
                id: "2023-05_overlay_hook_crash_detection",
                label: "Detect and report crashes in the overlay hook",
                defaultConfig: {
                    enableCrashReporting: !1,
                    enableCrashTrigger: !1
                },
                treatments: [{
                    id: 1,
                    label: "EnableCrashReporting",
                    config: {
                        enableCrashReporting: !0,
                        enableCrashTrigger: !1
                    }
                }, {
                    id: 2,
                    label: "EnableCrashTrigger",
                    config: {
                        enableCrashReporting: !0,
                        enableCrashTrigger: !0
                    }
                }]
            })
        },
        256955: function(e, t, n) {
            "use strict";
            n.r(t), n("70102");
            var i = n("784063"),
                s = n("605250"),
                a = n("773336"),
                o = n("50885");
            (0, i.inject)({
                supported() {
                    try {
                        if (__OVERLAY__);
                        else if (a.isPlatformEmbedded) {
                            let e = (0, i.getVoiceEngine)();
                            if (null == e.VoiceConnection || null == e.setVideoOutputSink && null == e.addVideoOutputSink) throw Error("voe function missing");
                            return !0
                        }
                    } catch (e) {
                        new(0, s.default)("injectMediaEngine").error("Potentially corrupt installation:", e.message)
                    }
                    return !1
                },
                supportsFeature: e => o.default.supportsFeature(e),
                setProcessPriority(e) {
                    o.default.getDiscordUtils().setProcessPriority(e)
                },
                getVoiceEngine: () => o.default.getVoiceEngine()
            })
        },
        713725: function(e, t, n) {
            "use strict";

            function i(e, t) {
                if (e.length < 2) return [];
                let n = [],
                    i = e[0];
                for (let s = 1; s < e.length; s++) {
                    let a = e[s];
                    n.push(t(i, a)), i = a
                }
                return n
            }
            n.r(t), n.d(t, {
                default: function() {
                    return i
                }
            }), n("424973")
        },
        299285: function(e, t, n) {
            "use strict";
            n.r(t), n.d(t, {
                default: function() {
                    return f
                }
            }), n("222007"), n("424973");
            var i = n("446674"),
                s = n("913144"),
                a = n("653047");
            let o = [],
                r = {},
                l = {},
                u = {},
                d = {};

            function c(e) {
                for (let t of (r[e.id] = e, u[e.name.toLowerCase()] = e, e.aliases)) u[t.toLowerCase()] = e;
                delete d[e.id]
            }

            function h(e) {
                let {
                    entitlements: t
                } = e, n = !1;
                for (let {
                        sku: e
                    }
                    of t)(null == e ? void 0 : e.application) != null && (c(a.default.createFromServer(e.application)), n = !0);
                return n
            }
            class p extends i.default.Store {
                _getAllApplications() {
                    return Object.values(r)
                }
                getGuildApplication(e, t) {
                    if (null != e) {
                        for (let n of Object.values(r))
                            if (n.guildId === e && n.type === t) return n
                    }
                }
                getGuildApplicationIds(e) {
                    var t;
                    return null == e ? o : null !== (t = l[e]) && void 0 !== t ? t : o
                }
                getApplication(e) {
                    return r[e]
                }
                getApplicationByName(e) {
                    if (null == e) return;
                    let t = e.toLowerCase();
                    return Object.prototype.hasOwnProperty.call(u, t) ? u[t] : void 0
                }
                isFetchingApplication(e) {
                    return !0 === d[e]
                }
                didFetchingApplicationFail(e) {
                    return !1 === d[e]
                }
                getFetchingOrFailedFetchingIds() {
                    return Object.keys(d)
                }
            }
            p.displayName = "ApplicationStore";
            var f = new p(s.default, {
                CONNECTION_OPEN: function() {
                    r = {}, l = {}
                },
                OVERLAY_INITIALIZE: function(e) {
                    let {
                        applications: t
                    } = e;
                    for (let e of t) c(new a.default(e))
                },
                APPLICATION_FETCH: function(e) {
                    let {
                        applicationId: t
                    } = e, n = d[t];
                    return d[t] = !0, !0 !== n
                },
                APPLICATION_FETCH_SUCCESS: function(e) {
                    let {
                        application: t
                    } = e;
                    c(a.default.createFromServer(t))
                },
                APPLICATION_FETCH_FAIL: function(e) {
                    let {
                        applicationId: t
                    } = e, n = d[t];
                    return d[t] = !1, !1 !== n
                },
                APPLICATIONS_FETCH: function(e) {
                    let {
                        applicationIds: t
                    } = e, n = !1;
                    for (let e of t) {
                        let t = d[e];
                        d[e] = !0, n = !0 !== t
                    }
                    return n
                },
                APPLICATIONS_FETCH_SUCCESS: function(e) {
                    let {
                        applications: t
                    } = e;
                    for (let e of t) c(a.default.createFromServer(e))
                },
                APPLICATIONS_FETCH_FAIL: function(e) {
                    let {
                        applicationIds: t
                    } = e, n = !1;
                    for (let e of t) {
                        let t = d[e];
                        d[e] = !1, n = !1 !== t
                    }
                    return n
                },
                APPLICATION_SUBSCRIPTIONS_FETCH_ENTITLEMENTS_SUCCESS: h,
                ENTITLEMENTS_FETCH_FOR_USER_SUCCESS: h,
                ENTITLEMENTS_GIFTABLE_FETCH_SUCCESS: h,
                GUILD_SETTINGS_LOADED_INTEGRATIONS: function(e) {
                    let {
                        integrations: t,
                        guildId: n
                    } = e, i = !1, s = [];
                    for (let {
                            application: e
                        }
                        of t) null != e && (c(e), s.push(e.id), i = !0);
                    return i && (l[n] = s), i
                },
                GUILD_APPLICATIONS_FETCH_SUCCESS: function(e) {
                    let {
                        guildId: t,
                        applications: n
                    } = e, i = [];
                    for (let e of n) i.push(e.id), c(a.default.createFromServer(e));
                    l[t] = i
                },
                BILLING_PAYMENTS_FETCH_SUCCESS: function(e) {
                    let {
                        payments: t
                    } = e, n = new Set;
                    for (let e of t) {
                        var i;
                        let t = null === (i = e.sku) || void 0 === i ? void 0 : i.application;
                        !(null == t || n.has(t.id)) && c(a.default.createFromServer(t))
                    }
                    return n.size > 0
                },
                PAYMENT_UPDATE: function(e) {
                    var t;
                    let {
                        payment: n
                    } = e;
                    if ((null === (t = n.sku) || void 0 === t ? void 0 : t.application) == null) return !1;
                    c(a.default.createFromServer(n.sku.application))
                },
                INVITE_RESOLVE_SUCCESS: function(e) {
                    let {
                        invite: t
                    } = e;
                    if (null == t.target_application) return !1;
                    c(a.default.createFromServer(t.target_application))
                },
                GIFT_CODE_RESOLVE_SUCCESS: function(e) {
                    var t;
                    let {
                        giftCode: n
                    } = e;
                    if ((null === (t = n.store_listing) || void 0 === t ? void 0 : t.sku.application) == null) return !1;
                    c(a.default.createFromServer(n.store_listing.sku.application))
                },
                LIBRARY_FETCH_SUCCESS: function(e) {
                    let {
                        libraryApplications: t
                    } = e;
                    for (let e of t) c(a.default.createFromServer(e.application))
                },
                STORE_LISTING_FETCH_SUCCESS: function(e) {
                    let {
                        storeListing: t
                    } = e;
                    if (null == t.sku.application) return !1;
                    c(a.default.createFromServer(t.sku.application))
                }
            })
        },
        99795: function(e, t, n) {
            "use strict";
            var i, s, a, o, r, l;

            function u(e) {
                return !((null == e ? void 0 : e.type) !== 0 && (null == e ? void 0 : e.type) !== 1)
            }

            function d(e) {
                return (null == e ? void 0 : e.type) === 2
            }
            n.r(t), n.d(t, {
                ParticipantTypes: function() {
                    return i
                },
                ParticipantSelectionTypes: function() {
                    return s
                },
                VoicePlatforms: function() {
                    return a
                },
                isStreamParticipant: function() {
                    return u
                },
                isUserParticipant: function() {
                    return d
                },
                PIP_WIDTH: function() {
                    return c
                },
                EMOJI_PICKER_EMOJI_TO_SHOW_COUNT: function() {
                    return h
                }
            }), (o = i || (i = {}))[o.STREAM = 0] = "STREAM", o[o.HIDDEN_STREAM = 1] = "HIDDEN_STREAM", o[o.USER = 2] = "USER", o[o.ACTIVITY = 3] = "ACTIVITY", (r = s || (s = {})).NONE = "NONE", r.AUTO = "AUTO", (l = a || (a = {}))[l.DESKTOP = 0] = "DESKTOP", l[l.MOBILE = 1] = "MOBILE", l[l.XBOX = 2] = "XBOX", l[l.PLAYSTATION = 3] = "PLAYSTATION";
            let c = 320,
                h = 8
        },
        80028: function(e, t, n) {
            "use strict";
            n.r(t), n.d(t, {
                ClipsQualitySettings: function() {
                    return o
                },
                ClipsLengthSettings: function() {
                    return r
                },
                ClipsViewerConnectivitySettings: function() {
                    return l
                },
                DEFAULT_KEYBIND: function() {
                    return c
                },
                CLIPS_TOAST_DURATION: function() {
                    return h
                },
                ClipsLogger: function() {
                    return p
                },
                CLIPS_EXPORT_FILENAME: function() {
                    return f
                },
                CURRENT_CLIP_METADATA_VERSION: function() {
                    return m
                },
                CLIPS_HARDWARE_CLASSIFICATION_VERSION: function() {
                    return E
                },
                WINDOWS_HARDWARE_MINIMUM_GPU_REGEX: function() {
                    return g
                },
                WINDOWS_HARDWARE_AUTO_ENABLE_GPU_REGEX: function() {
                    return S
                },
                OSX_HARDWARE_AUTO_ENABLE_GPU_REGEX: function() {
                    return _
                },
                MIN_CLIP_DURATION_SECONDS: function() {
                    return v
                },
                CLIP_NAME_MIN_CHAR_LENGTH: function() {
                    return C
                },
                CLIP_NAME_MAX_CHAR_LENGTH: function() {
                    return T
                },
                CLIPS_EDIT_MODAL_KEY: function() {
                    return I
                },
                CLIPS_GALLERY_MODAL_KEY: function() {
                    return A
                },
                CLIPS_THUMBNAIL_MAX_WIDTH: function() {
                    return N
                },
                CLIPS_THUMBNAIL_MAX_HEIGHT: function() {
                    return D
                },
                CLIPS_MAX_PARTICIPANTS: function() {
                    return O
                },
                CLIP_NAME_TEMPLATE: function() {
                    return R
                },
                MAX_SIMULTANEOUS_SAVE_CLIP_OPERATIONS: function() {
                    return b
                }
            });
            var i, s, a, o, r, l, u = n("605250"),
                d = n("718517");
            (i = o || (o = {}))[i.DEFAULT = 0] = "DEFAULT", (s = r || (r = {}))[s.SECONDS_30 = 30 * d.default.Millis.SECOND] = "SECONDS_30", s[s.MINUTES_1 = d.default.Millis.MINUTE] = "MINUTES_1", s[s.MINUTES_2 = 2 * d.default.Millis.MINUTE] = "MINUTES_2", (a = l || (l = {}))[a.ALL = 0] = "ALL", a[a.FRIENDS = 1] = "FRIENDS";
            let c = "alt+c",
                h = 6 * d.default.Millis.SECOND,
                p = new u.default("Clips"),
                f = e => "Discord_Clip_".concat(e, ".mp4"),
                m = 2,
                E = 1,
                g = /(NVIDIA GeForce GTX (98|10|16).*|Radeon RX 5(500|600|).*|Radeon RX5.*)/,
                S = /(NVIDIA GeForce (RTX (20|30|40).*))|(.*Radeon RX (57|58|59|6|7).*)/,
                _ = /(Apple M[12].*)/,
                v = .1,
                C = 0,
                T = 200,
                I = "clips-edit",
                A = "clips-gallery",
                N = 640,
                D = 360,
                O = 100,
                R = e => "Clip - ".concat(new Date(e).toLocaleString()),
                b = 15
        },
        56947: function(e, t, n) {
            "use strict";
            n.r(t), n.d(t, {
                ClipsExperiment: function() {
                    return r
                },
                areClipsEnabled: function() {
                    return u
                },
                useEnableClips: function() {
                    return d
                },
                useShouldSeeClipsPremiumEarlyAccessGoLiveRoadblock: function() {
                    return c
                },
                useShouldSeeClipsPremiumEarlyAccessAnnouncementCoachmark: function() {
                    return h
                }
            });
            var i = n("862205"),
                s = n("584687"),
                a = n("42887"),
                o = n("18346");
            let r = (0, i.createExperiment)({
                    kind: "user",
                    id: "2022-11_clips_experiment",
                    label: "Clips Experiment",
                    defaultConfig: {
                        enableClips: !1,
                        ignorePlatformRestriction: !1
                    },
                    treatments: [{
                        id: 1,
                        label: "Clips without upsells",
                        config: {
                            enableClips: !0,
                            ignorePlatformRestriction: !1
                        }
                    }, {
                        id: 2,
                        label: "Clips with upsells",
                        config: {
                            enableClips: !0,
                            ignorePlatformRestriction: !1
                        }
                    }, {
                        id: 99,
                        label: "Clips 4 da Developerz",
                        config: {
                            enableClips: !0,
                            ignorePlatformRestriction: !0
                        }
                    }]
                }),
                l = (0, i.createExperiment)({
                    kind: "user",
                    id: "2023-09_clips_nitro_early_access",
                    label: "Clips (Nitro EA)",
                    defaultConfig: {
                        enableClips: !1,
                        enablePremiumEarlyAccessAnnouncementCoachmark: !1,
                        enablePremiumEarlyAccessGoLiveRoadblock: !1
                    },
                    treatments: [{
                        id: 1,
                        label: "Clips Nitro EA Upsells Visible",
                        config: {
                            enableClips: !1,
                            enablePremiumEarlyAccessAnnouncementCoachmark: !0,
                            enablePremiumEarlyAccessGoLiveRoadblock: !0
                        }
                    }, {
                        id: 2,
                        label: "Clips Enabled (Nitro)",
                        config: {
                            enableClips: !0,
                            enablePremiumEarlyAccessAnnouncementCoachmark: !0,
                            enablePremiumEarlyAccessGoLiveRoadblock: !1
                        }
                    }]
                });

            function u() {
                if (!(0, o.default)(a.default)) return !1;
                let {
                    enableClips: e
                } = l.getCurrentConfig({
                    location: "areClipsEnabled"
                }, {
                    autoTrackExposure: !1
                }), {
                    enableClips: t
                } = r.getCurrentConfig({
                    location: "areClipsEnabled"
                }, {
                    autoTrackExposure: !1
                }), {
                    enableDecoupledGameClipping: n
                } = s.default.getCurrentConfig({
                    location: "areClipsEnabled"
                }, {
                    autoTrackExposure: !1
                });
                return e || t || n
            }

            function d() {
                let e = (0, o.default)(a.default),
                    {
                        enableClips: t
                    } = l.useExperiment({
                        location: "useEnableClips"
                    }, {
                        autoTrackExposure: !1
                    }),
                    {
                        enableClips: n
                    } = r.useExperiment({
                        location: "useEnableClips"
                    }, {
                        autoTrackExposure: !1
                    }),
                    {
                        enableDecoupledGameClipping: i
                    } = s.default.useExperiment({
                        location: "useEnableClips"
                    }, {
                        autoTrackExposure: !1
                    });
                return (n || t || i) && e
            }
            let c = e => {
                    let {
                        autoTrackExposure: t
                    } = e, n = (0, o.default)(a.default), {
                        enablePremiumEarlyAccessGoLiveRoadblock: i
                    } = l.useExperiment({
                        location: "useShouldSeeClipsPremiumEarlyAccessGoLiveRoadblock"
                    }, {
                        autoTrackExposure: t && n
                    });
                    return !!n && i
                },
                h = e => {
                    let {
                        autoTrackExposure: t
                    } = e, n = (0, o.default)(a.default), {
                        enablePremiumEarlyAccessAnnouncementCoachmark: i
                    } = l.useExperiment({
                        location: "useShouldSeeClipsPremiumEarlyAccessGoLiveRoadblock"
                    }, {
                        autoTrackExposure: t && n
                    });
                    return !!n && i
                }
        },
        386045: function(e, t, n) {
            "use strict";
            n.r(t), n.d(t, {
                default: function() {
                    return N
                }
            }), n("222007"), n("702976");
            var i = n("446674"),
                s = n("913144"),
                a = n("49671"),
                o = n("374014"),
                r = n("271938"),
                l = n("42887"),
                u = n("568307"),
                d = n("568734"),
                c = n("30591"),
                h = n("80028"),
                p = n("49111");
            let f = "default",
                m = [],
                E = 0,
                g = null,
                S = null,
                _ = {},
                v = {
                    clipsEnabled: !1,
                    storageLocation: f,
                    clipsQuality: h.ClipsQualitySettings.DEFAULT,
                    clipsLength: h.ClipsLengthSettings.SECONDS_30,
                    decoupledClipsEnabled: !1,
                    viewerClipsEnabled: !0,
                    viewerConnectivity: h.ClipsViewerConnectivitySettings.ALL
                },
                C = {
                    clipsSettings: v,
                    hardwareClassification: null,
                    hardwareClassificationForDecoupled: null,
                    hardwareClassificationVersion: 0,
                    newClipIds: [],
                    hasClips: !1
                };
            async function T() {
                if (C.clipsSettings.storageLocation !== f || null == a.default || null == a.default.remoteApp) return;
                let e = await a.default.remoteApp.getPath("documents");
                C.clipsSettings.storageLocation = e, A.emitChange()
            }
            class I extends i.default.DeviceSettingsStore {
                initialize(e) {
                    null != e && (C = e), T(), this.waitFor(u.default)
                }
                getClips() {
                    return m
                }
                getUserAgnosticState() {
                    return C
                }
                getSettings() {
                    return C.clipsSettings
                }
                getLastClipsSession() {
                    return S
                }
                getClipsWarningShown(e) {
                    return g === e
                }
                getHardwareClassification() {
                    return C.hardwareClassification
                }
                getHardwareClassificationForDecoupled() {
                    return C.hardwareClassificationForDecoupled
                }
                getHardwareClassificationVersion() {
                    return C.hardwareClassificationVersion
                }
                getIsAtMaxSaveClipOperations() {
                    return E >= h.MAX_SIMULTANEOUS_SAVE_CLIP_OPERATIONS
                }
                isClipsEnabledForUser(e) {
                    var t, n;
                    return null !== (n = null === (t = _[e]) || void 0 === t ? void 0 : t.clipsEnabled) && void 0 !== n && n
                }
                isVoiceRecordingAllowedForUser(e) {
                    var t, n;
                    return null !== (n = null === (t = _[e]) || void 0 === t ? void 0 : t.allowVoiceRecording) && void 0 !== n && n
                }
                isViewerClippingAllowedForUser(e) {
                    var t, n;
                    return null !== (n = null === (t = _[e]) || void 0 === t ? void 0 : t.allowAnyViewerClips) && void 0 !== n && n
                }
                hasClips() {
                    return C.hasClips
                }
            }
            I.displayName = "ClipsStore", I.persistKey = "ClipsStore", I.migrations = [e => ({
                clipsSettings: null != e ? e : v,
                newClipsCount: 0
            }), e => {
                let t = {
                    ...v,
                    ...e.clipsSettings
                };
                return {
                    ...e,
                    clipsSettings: t
                }
            }, e => {
                var t;
                return {
                    ...e,
                    newClipIds: null !== (t = e.newClipIds) && void 0 !== t ? t : []
                }
            }, e => {
                var t, n;
                return {
                    ...e,
                    hardwareClassification: null !== (t = e.hardwareClassification) && void 0 !== t ? t : null,
                    hardwareClassificationVersion: null !== (n = e.hardwareClassificationVersion) && void 0 !== n ? n : 0
                }
            }, e => {
                var t;
                return {
                    ...e,
                    hasClips: null !== (t = e.hasClips) && void 0 !== t && t
                }
            }, e => ({
                ...e,
                clipsSettings: {
                    ...e.clipsSettings,
                    decoupledClipsEnabled: v.decoupledClipsEnabled
                }
            }), e => {
                var t;
                return {
                    ...e,
                    hardwareClassificationForDecoupled: null !== (t = e.hardwareClassificationForDecoupled) && void 0 !== t ? t : null
                }
            }, e => {
                let t = null != l.default && l.default.getHardwareH264();
                return {
                    ...e,
                    clipsSettings: {
                        ...e.clipsSettings,
                        clipsEnabled: !!t && e.clipsSettings.clipsEnabled,
                        decoupledClipsEnabled: !!t && e.clipsSettings.decoupledClipsEnabled
                    }
                }
            }];
            let A = new I(s.default, {
                CLIPS_SETTINGS_UPDATE: function(e) {
                    let {
                        settings: t
                    } = e;
                    C = {
                        ...C,
                        clipsSettings: {
                            ...C.clipsSettings,
                            ...t
                        }
                    }
                },
                CLIPS_SAVE_CLIP: function(e) {
                    var t, n;
                    let {
                        clip: i
                    } = e;
                    E = Math.max(E - 1, 0), S = {
                        applicationName: i.applicationName,
                        ended: !1,
                        ...S,
                        newClipIds: [...null !== (t = null == S ? void 0 : S.newClipIds) && void 0 !== t ? t : [], i.id]
                    }, C = {
                        ...C,
                        newClipIds: [...null !== (n = C.newClipIds) && void 0 !== n ? n : [], i.id]
                    }, m = [i, ...m], C.hasClips = !0
                },
                CLIPS_SAVE_CLIP_START: function() {
                    E += 1
                },
                CLIPS_SAVE_CLIP_ERROR: function() {
                    E = Math.max(E - 1, 0)
                },
                STREAM_START: function(e) {
                    let {
                        sourceName: t,
                        pid: n
                    } = e;
                    if (!C.clipsSettings.clipsEnabled) return !1;
                    let i = t;
                    if (null != n) {
                        var s;
                        let e = u.default.getGameForPID(n);
                        i = null !== (s = null == e ? void 0 : e.name) && void 0 !== s ? s : i
                    }
                    if (null == i || "" === i) return !1;
                    S = {
                        applicationName: i,
                        newClipIds: [],
                        ended: !1
                    }
                },
                STREAM_STOP: function(e) {
                    let {
                        streamKey: t
                    } = e;
                    if (null == S || (0, o.decodeStreamKey)(t).ownerId !== r.default.getId()) return !1;
                    S = 0 === S.newClipIds.length ? null : {
                        ...S,
                        ended: !0
                    }
                },
                CLIPS_CLEAR_CLIPS_SESSION: function() {
                    if (null == S) return !1;
                    S = null
                },
                CLIPS_CLEAR_NEW_CLIP_IDS: function() {
                    C.newClipIds = []
                },
                CLIPS_LOAD_DIRECTORY_SUCCESS: function(e) {
                    C.hasClips = e.clips.length > 0, m = e.clips
                },
                CLIPS_DELETE_CLIP: function(e) {
                    0 === (m = m.filter(t => {
                        let {
                            filepath: n
                        } = t;
                        return n !== e.filepath
                    })).length && (C.hasClips = !1)
                },
                CLIPS_UPDATE_METADATA: function(e) {
                    let {
                        clip: t
                    } = e;
                    for (let [e, n] of m.entries())
                        if (n.id === t.id) {
                            m[e] = t, m = [...m];
                            return
                        }
                },
                RTC_CONNECTION_FLAGS: function(e) {
                    _[e.userId] = {
                        clipsEnabled: (0, d.hasFlag)(e.flags, p.VoiceFlags.CLIPS_ENABLED),
                        allowVoiceRecording: (0, d.hasFlag)(e.flags, p.VoiceFlags.ALLOW_VOICE_RECORDING),
                        allowAnyViewerClips: (0, d.hasFlag)(e.flags, p.VoiceFlags.ALLOW_ANY_VIEWER_CLIPS)
                    }
                },
                CLIPS_SHOW_CALL_WARNING: function(e) {
                    let {
                        channelId: t
                    } = e;
                    g = t
                },
                VOICE_CHANNEL_SELECT: function(e) {
                    let {
                        channelId: t
                    } = e;
                    t !== g && (g = null)
                },
                CLIPS_CLASSIFY_HARDWARE: function(e) {
                    let {
                        classification: t
                    } = e, n = C.hardwareClassification;
                    C.hardwareClassificationVersion = h.CLIPS_HARDWARE_CLASSIFICATION_VERSION, C.hardwareClassification = t, C.hardwareClassification === c.ClipsHardwareClassification.MEETS_AUTO_ENABLE && n !== c.ClipsHardwareClassification.MEETS_AUTO_ENABLE && (C.clipsSettings.clipsEnabled = !0);
                    let i = C.hardwareClassificationForDecoupled;
                    C.hardwareClassificationForDecoupled = t, C.hardwareClassificationForDecoupled === c.ClipsHardwareClassification.MEETS_AUTO_ENABLE && i !== c.ClipsHardwareClassification.MEETS_AUTO_ENABLE && C.clipsSettings.clipsEnabled && (C.clipsSettings.decoupledClipsEnabled = !0)
                },
                CLIPS_INIT: function(e) {
                    let {
                        applicationName: t
                    } = e;
                    if (!C.clipsSettings.clipsEnabled) return !1;
                    S = {
                        applicationName: t,
                        newClipIds: [],
                        ended: !1
                    }
                }
            });
            var N = A
        },
        30591: function(e, t, n) {
            "use strict";
            var i, s;
            n.r(t), n.d(t, {
                ClipsHardwareClassification: function() {
                    return i
                }
            }), (s = i || (i = {})).UNKNOWN = "unknown", s.BELOW_MINIMUM = "below_minimum", s.MEETS_MINIMUM = "meets_minimum", s.MEETS_AUTO_ENABLE = "meets_auto_enable"
        },
        18346: function(e, t, n) {
            "use strict";
            n.r(t), n.d(t, {
                default: function() {
                    return o
                }
            });
            var i = n("773336"),
                s = n("56947"),
                a = n("353927");

            function o(e) {
                let {
                    ignorePlatformRestriction: t
                } = s.ClipsExperiment.getCurrentConfig({
                    location: "isClipsClientCapable"
                }, {
                    autoTrackExposure: !1
                });
                return t || i.isDesktop() && e.getMediaEngine().supports(a.Features.CLIPS)
            }
        },
        691898: function(e, t, n) {
            "use strict";
            n.r(t), n.d(t, {
                EXAMPLE_DOMAIN: function() {
                    return s
                },
                getDnsName: function() {
                    return a
                },
                getHttpName: function() {
                    return o
                },
                DomainConnectionExperiment: function() {
                    return r
                }
            });
            var i = n("862205");
            let s = "example.com",
                a = e => "_discord.".concat(e),
                o = e => "https://".concat(e, "/.well-known/discord"),
                r = (0, i.createExperiment)({
                    id: "2023-07_domain_connection",
                    label: "Domain Connection",
                    kind: "user",
                    defaultConfig: {
                        enabled: !1
                    },
                    treatments: [{
                        id: 1,
                        label: "Enabled",
                        config: {
                            enabled: !0
                        }
                    }]
                })
        },
        808122: function(e, t, n) {
            "use strict";

            function i() {
                let e = s();
                return null === e || !!(e >= 31) || !1
            }

            function s() {
                return null
            }
            n.r(t), n.d(t, {
                hasPerformanceForKrispFullband: function() {
                    return i
                },
                getMediaPerformanceClass: function() {
                    return s
                }
            })
        },
        214647: function(e, t, n) {
            "use strict";
            n.r(t), n.d(t, {
                GET_THERMAL_STATE_NOT_IMPLEMENTED_ERROR_MESSAGE: function() {
                    return i
                }
            });
            let i = "getThermalState not implemented for this client platform"
        },
        347672: function(e, t, n) {
            "use strict";
            n.r(t), n.d(t, {
                default: function() {
                    return s
                }
            }), n("70102");
            var i = n("214647"),
                s = {
                    getThermalState: () => Promise.reject(Error(i.GET_THERMAL_STATE_NOT_IMPLEMENTED_ERROR_MESSAGE))
                }
        },
        601222: function(e, t, n) {
            "use strict";
            n.r(t), n.d(t, {
                default: function() {
                    return a
                }
            });
            var i = n("347672"),
                s = n("214647");
            async function a() {
                let e = null;
                try {
                    e = await i.default.getThermalState()
                } catch (e) {
                    if (e.message === s.GET_THERMAL_STATE_NOT_IMPLEMENTED_ERROR_MESSAGE) return Promise.resolve(null);
                    throw e
                }
                return Promise.resolve(e)
            }
        },
        650033: function(e, t, n) {
            "use strict";
            n.r(t), n.d(t, {
                default: function() {
                    return l
                }
            }), n("222007");
            var i = n("446674"),
                s = n("913144");
            let a = {
                    enable_swipe_shortcuts: "Gestures shortcuts - swipe from right to left.",
                    enable_activity_or_message_preview: "If a user has an activity available, show it instead of the last message in DM list",
                    disable_alpha_voice_panel: "Disable new Voice Panel UI: Currently the new voice ui is defaulted ON for staff.  It's not feature complete so if there's something you are missing, or you find a problem, you can disable it here.",
                    highlight_experimental_icons: "Highlight experimental icons",
                    active_now_v2: "Enable Active Now v2 redesign for activity cards",
                    happening_now_summary_card: "Enable Happening Now Card with Summary",
                    enable_last_channel: "Enable launch into last channel",
                    enable_recently_active: "Enable recently active channels",
                    happening_main_tab: "Enable Happening tab containing summaries",
                    navigate_to_last_channel: "Navigate to last channel when selecting a guild.",
                    new_theme_settings: "Enable the new theme settings, with Darker and Lights Out themes",
                    user_channel_emoji_overrides: "Enable user channel emoji overrides",
                    enable_recently_active_summaries: "Enable summaries in recently active view",
                    channel_list_layout_animations: "Enable experimental channel list layout animations",
                    message_preview_animations: "Enable message preview animations",
                    recent_channels_throttle: "Throttle recent channels reordering",
                    force_voice_panel: "Force new voice panel to be shown.",
                    enable_server_discovery: "Enable Server Discovery Search on mobile",
                    messages_badge_num_channels: "Messages tab badge counts # of unread channels instead of # of unread messages",
                    main_tab_launchpad: "Enable LaunchPad in Main Tab",
                    main_tab_legacy_quick_switcher: "Enable Legacy Quick Switcher in Main Tab",
                    swipe_to_edit: "Enable Swipe-to-Edit",
                    new_panels: "Use panels for chat",
                    new_channels_for_panels: "Use new channel list for panels",
                    panels_split_messages_tab: "Split messages tab for panels",
                    redesign_individual_feature_you_tab: "Enable You tab in the old UI",
                    fullscreen_panels: "Fullscreen panels",
                    disable_theme_key: "Disable reloading the entire app when the theme changes",
                    theme_setting_in_account_sheet: "Show theme settings in the Account action sheet",
                    global_panels: "Use global panels for chat",
                    panels_navigator: "Use panels navigator",
                    cozy_header: "Cozy header",
                    disable_file_link_redesign: "Disables the new file and links in search",
                    enable_channel_emojis: "Enables channel emoji UI components"
                },
                o = {};
            class r extends i.default.DeviceSettingsStore {
                getUserAgnosticState() {
                    return {
                        toggleStates: o
                    }
                }
                initialize(e) {
                    for (var t in a) {
                        var n, i;
                        let s = null !== (i = null == e ? void 0 : null === (n = e.toggleStates) || void 0 === n ? void 0 : n[t]) && void 0 !== i && i;
                        o[t] = s
                    }
                }
                get(e) {
                    var t;
                    return null !== (t = o[e]) && void 0 !== t && t
                }
                set(e, t) {
                    return o[e] = t, t
                }
                all() {
                    return o
                }
                allWithDescriptions() {
                    return Object.entries(o).map(e => {
                        let [t, n] = e;
                        return [t, n, a[t]]
                    })
                }
            }
            r.displayName = "DevToolsDesignTogglesStore", r.persistKey = "DevToolsDesignTogglesStore";
            var l = new r(s.default, {
                DEV_TOOLS_DESIGN_TOGGLE_SET: function(e) {
                    o[e.toggle] = e.value
                }
            })
        },
        362391: function(e, t, n) {
            "use strict";
            n.r(t), n.d(t, {
                default: function() {
                    return a
                }
            });
            var i = n("446674"),
                s = n("650033");

            function a(e) {
                let t = (0, i.useStateFromStores)([s.default], () => s.default.get(e), [e]);
                return t
            }
        },
        630915: function(e, t, n) {
            "use strict";
            n.r(t), n.d(t, {
                isOOPExperimentEnabled: function() {
                    return a
                }
            });
            var i = n("296892");
            let s = (0, i.default)({
                kind: "user",
                id: "2023-08_overlay3_out_of_process_enablement",
                label: "Overlay3 - Out of Process Enablement",
                defaultConfig: {
                    useGlobalOverlay: !1
                },
                treatments: [{
                    id: 1,
                    label: "Enabled",
                    config: {
                        useGlobalOverlay: !0
                    }
                }]
            });

            function a() {
                let e = s.getCurrentConfig({
                    location: "isOOPExperimentEnabled"
                }, {
                    autoTrackExposure: !0
                });
                return null != e && e.useGlobalOverlay
            }
        },
        733589: function(e, t, n) {
            "use strict";
            n.r(t), n.d(t, {
                default: function() {
                    return i
                }
            });
            var i = n("106919").default
        },
        106919: function(e, t, n) {
            "use strict";
            n.r(t), n.d(t, {
                default: function() {
                    return s
                }
            });
            let i = new class e {
                enterPipMode() {
                    return Promise.resolve()
                }
                setEnabled(e) {}
                setSelectedStream(e) {}
                setMirrored(e) {}
                setPipAspectRatio(e, t) {}
                addOnPipModeChangedListener(e) {}
                isEnabled() {
                    return !1
                }
            };
            var s = i
        },
        76393: function(e, t, n) {
            "use strict";
            n.r(t), n.d(t, {
                default: function() {
                    return m
                }
            }), n("222007");
            var i = n("446674"),
                s = n("913144"),
                a = n("235660"),
                o = n("800762");
            let r = null,
                l = null,
                u = new Set,
                d = {},
                c = {},
                h = new Set,
                p = Object.freeze({});
            class f extends i.default.DeviceSettingsStore {
                initialize(e) {
                    null != e && (c = e.lastSelectedDeviceByPlatform), this.waitFor(a.default, o.default)
                }
                getUserAgnosticState() {
                    return {
                        lastSelectedDeviceByPlatform: c
                    }
                }
                getDevicesForPlatform(e) {
                    var t;
                    return null !== (t = d[e]) && void 0 !== t ? t : p
                }
                getLastSelectedDeviceByPlatform(e) {
                    return c[e]
                }
                getDevice(e, t) {
                    var n;
                    return null === (n = d[e]) || void 0 === n ? void 0 : n[t]
                }
                getFetchingDevices(e) {
                    return h.has(e)
                }
                getPendingDeviceCommands() {
                    return u
                }
                getRemoteSessionId() {
                    return r
                }
                getAwaitingRemoteSessionInfo() {
                    return l
                }
            }
            f.displayName = "GameConsoleStore", f.persistKey = "GameConsoleStore";
            var m = new f(s.default, {
                REMOTE_SESSION_CONNECT: function(e) {
                    let {
                        sessionId: t
                    } = e;
                    r = t, l = null
                },
                REMOTE_SESSION_DISCONNECT: function() {
                    r = null, l = null
                },
                WAIT_FOR_REMOTE_SESSION: function(e) {
                    let {
                        sessionType: t,
                        nonce: n,
                        channelId: i,
                        deviceId: s,
                        commandId: a
                    } = e;
                    l = {
                        type: t,
                        nonce: n,
                        channelId: i,
                        startedAt: Date.now(),
                        deviceId: s,
                        commandId: a
                    }
                },
                GAME_CONSOLE_FETCH_DEVICES_START: function(e) {
                    let {
                        platform: t
                    } = e;
                    h.add(t)
                },
                GAME_CONSOLE_FETCH_DEVICES_SUCCESS: function(e) {
                    let {
                        platform: t,
                        devices: n
                    } = e;
                    h.delete(t);
                    let i = d[t] = {},
                        s = {};
                    for (let e of n) i[e.id] = e, c[t] === e.id && (s[t] = e.id);
                    c = s
                },
                GAME_CONSOLE_FETCH_DEVICES_FAIL: function(e) {
                    let {
                        platform: t
                    } = e;
                    h.delete(t)
                },
                GAME_CONSOLE_SELECT_DEVICE: function(e) {
                    let {
                        platform: t,
                        deviceId: n
                    } = e;
                    c[t] = n
                }
            })
        },
        831610: function(e, t, n) {
            "use strict";
            n.r(t), n.d(t, {
                default: function() {
                    return s
                }
            }), n("781738");
            let i = /\\/g;

            function s(e) {
                return e.replace(i, "/")
            }
        },
        706530: function(e, t, n) {
            "use strict";
            n.r(t), n.d(t, {
                StreamIssueReportReasons: function() {
                    return a
                },
                DARWIN_SOUNDSHARE_VERSION: function() {
                    return l
                },
                DARWIN_SCKIT_VERSION: function() {
                    return u
                },
                DARWIN_SCKIT_AUDIO_VERSION: function() {
                    return d
                },
                WINDOWS_SOUNDSHARE_VERSION: function() {
                    return c
                },
                WINDOWS_GRAPHICS_CAPTURE_VERSION: function() {
                    return h
                },
                StreamTypes: function() {
                    return o
                },
                STREAM_NOTIFY_GUILD_MAX_SIZE: function() {
                    return p
                }
            });
            var i, s, a, o, r = n("561467");
            (i = a || (a = {})).BLACK_SCREEN = "BLACK_SCREEN", i.BLURRY = "BLURRY", i.LAGGING = "LAGGING", i.OUT_OF_SYNC = "OUT_OF_SYNC", i.AUDIO_MISSING = "AUDIO_MISSING", i.AUDIO_POOR = "AUDIO_POOR", i.GAME_ISSUE = "GAME_ISSUE", i.STREAM_STOPPED = "STREAM_STOPPED", i.NO_ISSUE = "NO_ISSUE", i.OTHER = "OTHER";
            let l = ">=19.0.0",
                u = ">=22.0.0",
                d = ">=22.0.0",
                c = ">=10.0.17763",
                h = ">=10.0.22000";
            (s = o || (o = {})).GUILD = "guild", s.CALL = "call";
            let p = r.Notifications.StreamNotificationsGuildMaxSize
        },
        374014: function(e, t, n) {
            "use strict";
            n.r(t), n.d(t, {
                isStreamKey: function() {
                    return s
                },
                decodeStreamKey: function() {
                    return a
                },
                encodeStreamKey: function() {
                    return o
                }
            }), n("222007"), n("70102");
            var i = n("706530");

            function s(e) {
                return null != e && (e.startsWith(i.StreamTypes.GUILD) || e.startsWith(i.StreamTypes.CALL))
            }

            function a(e) {
                let t = e.split(":"),
                    n = t[0];
                switch (n) {
                    case i.StreamTypes.GUILD: {
                        let [e, n, i, s] = t;
                        return {
                            streamType: e,
                            guildId: n,
                            channelId: i,
                            ownerId: s
                        }
                    }
                    case i.StreamTypes.CALL: {
                        let [e, n, i] = t;
                        return {
                            streamType: e,
                            channelId: n,
                            ownerId: i
                        }
                    }
                    default:
                        throw Error("Unknown stream type ".concat(n))
                }
            }

            function o(e) {
                let {
                    streamType: t,
                    guildId: n,
                    channelId: s,
                    ownerId: a
                } = e;
                switch (t) {
                    case i.StreamTypes.GUILD:
                        return [t, n, s, a].join(":");
                    case i.StreamTypes.CALL:
                        return [t, s, a].join(":");
                    default:
                        throw Error("Unknown stream type ".concat(t))
                }
            }
        },
        933034: function(e, t, n) {
            "use strict";
            n.r(t), n.d(t, {
                default: function() {
                    return s
                }
            });
            var i = n("568307");

            function s(e) {
                let t, n;
                if (null == e) return {};
                let s = e.sourcePid;
                if (null != s) {
                    let e = i.default.getGameForPID(s);
                    t = null == e ? void 0 : e.name, n = null == e ? void 0 : e.id
                }
                return {
                    soundshare_session: e.soundshareSession,
                    share_game_name: t,
                    share_game_id: n
                }
            }
        },
        756898: function(e, t, n) {
            "use strict";

            function i(e, t) {
                return null != t && e.startsWith("window:".concat(t))
            }
            n.r(t), n.d(t, {
                default: function() {
                    return i
                }
            })
        },
        591023: function(e, t, n) {
            "use strict";
            n.r(t), n.d(t, {
                isActionedApplicationStatus: function() {
                    return s
                },
                isSubmittedApplicationStatus: function() {
                    return a
                },
                isApprovedAndAcked: function() {
                    return o
                },
                isActionedAndNotAcked: function() {
                    return r
                }
            });
            var i = n("567054");

            function s(e) {
                return e === i.GuildJoinRequestApplicationStatuses.APPROVED || e === i.GuildJoinRequestApplicationStatuses.REJECTED
            }

            function a(e) {
                return e === i.GuildJoinRequestApplicationStatuses.SUBMITTED
            }

            function o(e) {
                return e.applicationStatus === i.GuildJoinRequestApplicationStatuses.APPROVED && null != e.lastSeen
            }

            function r(e) {
                return s(e.applicationStatus) && null == e.lastSeen
            }
        },
        567054: function(e, t, n) {
            "use strict";
            var i, s, a, o, r, l, u, d;
            n.r(t), n.d(t, {
                MAX_RESULTS_PER_PAGE: function() {
                    return c
                },
                MAX_VISIBLE_PAGES: function() {
                    return h
                },
                VerificationFormFieldTypes: function() {
                    return i
                },
                GuildJoinRequestSortOrders: function() {
                    return a
                },
                GuildJoinRequestApplicationStatuses: function() {
                    return o
                },
                isTermsFormField: function() {
                    return p
                }
            });
            let c = 25,
                h = 4;

            function p(e) {
                return null != e && "TERMS" === e.field_type
            }(r = i || (i = {})).TERMS = "TERMS", r.TEXT_INPUT = "TEXT_INPUT", r.PARAGRAPH = "PARAGRAPH", r.MULTIPLE_CHOICE = "MULTIPLE_CHOICE", r.VERIFICATION = "VERIFICATION", (l = s || (s = {})).EMAIL = "email", l.PHONE = "phone", (u = a || (a = {})).TIMESTAMP_DESC = "NEWEST", u.TIMESTAMP_ASC = "OLDEST", (d = o || (o = {})).STARTED = "STARTED", d.SUBMITTED = "SUBMITTED", d.REJECTED = "REJECTED", d.APPROVED = "APPROVED"
        },
        982527: function(e, t, n) {
            "use strict";
            n.r(t), n.d(t, {
                joinRequestFromServer: function() {
                    return c
                },
                default: function() {
                    return f
                }
            });
            var i = n("446674"),
                s = n("913144"),
                a = n("813006"),
                o = n("697218"),
                r = n("591023");
            let l = {},
                u = !1,
                d = {};

            function c(e) {
                return {
                    id: e.id,
                    guildId: e.guild_id,
                    userId: e.user_id,
                    user: e.user,
                    createdAt: e.created_at,
                    formResponses: e.form_responses,
                    rejectionReason: e.rejection_reason,
                    applicationStatus: e.application_status,
                    actionedAt: e.actioned_at,
                    actionedByUser: e.actioned_by_user,
                    lastSeen: e.last_seen
                }
            }

            function h(e) {
                let {
                    guildId: t,
                    request: n
                } = e;
                if (null == n) return;
                let i = c(n),
                    s = o.default.getCurrentUser();
                if (null != s && i.userId !== s.id) return !1;
                (0, r.isApprovedAndAcked)(i) ? delete l[t]: l[t] = i
            }
            class p extends i.default.Store {
                getRequest(e) {
                    return l[e]
                }
                computeGuildIds() {
                    return Object.values(l).map(e => null == e ? void 0 : e.guildId).filter(e => null != e)
                }
                getJoinRequestGuild(e) {
                    return null != d[e] ? new a.default(d[e]) : null
                }
                get hasFetchedRequestToJoinGuilds() {
                    return u
                }
            }
            p.displayName = "UserGuildJoinRequestStore";
            var f = new p(s.default, {
                CONNECTION_OPEN: function(e) {
                    let {
                        guildJoinRequests: t
                    } = e;
                    u = !1, d = {}, l = {}, t.forEach(e => {
                        let {
                            guild_id: t
                        } = e;
                        null != t && (l[t] = c(e))
                    })
                },
                GUILD_JOIN_REQUEST_UPDATE: h,
                GUILD_JOIN_REQUEST_CREATE: h,
                USER_GUILD_JOIN_REQUEST_UPDATE: function(e) {
                    let {
                        request: t,
                        guildId: n
                    } = e;
                    if (null == t) {
                        delete l[n];
                        return
                    }
                    let i = c(t);
                    (0, r.isApprovedAndAcked)(i) ? delete l[n]: l[n] = i
                },
                GUILD_DELETE: function(e) {
                    let {
                        guild: t
                    } = e;
                    delete l[t.id]
                },
                USER_JOIN_REQUEST_GUILDS_FETCH: function(e) {
                    let {
                        guilds: t
                    } = e;
                    u = !0, t.forEach(e => {
                        let {
                            id: t,
                            name: n,
                            features: i,
                            icon: s
                        } = e;
                        d[t] = {
                            id: t,
                            name: n,
                            features: i,
                            icon: s
                        }
                    })
                },
                MEMBER_VERIFICATION_FORM_UPDATE: function(e) {
                    let {
                        form: t,
                        guildId: n
                    } = e;
                    if ((null == t ? void 0 : t.guild) != null) {
                        let {
                            id: e,
                            name: i,
                            icon: s,
                            features: a
                        } = t.guild;
                        d[n] = {
                            id: e,
                            name: i,
                            icon: s,
                            features: null != a ? a : []
                        }
                    }
                },
                INVITE_ACCEPT_SUCCESS: function(e) {
                    let {
                        invite: t
                    } = e, {
                        guild: n,
                        join_request: i
                    } = t;
                    if (null != n && null != i) {
                        let {
                            guild_id: e
                        } = i;
                        l[e] = c(i);
                        let {
                            id: t,
                            name: s,
                            icon: a,
                            features: o
                        } = n;
                        d[t] = {
                            id: t,
                            name: s,
                            icon: a,
                            features: null != o ? o : []
                        }
                    }
                },
                ACK_APPROVED_GUILD_JOIN_REQUEST: function(e) {
                    let {
                        guildId: t
                    } = e;
                    delete l[t]
                }
            })
        },
        916863: function(e, t, n) {
            "use strict";
            n.r(t), (0, n("862205").createExperiment)({
                kind: "user",
                id: "2023-08_mobile_redesign_0g_mini",
                label: "Tabs V2 - 0g Mini",
                defaultConfig: {
                    showRedesign: !1,
                    showMinimalChannelList: !1,
                    showFullWidthPanel: !1,
                    showRecentChannels: !1,
                    showNotificationTimer: !1
                },
                treatments: [{
                    id: 1,
                    label: "Minimal Channel List",
                    config: {
                        showRedesign: !0,
                        showMinimalChannelList: !0,
                        showFullWidthPanel: !1,
                        showRecentChannels: !1,
                        showNotificationTimer: !1
                    }
                }, {
                    id: 2,
                    label: "Full Width Panel",
                    config: {
                        showRedesign: !1,
                        showMinimalChannelList: !1,
                        showFullWidthPanel: !0,
                        showRecentChannels: !1,
                        showNotificationTimer: !1
                    }
                }, {
                    id: 3,
                    label: "Recent Channels",
                    config: {
                        showRedesign: !0,
                        showMinimalChannelList: !1,
                        showFullWidthPanel: !1,
                        showRecentChannels: !0,
                        showNotificationTimer: !1
                    }
                }, {
                    id: 4,
                    label: "Notification Timer",
                    config: {
                        showRedesign: !0,
                        showMinimalChannelList: !1,
                        showFullWidthPanel: !1,
                        showRecentChannels: !1,
                        showNotificationTimer: !0
                    }
                }, {
                    id: 5,
                    label: "Base redesign",
                    config: {
                        showRedesign: !0,
                        showMinimalChannelList: !1,
                        showFullWidthPanel: !1,
                        showRecentChannels: !1,
                        showNotificationTimer: !1
                    }
                }]
            })
        },
        126198: function(e, t, n) {
            "use strict";
            n.r(t), n.d(t, {
                getCombinedCurryExperimentValue: function() {
                    return r
                }
            }), n("884691"), n("95410"), n("650033");
            var i = n("862205");
            n("789563");
            let s = [{
                    id: 2,
                    label: "App Navbar Always Visible",
                    config: {
                        showRedesign: !0,
                        recentChannels: !1,
                        launchIntoLastChannel: !1
                    }
                }, {
                    id: 3,
                    label: "App Navbar Always Visible + Keep Channel",
                    config: {
                        showRedesign: !0,
                        recentChannels: !1,
                        launchIntoLastChannel: !1
                    }
                }, {
                    id: 4,
                    label: "Recent channels",
                    config: {
                        showRedesign: !0,
                        recentChannels: !0,
                        launchIntoLastChannel: !1
                    }
                }, {
                    id: 5,
                    label: "Launch into last channel",
                    config: {
                        showRedesign: !0,
                        recentChannels: !1,
                        launchIntoLastChannel: !0
                    }
                }, {
                    id: 6,
                    label: "Plain Redesign",
                    config: {
                        showRedesign: !0,
                        recentChannels: !1,
                        launchIntoLastChannel: !1
                    }
                }],
                a = (0, i.createExperiment)({
                    kind: "user",
                    id: "2023-06_mobile_redesign_curry_existing_users",
                    label: "Tabs V2 - Curry Existing Users",
                    defaultConfig: {
                        showRedesign: !1,
                        recentChannels: !1,
                        launchIntoLastChannel: !1
                    },
                    treatments: s
                }),
                o = (0, i.createExperiment)({
                    kind: "user",
                    id: "2023-06_mobile_redesign_curry_new_users",
                    label: "Tabs V2 - Curry New Users",
                    defaultConfig: {
                        showRedesign: !1,
                        recentChannels: !1,
                        launchIntoLastChannel: !1
                    },
                    treatments: s
                });

            function r(e) {
                return !!a.getCurrentConfig({
                    location: "bcf97c_3"
                }, {
                    autoTrackExposure: !1
                })[e] || !!o.getCurrentConfig({
                    location: "bcf97c_4"
                }, {
                    autoTrackExposure: !1
                })[e] || !1
            }
        },
        21121: function(e, t, n) {
            "use strict";
            n.r(t), n.d(t, {
                getRootNavigationRefIfInExperiment: function() {
                    return E
                },
                isInMainTabsExperiment: function() {
                    return g
                },
                useInMainTabsExperiment: function() {
                    return S
                }
            }), n("70102"), n("222007"), n("884691");
            var i, s, a = n("308503"),
                o = n("95410");
            n("789563"), n("697218"), n("916863"), n("126198"), n("900226"), n("985268"), n("699145"), n("102425"), n("460609");
            var r = n("132522"),
                l = n("693051"),
                u = n("139404"),
                d = n("61796"),
                c = n("264325"),
                h = n("18108");
            (s = i || (i = {}))[s.GDM = 0] = "GDM", s[s.EXISTING_USERS = 1] = "EXISTING_USERS", s[s.NEW_USERS = 2] = "NEW_USERS";
            let p = "tabs-v2-experiment-key",
                f = (0, a.default)((e, t) => ({
                    _experimentCacheInitialized: !1,
                    _experimentEnabled: !1,
                    getExperimentEnabled() {
                        if (!(0, d.isMainTabsExperimentPlatformSupported)()) return !1;
                        let {
                            _experimentCacheInitialized: e,
                            _experimentEnabled: n
                        } = t();
                        if (!e) throw Error("MainTabsV2ExperimentStore: Experiment cache not initialized");
                        return n
                    },
                    setExperimentEnabled: t => {
                        e({
                            _experimentEnabled: t
                        }), o.default.set(p, t)
                    },
                    setInitialized: () => {
                        e(e => e._experimentCacheInitialized ? e : {
                            _experimentCacheInitialized: !0,
                            _experimentEnabled: !0 === o.default.get(p)
                        })
                    }
                }));

            function m() {
                let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : (0, u.isMobileRedesignDisabled)(),
                    t = arguments.length > 1 && void 0 !== arguments[1] && arguments[1],
                    n = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : f.getState().getExperimentEnabled(),
                    i = arguments.length > 3 && void 0 !== arguments[3] ? arguments[3] : (0, c.isTabsUIEnabledManually)(),
                    s = arguments.length > 4 && void 0 !== arguments[4] ? arguments[4] : (0, r.isRedesignToggleIgnored)();
                if (!(0, d.isMainTabsExperimentPlatformSupported)()) return !1;
                if (!s) {
                    if (!t && e) return (0, h.updateIsInTabsUI)(!1), !1;
                    if (i) return (0, h.updateIsInTabsUI)(!0), !0
                }
                return !t && (0, h.updateIsInTabsUI)(n), n
            }

            function E() {
                return g() ? (0, l.getRootNavigationRef)() : void 0
            }

            function g() {
                return m()
            }

            function S() {
                let e = arguments.length > 0 && void 0 !== arguments[0] && arguments[0],
                    t = (0, u.useMobileRedesignDisabled)(),
                    n = f(e => e.getExperimentEnabled()),
                    i = (0, c.useIsTabsUIEnabledManually)(),
                    s = (0, r.useRedesignToggleIgnored)();
                return m(t, e, n, i, s)
            }
        },
        900226: function(e, t, n) {
            "use strict";
            n.r(t);
            var i = n("862205");
            (0, i.createExperiment)({
                kind: "user",
                id: "2023-02_tabs_v2",
                label: "Tabs V2 - GDM Bucketing",
                defaultConfig: {
                    enabled: !1
                },
                treatments: [{
                    id: 1,
                    label: "Enable Tabs V2",
                    config: {
                        enabled: !0
                    }
                }]
            }), (0, i.createExperiment)({
                kind: "user",
                id: "2023-03_mobile_re_design_existing_users",
                label: "Tabs V2 - Existing Users",
                defaultConfig: {
                    enabled: !1
                },
                treatments: [{
                    id: 1,
                    label: "Enable Tabs V2",
                    config: {
                        enabled: !0
                    }
                }]
            }), (0, i.createExperiment)({
                kind: "user",
                id: "2023-02_mobile_redesign_new_users",
                label: "Tabs V2 - New Users",
                defaultConfig: {
                    enabled: !1
                },
                treatments: [{
                    id: 1,
                    label: "Enable Tabs V2",
                    config: {
                        enabled: !0
                    }
                }]
            }), (0, i.createExperiment)({
                kind: "user",
                id: "2023-04_mobile_redesign_0c_new_users",
                label: "Tabs V2 - New Users Phase 0c",
                defaultConfig: {
                    enabled: !1
                },
                treatments: [{
                    id: 1,
                    label: "Enable Tabs V2",
                    config: {
                        enabled: !0
                    }
                }]
            }), (0, i.createExperiment)({
                kind: "user",
                id: "2023-04_mobile_redesign_0d_new_users",
                label: "Tabs V2 - New Users Phase 0d",
                defaultConfig: {
                    enabled: !1
                },
                treatments: [{
                    id: 1,
                    label: "Enable Tabs V2",
                    config: {
                        enabled: !0
                    }
                }]
            })
        },
        985268: function(e, t, n) {
            "use strict";
            n.r(t), (0, n("862205").createExperiment)({
                kind: "user",
                id: "2023-09_mobile_redesign_hfu",
                label: "Tabs V2 - HFU Iteration",
                defaultConfig: {
                    showRedesign: !1,
                    showMessagesTab: !1,
                    showLaunchpadPullTab: !1,
                    showMinimalChannelList: !1,
                    showQuickswitcherTab: !1,
                    showLaunchpadTab: !1,
                    showFullWidthPanel: !1,
                    showFullWidthPanelNoSwipingOrSelected: !1
                },
                treatments: [{
                    id: 1,
                    label: "DM Tab",
                    config: {
                        showRedesign: !1,
                        showMessagesTab: !0,
                        showLaunchpadPullTab: !1,
                        showMinimalChannelList: !1,
                        showQuickswitcherTab: !1,
                        showLaunchpadTab: !1,
                        showFullWidthPanel: !1,
                        showFullWidthPanelNoSwipingOrSelected: !1
                    }
                }, {
                    id: 2,
                    label: "Launchpad Pull Tab",
                    config: {
                        showRedesign: !0,
                        showMessagesTab: !1,
                        showLaunchpadPullTab: !0,
                        showMinimalChannelList: !1,
                        showQuickswitcherTab: !1,
                        showLaunchpadTab: !1,
                        showFullWidthPanel: !1,
                        showFullWidthPanelNoSwipingOrSelected: !1
                    }
                }, {
                    id: 3,
                    label: "Minimal Channel List",
                    config: {
                        showRedesign: !0,
                        showMessagesTab: !1,
                        showLaunchpadPullTab: !1,
                        showMinimalChannelList: !0,
                        showQuickswitcherTab: !1,
                        showLaunchpadTab: !1,
                        showFullWidthPanel: !1,
                        showFullWidthPanelNoSwipingOrSelected: !1
                    }
                }, {
                    id: 4,
                    label: "Quickswitcher Tab",
                    config: {
                        showRedesign: !0,
                        showMessagesTab: !1,
                        showLaunchpadPullTab: !1,
                        showMinimalChannelList: !1,
                        showQuickswitcherTab: !0,
                        showLaunchpadTab: !1,
                        showFullWidthPanel: !1,
                        showFullWidthPanelNoSwipingOrSelected: !1
                    }
                }, {
                    id: 5,
                    label: "Launchpad Tab",
                    config: {
                        showRedesign: !0,
                        showMessagesTab: !1,
                        showLaunchpadPullTab: !1,
                        showMinimalChannelList: !1,
                        showQuickswitcherTab: !1,
                        showLaunchpadTab: !0,
                        showFullWidthPanel: !1,
                        showFullWidthPanelNoSwipingOrSelected: !1
                    }
                }, {
                    id: 6,
                    label: "Base redesign",
                    config: {
                        showRedesign: !0,
                        showMessagesTab: !1,
                        showLaunchpadPullTab: !1,
                        showMinimalChannelList: !1,
                        showQuickswitcherTab: !1,
                        showLaunchpadTab: !1,
                        showFullWidthPanel: !1,
                        showFullWidthPanelNoSwipingOrSelected: !1
                    }
                }, {
                    id: 7,
                    label: "Full width panel",
                    config: {
                        showRedesign: !1,
                        showMessagesTab: !1,
                        showLaunchpadPullTab: !1,
                        showMinimalChannelList: !1,
                        showQuickswitcherTab: !1,
                        showLaunchpadTab: !1,
                        showFullWidthPanel: !0,
                        showFullWidthPanelNoSwipingOrSelected: !1
                    }
                }, {
                    id: 8,
                    label: "Full width panel (disabled swiping & selected channel highlight)",
                    config: {
                        showRedesign: !1,
                        showMessagesTab: !1,
                        showLaunchpadPullTab: !1,
                        showMinimalChannelList: !1,
                        showQuickswitcherTab: !1,
                        showLaunchpadTab: !1,
                        showFullWidthPanel: !1,
                        showFullWidthPanelNoSwipingOrSelected: !0
                    }
                }]
            })
        },
        699145: function(e, t, n) {
            "use strict";
            n.r(t), n.d(t, {
                MainTabsV2OnePercentExperimentExistingUsers: function() {
                    return o
                },
                MainTabsV2OnePercentExperimentNewUsers: function() {
                    return r
                }
            });
            var i = n("862205");
            let s = {
                    showRedesign: !1,
                    showPanels: !1
                },
                a = [{
                    id: 1,
                    label: "Redesign",
                    config: {
                        showRedesign: !0,
                        showPanels: !1
                    }
                }, {
                    id: 2,
                    label: "Panels",
                    config: {
                        showRedesign: !0,
                        showPanels: !0
                    }
                }],
                o = (0, i.createExperiment)({
                    kind: "user",
                    id: "2023-10_mobile_redesign_one_percent_existing_users",
                    label: "Tabs V2 - One Percent - Existing Users",
                    defaultConfig: s,
                    treatments: a
                }),
                r = (0, i.createExperiment)({
                    kind: "user",
                    id: "2023-10_mobile_redesign_one_percent_new_users",
                    label: "Tabs V2 - One Percent - New Users",
                    defaultConfig: s,
                    treatments: a
                })
        },
        102425: function(e, t, n) {
            "use strict";
            n.r(t), n.d(t, {
                MainTabsV2PanelsExperimentExistingUsers: function() {
                    return o
                },
                MainTabsV2PanelsExperimentNewUsers: function() {
                    return r
                }
            });
            var i = n("862205");
            let s = {
                    showRedesign: !1,
                    showNewPanels: !1,
                    isSplitMessagesTab: !1
                },
                a = [{
                    id: 1,
                    label: "Merged Server + DM tab",
                    config: {
                        showRedesign: !0,
                        showNewPanels: !0,
                        isSplitMessagesTab: !1
                    }
                }, {
                    id: 2,
                    label: "Split DM Tab",
                    config: {
                        showRedesign: !0,
                        showNewPanels: !0,
                        isSplitMessagesTab: !0
                    }
                }, {
                    id: 3,
                    label: "Base redesign",
                    config: {
                        showRedesign: !0,
                        showNewPanels: !1,
                        isSplitMessagesTab: !1
                    }
                }],
                o = (0, i.createExperiment)({
                    kind: "user",
                    id: "2023-09_mobile_redesign_panels_existing_users",
                    label: "Tabs V2 - Panels - Existing Users",
                    defaultConfig: s,
                    treatments: a
                }),
                r = (0, i.createExperiment)({
                    kind: "user",
                    id: "2023-09_mobile_redesign_panels_new_users",
                    label: "Tabs V2 - Panels - New Users",
                    defaultConfig: s,
                    treatments: a
                })
        },
        460609: function(e, t, n) {
            "use strict";
            n.r(t);
            var i = n("862205");
            n("916863"), n("985268"), n("699145"), n("102425"), n("140567");
            let s = {
                    showRedesign: !1,
                    showNewVoiceUI: !1,
                    showNewNotificationCenter: !1,
                    showNewSearch: !1,
                    showDay0: !1
                },
                a = [{
                    id: 1,
                    label: "Redesign Base",
                    config: {
                        showRedesign: !0,
                        showNewVoiceUI: !1,
                        showNewNotificationCenter: !1,
                        showNewSearch: !1,
                        showDay0: !1
                    }
                }, {
                    id: 2,
                    label: "Redesign + Voice UI",
                    config: {
                        showRedesign: !0,
                        showNewVoiceUI: !0,
                        showNewNotificationCenter: !1,
                        showNewSearch: !1,
                        showDay0: !1
                    }
                }, {
                    id: 3,
                    label: "Redesign + Notification Center",
                    config: {
                        showRedesign: !0,
                        showNewVoiceUI: !1,
                        showNewNotificationCenter: !0,
                        showNewSearch: !1,
                        showDay0: !1
                    }
                }, {
                    id: 4,
                    label: "Redesign + Search",
                    config: {
                        showRedesign: !0,
                        showNewVoiceUI: !1,
                        showNewNotificationCenter: !1,
                        showNewSearch: !0,
                        showDay0: !1
                    }
                }, {
                    id: 5,
                    label: "Redesign + Everything",
                    config: {
                        showRedesign: !0,
                        showNewVoiceUI: !0,
                        showNewNotificationCenter: !0,
                        showNewSearch: !0,
                        showDay0: !0
                    }
                }, {
                    id: 6,
                    label: "Redesign + Day 0",
                    config: {
                        showRedesign: !0,
                        showNewVoiceUI: !1,
                        showNewNotificationCenter: !1,
                        showNewSearch: !1,
                        showDay0: !0
                    }
                }];
            (0, i.createExperiment)({
                kind: "user",
                id: "2023-08_mobile_redesign_phase_one_existing_users",
                label: "Tabs V2 - Phase One - Existing Users",
                defaultConfig: s,
                treatments: a
            }), (0, i.createExperiment)({
                kind: "user",
                id: "2023-08_mobile_redesign_phase_one_new_users",
                label: "Tabs V2 - Phase One - New Users",
                defaultConfig: s,
                treatments: a
            })
        },
        140567: function(e, t, n) {
            "use strict";
            n.r(t), (0, n("862205").createExperiment)({
                kind: "user",
                id: "2023-09_mobile_redesign_staff",
                label: "Tabs V2 - Staff",
                defaultConfig: {
                    isStaff: !1,
                    isStaffPersonal: !1
                },
                treatments: [{
                    id: 1,
                    label: "Staff",
                    config: {
                        isStaff: !0,
                        isStaffPersonal: !1
                    }
                }, {
                    id: 2,
                    label: "Staff Personal",
                    config: {
                        isStaff: !1,
                        isStaffPersonal: !0
                    }
                }]
            })
        },
        132522: function(e, t, n) {
            "use strict";
            n.r(t), n.d(t, {
                useRedesignToggleIgnored: function() {
                    return a
                },
                isRedesignToggleIgnored: function() {
                    return o
                }
            });
            var i = n("862205");
            n("934306");
            let s = (0, i.createExperiment)({
                kind: "user",
                id: "2023-09_mobile_redesign_override_toggles",
                label: "Tabs V2 - redesign opt-out/in for all",
                defaultConfig: {
                    hide: !1,
                    ignore: !1
                },
                treatments: [{
                    id: 1,
                    label: "control",
                    config: {
                        hide: !1,
                        ignore: !1
                    }
                }, {
                    id: 2,
                    label: "hide toggles",
                    config: {
                        hide: !0,
                        ignore: !1
                    }
                }, {
                    id: 3,
                    label: "hide & ignore toggles",
                    config: {
                        hide: !0,
                        ignore: !0
                    }
                }]
            });
            (0, i.createExperiment)({
                kind: "user",
                id: "2023-09_mobile_redesign_override_toggles_t2",
                label: "Tabs V2 - redesign opt-out for T2",
                defaultConfig: {
                    hide: !1
                },
                treatments: [{
                    id: 1,
                    label: "show",
                    config: {
                        hide: !1
                    }
                }, {
                    id: 2,
                    label: "hide",
                    config: {
                        hide: !0
                    }
                }]
            });
            let a = () => s.useExperiment({
                    location: "x"
                }, {
                    autoTrackExposure: !1
                }).ignore,
                o = () => s.getCurrentConfig({
                    location: "x"
                }, {
                    autoTrackExposure: !1
                }).ignore
        },
        693051: function(e, t, n) {
            "use strict";

            function i() {}
            n.r(t), n.d(t, {
                getRootNavigationRef: function() {
                    return i
                }
            })
        },
        139404: function(e, t, n) {
            "use strict";

            function i() {
                return !1
            }

            function s() {
                return !1
            }
            n.r(t), n.d(t, {
                useMobileRedesignDisabled: function() {
                    return i
                },
                isMobileRedesignDisabled: function() {
                    return s
                }
            })
        },
        61796: function(e, t, n) {
            "use strict";

            function i() {
                return !1
            }
            n.r(t), n.d(t, {
                isMainTabsExperimentPlatformSupported: function() {
                    return i
                }
            })
        },
        264325: function(e, t, n) {
            "use strict";

            function i() {
                return !1
            }

            function s() {
                return !1
            }
            n.r(t), n.d(t, {
                useIsTabsUIEnabledManually: function() {
                    return i
                },
                isTabsUIEnabledManually: function() {
                    return s
                }
            })
        },
        18108: function(e, t, n) {
            "use strict";
            let i, s;
            n.r(t), n.d(t, {
                updateIsInTabsUI: function() {
                    return d
                },
                updateIsInNewPanels: function() {
                    return c
                }
            });
            var a = n("411916"),
                o = n("827032"),
                r = n("599110"),
                l = n("286235");

            function u() {
                let e = i ? s ? a.DesignIds.DESIGN_TABS_IA : a.DesignIds.DESIGN_IA : a.DesignIds.CLASSIC_IA;
                r.default.extendSuperProperties({
                    design_id: e
                }), o.addGlobalTag("design_id", e), l.default.setTags({
                    design_id: "".concat(e)
                })
            }

            function d(e) {
                i !== e && (i = e, u())
            }

            function c(e) {
                s !== e && (s = e, u())
            }
        },
        446411: function(e, t, n) {
            "use strict";
            n.r(t), n.d(t, {
                isOnGlobalPanels: function() {
                    return a
                }
            });
            var i = n("650033");
            n("362391");
            var s = n("21121");

            function a() {
                return !!(0, s.isInMainTabsExperiment)() && i.default.get("global_panels")
            }
        },
        934306: function(e, t, n) {
            "use strict";
            let i;
            n.r(t), n.d(t, {
                isOnNewPanels: function() {
                    return E
                },
                useOnNewPanels: function() {
                    return g
                },
                isSplitMessagesTab: function() {
                    return S
                },
                isSplitMessagesTabAndOnMessagesTab: function() {
                    return _
                },
                shouldHandleNewPanelsRoute: function() {
                    return v
                }
            });
            var s = n("95410"),
                a = n("650033"),
                o = n("362391"),
                r = n("760190"),
                l = n("21121"),
                u = n("699145"),
                d = n("102425"),
                c = n("18108"),
                h = n("446411"),
                p = n("491246"),
                f = n("49111");

            function m(e) {
                (0, c.updateIsInNewPanels)(e), i !== e && (s.default.set("isOnNewPanels", e), i = e)
            }

            function E() {
                return (0, l.isInMainTabsExperiment)() ? !!(0, h.isOnGlobalPanels)() || (a.default.get("new_panels") ? (m(!0), !0) : r.default.hasLoadedExperiments || void 0 === i ? d.MainTabsV2PanelsExperimentExistingUsers.getCurrentConfig({
                    location: "isOnNewPanels"
                }, {
                    autoTrackExposure: !1
                }).showNewPanels || d.MainTabsV2PanelsExperimentNewUsers.getCurrentConfig({
                    location: "isOnNewPanels"
                }, {
                    autoTrackExposure: !1
                }).showNewPanels || u.MainTabsV2OnePercentExperimentExistingUsers.getCurrentConfig({
                    location: "isOnNewPanels"
                }, {
                    autoTrackExposure: !1
                }).showPanels || u.MainTabsV2OnePercentExperimentNewUsers.getCurrentConfig({
                    location: "isOnNewPanels"
                }, {
                    autoTrackExposure: !1
                }).showPanels ? (m(!0), !0) : (m(!1), !1) : i) : (m(!1), !1)
            }

            function g() {
                let e = (0, l.useInMainTabsExperiment)(),
                    t = (0, o.default)("new_panels"),
                    n = d.MainTabsV2PanelsExperimentExistingUsers.useExperiment({
                        location: "useOnNewPanels"
                    }, {
                        autoTrackExposure: !1
                    }).showNewPanels,
                    i = d.MainTabsV2PanelsExperimentNewUsers.useExperiment({
                        location: "useOnNewPanels"
                    }, {
                        autoTrackExposure: !1
                    }).showNewPanels,
                    s = u.MainTabsV2OnePercentExperimentExistingUsers.useExperiment({
                        location: "useOnNewPanels"
                    }, {
                        autoTrackExposure: !1
                    }).showPanels,
                    a = u.MainTabsV2OnePercentExperimentNewUsers.useExperiment({
                        location: "useOnNewPanels"
                    }, {
                        autoTrackExposure: !1
                    }).showPanels;
                return e && (t || n || i || s || a)
            }

            function S() {
                return !!(0, l.isInMainTabsExperiment)() && (!!(!E() || (0, h.isOnGlobalPanels)() || a.default.get("panels_split_messages_tab")) || !!d.MainTabsV2PanelsExperimentExistingUsers.getCurrentConfig({
                    location: "isSplitMessagesTab"
                }, {
                    autoTrackExposure: !1
                }).isSplitMessagesTab || !!d.MainTabsV2PanelsExperimentNewUsers.getCurrentConfig({
                    location: "isSplitMessagesTab"
                }, {
                    autoTrackExposure: !1
                }).isSplitMessagesTab || !!u.MainTabsV2OnePercentExperimentExistingUsers.getCurrentConfig({
                    location: "isSplitMessagesTab"
                }, {
                    autoTrackExposure: !1
                }).showPanels || !!u.MainTabsV2OnePercentExperimentNewUsers.getCurrentConfig({
                    location: "isSplitMessagesTab"
                }, {
                    autoTrackExposure: !1
                }).showPanels || !1)
            }

            function _() {
                if (!S()) return !1;
                let e = (0, p.default)();
                return (null == e ? void 0 : e.name) === "messages"
            }

            function v(e) {
                return !(!E() || (0, h.isOnGlobalPanels)()) && (!S() || null != e && e !== f.ME)
            }
        },
        491246: function(e, t, n) {
            "use strict";
            n.r(t), n.d(t, {
                default: function() {
                    return s
                }
            });
            var i = n("693051");

            function s() {
                let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : (0, i.getRootNavigationRef)(),
                    t = (null == e ? void 0 : e.isReady()) === !0 ? null == e ? void 0 : e.getCurrentRoute() : void 0;
                return t
            }
        },
        746800: function(e, t, n) {
            "use strict";
            n.r(t), n.d(t, {
                default: function() {
                    return i
                }
            });
            var i = (0, n("862205").createExperiment)({
                kind: "user",
                id: "2022-11_rtx40xx_gpu_screenshare_with_av1",
                label: "Test how AV1 works on windows with RTX40xx GPUs for screenshare",
                defaultConfig: {
                    signalAV1Support: !1
                },
                treatments: [{
                    id: 1,
                    label: "Screenshare with AV1",
                    config: {
                        signalAV1Support: !0
                    }
                }]
            })
        },
        469543: function(e, t, n) {
            "use strict";
            n.r(t), n.d(t, {
                default: function() {
                    return i
                }
            });
            var i = (0, n("862205").createExperiment)({
                kind: "user",
                id: "2023-09_amd_relaxed_rate_control",
                label: "Alternative rate control proposal for AMD encoder",
                defaultConfig: {
                    amdRelaxedRc: !1
                },
                treatments: [{
                    id: 1,
                    label: "AMD relaxed rate control",
                    config: {
                        amdRelaxedRc: !0
                    }
                }]
            })
        },
        967039: function(e, t, n) {
            "use strict";
            n.r(t), n.d(t, {
                default: function() {
                    return a
                }
            }), n("222007");
            var i = n("862205");
            let s = (0, i.createExperiment)({
                kind: "user",
                id: "2023-10_bandwidth_estimation_v1",
                label: "Bandwidth Estimation",
                defaultConfig: {
                    enabled: !1,
                    fullname: ""
                },
                treatments: [{
                    id: 1,
                    label: "Sender: Loss-Based BWE V2",
                    config: {
                        enabled: !0,
                        fullname: "bandwidth_estimation/loss-based-bwe-v2/"
                    }
                }, {
                    id: 2,
                    label: "Sender: Robust Estimator",
                    config: {
                        enabled: !0,
                        fullname: "bandwidth_estimation/robust-estimator/"
                    }
                }, {
                    id: 3,
                    label: "Sender: Loss-Based BWE V2 + Robust Estimator",
                    config: {
                        enabled: !0,
                        fullname: "bandwidth_estimation/loss-based-bwe-v2,robust-estimator/"
                    }
                }, {
                    id: 4,
                    label: "Sender: Trendline Window Size",
                    config: {
                        enabled: !0,
                        fullname: "bandwidth_estimation/trendline-window-size/"
                    }
                }, {
                    id: 5,
                    label: "Sender: Trendline Window Size + Robust Estimator",
                    config: {
                        enabled: !0,
                        fullname: "bandwidth_estimation/trendline-window-size,robust-estimator/"
                    }
                }, {
                    id: 6,
                    label: "Worker: Loss-Based BWE V2",
                    config: {
                        enabled: !0,
                        fullname: "bandwidth_estimation//loss-based-bwe-v2"
                    }
                }, {
                    id: 7,
                    label: "Worker: Robust Estimator",
                    config: {
                        enabled: !0,
                        fullname: "bandwidth_estimation//robust-estimator"
                    }
                }, {
                    id: 8,
                    label: "Worker: Loss-Based BWE V2 + Robust Estimator",
                    config: {
                        enabled: !0,
                        fullname: "bandwidth_estimation//loss-based-bwe-v2,robust-estimator"
                    }
                }, {
                    id: 9,
                    label: "Worker: Trendline Window Size",
                    config: {
                        enabled: !0,
                        fullname: "bandwidth_estimation//trendline-window-size"
                    }
                }, {
                    id: 10,
                    label: "Worker: Trendline Window Size + Robust Estimator",
                    config: {
                        enabled: !0,
                        fullname: "bandwidth_estimation//trendline-window-size,robust-estimator"
                    }
                }, {
                    id: 11,
                    label: "Sender + Worker: Trendline Window Size",
                    config: {
                        enabled: !0,
                        fullname: "bandwidth_estimation/trendline-window-size/trendline-window-size"
                    }
                }, {
                    id: 12,
                    label: "Sender + Worker: Trendline Window Size + Robust Estimator",
                    config: {
                        enabled: !0,
                        fullname: "bandwidth_estimation/trendline-window-size,robust-estimator/trendline-window-size,robust-estimator"
                    }
                }, {
                    id: 13,
                    label: "Sender + Worker: Loss-Based-BWE V2 + Trendline Window Size + Robust Estimator",
                    config: {
                        enabled: !0,
                        fullname: "bandwidth_estimation/loss-based-bwe-v2,trendline-window-size,robust-estimator/loss-based-bwe-v2,trendline-window-size,robust-estimator"
                    }
                }]
            });
            var a = {
                getConfig(e, t) {
                    let n = s.getCurrentConfig({
                        location: "e1c55b_1"
                    }, {
                        autoTrackExposure: e
                    });
                    return !this.supportsBandwidthEstimationExperimentFullname(n.fullname, t) && (n.enabled = !1), n
                },
                supportsBandwidthEstimationExperimentFullname(e, t) {
                    let n = this.getMediaEngineExperiments(e);
                    if (null === n) return !1;
                    for (let e of n)
                        if (!t.includes(e)) return !1;
                    return !0
                },
                getMediaEngineExperiments(e) {
                    let t = e.split("/");
                    return 3 !== t.length || "bandwidth_estimation" !== t[0] ? null : t[1].split(",").filter(e => 0 !== e.length)
                }
            }
        },
        584687: function(e, t, n) {
            "use strict";
            n.r(t), n.d(t, {
                default: function() {
                    return i
                }
            });
            var i = (0, n("862205").createExperiment)({
                kind: "user",
                id: "2023-09_decoupled_game_clipping",
                label: "Test decoupled game clipping",
                defaultConfig: {
                    enableDecoupledGameClipping: !1
                },
                treatments: [{
                    id: 1,
                    label: "Decoupled Game Clipping",
                    config: {
                        enableDecoupledGameClipping: !0
                    }
                }]
            })
        },
        647114: function(e, t, n) {
            "use strict";
            n.r(t), n.d(t, {
                default: function() {
                    return i
                }
            });
            var i = (0, n("862205").createExperiment)({
                kind: "user",
                id: "2022-08_windows_graphics_capture",
                label: "Windows Graphics Capture",
                defaultConfig: {
                    graphicsCaptureEnabled: !1
                },
                treatments: [{
                    id: 1,
                    label: "Graphics Captrue Enabled",
                    config: {
                        graphicsCaptureEnabled: !0
                    }
                }]
            })
        },
        334280: function(e, t, n) {
            "use strict";
            n.r(t), (0, n("862205").createExperiment)({
                kind: "user",
                id: "2023-02_h265_android",
                label: "Test how h265 works on android for DM calls",
                defaultConfig: {
                    signalH265SupportAndroid: !1
                },
                treatments: [{
                    id: 1,
                    label: "Calling with H.265",
                    config: {
                        signalH265SupportAndroid: !0
                    }
                }]
            })
        },
        705500: function(e, t, n) {
            "use strict";
            n.r(t), n.d(t, {
                default: function() {
                    return i
                }
            });
            var i = (0, n("862205").createExperiment)({
                kind: "user",
                id: "2023-06_h265_macos",
                label: "Test how h265 works on macos",
                defaultConfig: {
                    signalH265SupportMacOS: !1
                },
                treatments: [{
                    id: 1,
                    label: "Calling with H.265",
                    config: {
                        signalH265SupportMacOS: !0
                    }
                }]
            })
        },
        715440: function(e, t, n) {
            "use strict";
            n.r(t), (0, n("862205").createExperiment)({
                kind: "user",
                id: "2022-10_h265_dm_call",
                label: "Test how h265 works on ios/macos for DM calls",
                defaultConfig: {
                    signalH265SupportApple: !1
                },
                treatments: [{
                    id: 1,
                    label: "Calling with H.265",
                    config: {
                        signalH265SupportApple: !0
                    }
                }]
            })
        },
        238847: function(e, t, n) {
            "use strict";
            n.r(t), n.d(t, {
                default: function() {
                    return i
                }
            });
            var i = (0, n("862205").createExperiment)({
                kind: "user",
                id: "2023-07_h265_for_windows_with_nvidia",
                label: "Test how h265 works on Windows with Nvidia nvenc codec",
                defaultConfig: {
                    signalH265SupportNvenc: !1
                },
                treatments: [{
                    id: 1,
                    label: "Calling with H.265",
                    config: {
                        signalH265SupportNvenc: !0
                    }
                }]
            })
        },
        981699: function(e, t, n) {
            "use strict";
            n.r(t), n.d(t, {
                default: function() {
                    return i
                }
            });
            var i = (0, n("862205").createExperiment)({
                kind: "user",
                id: "2021-06_hdr_screen_capture",
                label: "HDR Screen Capture",
                defaultConfig: {
                    hdrCaptureMode: "never"
                },
                treatments: [{
                    id: 1,
                    label: "Always",
                    config: {
                        hdrCaptureMode: "always"
                    }
                }, {
                    id: 2,
                    label: "Permitted Devices Only",
                    config: {
                        hdrCaptureMode: "permittedDevicesOnly"
                    }
                }]
            })
        },
        140622: function(e, t, n) {
            "use strict";
            n.r(t), n.d(t, {
                default: function() {
                    return i
                }
            });
            var i = (0, n("862205").createExperiment)({
                kind: "user",
                id: "2023-08_full_band_krisp_android_",
                label: "Let us control if full band is enabled on Android",
                defaultConfig: {
                    allowSettingFullbandAndroid: !1
                },
                treatments: [{
                    id: 1,
                    label: "Load full band krisp model",
                    config: {
                        allowSettingFullbandAndroid: !0
                    }
                }]
            })
        },
        16001: function(e, t, n) {
            "use strict";
            n.r(t), n.d(t, {
                default: function() {
                    return i
                }
            });
            var i = (0, n("862205").createExperiment)({
                kind: "user",
                id: "2021-08_max_sync_delay",
                label: "Overrides the default max sync delay for AV streams in WebRTC",
                defaultConfig: {
                    maxSyncDelayOverride: 0
                },
                treatments: [{
                    id: 1,
                    label: "Use 3 seconds as max sync delay",
                    config: {
                        maxSyncDelayOverride: 3e3
                    }
                }]
            })
        },
        631508: function(e, t, n) {
            "use strict";
            n.r(t), n.d(t, {
                default: function() {
                    return i
                }
            });
            var i = (0, n("862205").createExperiment)({
                kind: "user",
                id: "2021-02_quartz_video_source",
                label: "Quartz Video Source",
                defaultConfig: {
                    useQuartzCapturer: !1,
                    allowScreenCaptureKit: !1
                },
                treatments: [{
                    id: 1,
                    label: "gotta go fast",
                    config: {
                        useQuartzCapturer: !0,
                        allowScreenCaptureKit: !1
                    }
                }, {
                    id: 2,
                    label: "2fast 2furious",
                    config: {
                        useQuartzCapturer: !0,
                        allowScreenCaptureKit: !0
                    }
                }]
            })
        },
        368765: function(e, t, n) {
            "use strict";
            n.r(t), n.d(t, {
                default: function() {
                    return i
                }
            });
            var i = (0, n("862205").createExperiment)({
                kind: "user",
                id: "2023-10_screencapturekit",
                label: "ScreenCaptureKit",
                defaultConfig: {
                    allowScreenCaptureKit: !1
                },
                treatments: [{
                    id: 1,
                    label: "enabled",
                    config: {
                        allowScreenCaptureKit: !0
                    }
                }]
            })
        },
        403770: function(e, t, n) {
            "use strict";
            n.r(t), n.d(t, {
                SecureFramesUserExperiment: function() {
                    return s
                },
                SecureFramesGuildExperiment: function() {
                    return a
                }
            });
            var i = n("862205");
            let s = (0, i.createExperiment)({
                    kind: "user",
                    id: "2023-08_secure_frames_encryption",
                    label: "Allowing testing secure frames for voice/video",
                    defaultConfig: {
                        canSupportSecureFrames: !1
                    },
                    treatments: [{
                        id: 1,
                        label: "Can support secure frames for voice/video",
                        config: {
                            canSupportSecureFrames: !0
                        }
                    }]
                }),
                a = (0, i.createExperiment)({
                    kind: "guild",
                    id: "2023-11_secure_frames_encryption_guilds",
                    label: "Allowing testing secure frames for voice/video (Guilds)",
                    defaultConfig: {
                        canSupportSecureFrames: !1
                    },
                    treatments: [{
                        id: 1,
                        label: "Can support secure frames for voice/video",
                        config: {
                            canSupportSecureFrames: !0
                        }
                    }]
                })
        },
        940146: function(e, t, n) {
            "use strict";
            n.r(t), n.d(t, {
                default: function() {
                    return a
                }
            });
            var i = n("862205");
            let s = (0, i.createExperiment)({
                kind: "user",
                id: "2023-10_video_hook_stale_frame_timeout",
                label: "Video Hook Stale Frame Timeout",
                defaultConfig: {
                    videoHookStaleFrameTimeoutMs: 500
                },
                treatments: [{
                    id: 1,
                    label: "1 second",
                    config: {
                        videoHookStaleFrameTimeoutMs: 1e3
                    }
                }, {
                    id: 2,
                    label: "5 seconds",
                    config: {
                        videoHookStaleFrameTimeoutMs: 5e3
                    }
                }, {
                    id: 3,
                    label: "10 seconds",
                    config: {
                        videoHookStaleFrameTimeoutMs: 1e4
                    }
                }, {
                    id: 4,
                    label: "30 seconds",
                    config: {
                        videoHookStaleFrameTimeoutMs: 3e4
                    }
                }, {
                    id: 5,
                    label: "60 seconds",
                    config: {
                        videoHookStaleFrameTimeoutMs: 6e4
                    }
                }, {
                    id: 5,
                    label: "120 seconds",
                    config: {
                        videoHookStaleFrameTimeoutMs: 12e4
                    }
                }]
            });
            var a = {
                getConfig: (e, t, n) => e ? s.getCurrentConfig({
                    location: t
                }, {
                    autoTrackExposure: n
                }) : s.definition.defaultConfig
            }
        },
        834604: function(e, t, n) {
            "use strict";
            n.r(t), n.d(t, {
                default: function() {
                    return a
                }
            });
            var i = n("862205");
            let s = (0, i.createExperiment)({
                kind: "user",
                id: "2023-08_video_quality_measurement_v1",
                label: "Video Quality Measurement",
                defaultConfig: {
                    enabled: !1,
                    measurement: ""
                },
                treatments: [{
                    id: 1,
                    label: "Measure PSNR [DEPRECATED DO NOT USE]",
                    config: {
                        enabled: !0,
                        measurement: "psnr"
                    }
                }, {
                    id: 2,
                    label: "Measure PSNR Only",
                    config: {
                        enabled: !0,
                        measurement: "imageQualityWebrtcPsnrDb"
                    }
                }, {
                    id: 3,
                    label: "Measure VMAF Only",
                    config: {
                        enabled: !0,
                        measurement: "imageQualityVmaf_v061"
                    }
                }, {
                    id: 4,
                    label: "Measure PSNR and VMAF",
                    config: {
                        enabled: !0,
                        measurement: "imageQualityWebrtcPsnrDb,imageQualityVmaf_v061"
                    }
                }, {
                    id: 5,
                    label: "Measure PSNR Only, 5000ms",
                    config: {
                        enabled: !0,
                        measurement: "imageQualityWebrtcPsnrDb:5000"
                    }
                }, {
                    id: 6,
                    label: "Measure VMAF Only, 5000ms",
                    config: {
                        enabled: !0,
                        measurement: "imageQualityVmaf_v061:5000"
                    }
                }, {
                    id: 7,
                    label: "Measure PSNR and VMAF, 5000ms",
                    config: {
                        enabled: !0,
                        measurement: "imageQualityWebrtcPsnrDb:5000,imageQualityVmaf_v061:5000"
                    }
                }, {
                    id: 8,
                    label: "Measure PSNR Only, 10000ms",
                    config: {
                        enabled: !0,
                        measurement: "imageQualityWebrtcPsnrDb:10000"
                    }
                }, {
                    id: 9,
                    label: "Measure VMAF Only, 10000ms",
                    config: {
                        enabled: !0,
                        measurement: "imageQualityVmaf_v061:10000"
                    }
                }, {
                    id: 10,
                    label: "Measure PSNR and VMAF, 10000ms",
                    config: {
                        enabled: !0,
                        measurement: "imageQualityWebrtcPsnrDb:10000,imageQualityVmaf_v061:10000"
                    }
                }, {
                    id: 11,
                    label: "Measure PSNR Only, 30000ms",
                    config: {
                        enabled: !0,
                        measurement: "imageQualityWebrtcPsnrDb:30000"
                    }
                }, {
                    id: 12,
                    label: "Measure VMAF Only, 30000ms",
                    config: {
                        enabled: !0,
                        measurement: "imageQualityVmaf_v061:30000"
                    }
                }, {
                    id: 13,
                    label: "Measure PSNR and VMAF, 30000ms",
                    config: {
                        enabled: !0,
                        measurement: "imageQualityWebrtcPsnrDb:30000,imageQualityVmaf_v061:30000"
                    }
                }]
            });
            var a = {
                isFeatureSupportedOnPlatform: () => !0,
                getConfig(e) {
                    let t = s.getCurrentConfig({
                        location: "e1c55b_1"
                    }, {
                        autoTrackExposure: e
                    });
                    return !this.isFeatureSupportedOnPlatform() && (t.enabled = !1), t
                }
            }
        },
        355014: function(e, t, n) {
            "use strict";
            n.r(t), n.d(t, {
                default: function() {
                    return i
                }
            });
            var i = (0, n("862205").createExperiment)({
                kind: "user",
                id: "2023-11_video_quality_measurement_hwdec",
                label: "Video Quality Measurement Hardware Decoding",
                defaultConfig: {
                    enabled: !1
                },
                treatments: [{
                    id: 0,
                    label: "Control",
                    config: {
                        enabled: !1
                    }
                }, {
                    id: 1,
                    label: "Enabled",
                    config: {
                        enabled: !0
                    }
                }]
            })
        },
        353500: function(e, t, n) {
            "use strict";
            n.r(t), n.d(t, {
                default: function() {
                    return i
                }
            });
            var i = (0, n("862205").createExperiment)({
                kind: "user",
                id: "2021-03_videotoolbox_rate_optimization",
                label: "VideoToolbox Rate Control Optimizations",
                defaultConfig: {
                    useExperimentalRateControl: !1
                },
                treatments: [{
                    id: 1,
                    label: "On",
                    config: {
                        useExperimentalRateControl: !0
                    }
                }]
            })
        },
        103979: function(e, t, n) {
            "use strict";
            n.r(t), n.d(t, {
                default: function() {
                    return i
                }
            });
            var i = (0, n("862205").createExperiment)({
                kind: "user",
                id: "2023-10_viewer_clipping",
                label: "Test viewer side clipping",
                defaultConfig: {
                    enableViewerClipping: !1,
                    ignoreSenderPreference: !1
                },
                treatments: [{
                    id: 1,
                    label: "Viewer Clipping enabled",
                    config: {
                        enableViewerClipping: !0,
                        ignoreSenderPreference: !1
                    }
                }, {
                    id: 99,
                    label: "Viewer Clipping enabled; For developer testing",
                    config: {
                        enableViewerClipping: !0,
                        ignoreSenderPreference: !0
                    }
                }]
            })
        },
        665862: function(e, t, n) {
            "use strict";
            n.r(t), n.d(t, {
                default: function() {
                    return a
                }
            });
            var i = n("862205");
            let s = (0, i.createExperiment)({
                kind: "user",
                id: "2023-10_wgc_stale_frame_timeout",
                label: "Windows Graphics Capture Stale Frame Timeout",
                defaultConfig: {
                    graphicsCaptureStaleFrameTimeoutMs: 500
                },
                treatments: [{
                    id: 1,
                    label: "1 second",
                    config: {
                        graphicsCaptureStaleFrameTimeoutMs: 1e3
                    }
                }, {
                    id: 2,
                    label: "5 seconds",
                    config: {
                        graphicsCaptureStaleFrameTimeoutMs: 5e3
                    }
                }, {
                    id: 3,
                    label: "10 seconds",
                    config: {
                        graphicsCaptureStaleFrameTimeoutMs: 1e4
                    }
                }, {
                    id: 4,
                    label: "30 seconds",
                    config: {
                        graphicsCaptureStaleFrameTimeoutMs: 3e4
                    }
                }, {
                    id: 5,
                    label: "60 seconds",
                    config: {
                        graphicsCaptureStaleFrameTimeoutMs: 6e4
                    }
                }, {
                    id: 5,
                    label: "120 seconds",
                    config: {
                        graphicsCaptureStaleFrameTimeoutMs: 12e4
                    }
                }]
            });
            var a = {
                getConfig: (e, t, n) => e ? s.getCurrentConfig({
                    location: t
                }, {
                    autoTrackExposure: n
                }) : s.definition.defaultConfig
            }
        },
        591883: function(e, t, n) {
            "use strict";
            n.r(t), n.d(t, {
                default: function() {
                    return a
                }
            });
            var i = n("913144"),
                s = n("353927");

            function a(e, t) {
                i.default.wait(() => {
                    i.default.dispatch({
                        type: "AUDIO_SET_LOCAL_VIDEO_DISABLED",
                        context: s.MediaEngineContextTypes.DEFAULT,
                        userId: e,
                        videoToggleState: t,
                        persist: !1,
                        isAutomatic: !0
                    })
                })
            }
        },
        222920: function(e, t, n) {
            "use strict";
            n.r(t), (0, n("862205").createExperiment)({
                kind: "user",
                id: "2021-09_ios_screenshare_resolution_profiles",
                label: "iOS: Screenshare resolution profiles",
                defaultConfig: {
                    profile: 0
                },
                treatments: [{
                    id: 1,
                    label: "Permanent old resolution",
                    config: {
                        profile: 1
                    }
                }, {
                    id: 2,
                    label: "Old resolution for 10s",
                    config: {
                        profile: 2
                    }
                }, {
                    id: 3,
                    label: "Wait 3s after 1st frame capture",
                    config: {
                        profile: 3
                    }
                }, {
                    id: 4,
                    label: "Wait 3s to capture 1st frame",
                    config: {
                        profile: 4
                    }
                }]
            })
        },
        122530: function(e, t, n) {
            "use strict";
            let i, s;
            n.r(t), n.d(t, {
                default: function() {
                    return l
                },
                setVideoToggleAnalyticsParams: function() {
                    return u
                }
            });
            var a = n("599110"),
                o = n("49111"),
                r = n("353927");

            function l(e, t, n) {
                a.default.track(o.AnalyticEvents.VIDEO_TOGGLED, {
                    video_toggle_reason: t,
                    toggled_user_id: e,
                    rtc_connection_id: null == i ? void 0 : i(),
                    media_session_id: null == s ? void 0 : s(),
                    video_health_manager_window_length: null,
                    video_health_manager_poor_fps_ratio: null,
                    video_health_manager_fps_threshold: null,
                    is_video_shown: n,
                    video_health_manager_backoff_time_seconds: null
                })
            }

            function u(e, t) {
                i = e, s = t
            }
        },
        827032: function(e, t, n) {
            "use strict";
            n.r(t), n.d(t, {
                addGlobalTag: function() {
                    return s
                },
                getGlobalTagsArray: function() {
                    return a
                }
            });
            let i = {};

            function s(e, t) {
                i[e] = t
            }

            function a() {
                return Object.keys(i).map(e => "".concat(e, ":").concat(i[e]))
            }
        },
        489269: function(e, t, n) {
            "use strict";
            n.r(t), n.d(t, {
                default: function() {
                    return s
                }
            });
            var i = n("913144"),
                s = class e {
                    static setPermission(e, t) {
                        i.default.dispatch({
                            type: "SET_NATIVE_PERMISSION",
                            permissionType: e,
                            state: t
                        })
                    }
                }
        },
        426685: function(e, t, n) {
            "use strict";
            n.r(t), n.d(t, {
                NativePermissionBaseUtils: function() {
                    return u
                }
            }), n("70102");
            var i = n("599110"),
                s = n("489269"),
                a = n("581892"),
                o = n("180524"),
                r = n("49111"),
                l = n("782340");
            class u {
                async requestAuthorization(e, t, n) {
                    if ("function" != typeof t) throw Error("requestAuthorization: Was provided with not a function for ".concat(e, "."));
                    i.default.track(r.AnalyticEvents.PERMISSIONS_REQUESTED, {
                        type: e
                    });
                    let a = await t() === o.NativePermissionStatus.AUTHORIZED,
                        l = a ? o.NativePermissionStates.ACCEPTED : o.NativePermissionStates.DENIED;
                    return s.default.setPermission(e, l), !a && n.showAuthorizationError && this.showAlert(e), a
                }
                requestPermission(e, t) {
                    let n = u.defaultNativePermissionsRequestOptions(t);
                    return this.requestPermissionCore(e, n)
                }
                hasPermission(e, t) {
                    let n = u.defaultNativePermissionsRequestOptions(t);
                    return this.hasPermissionCore(e, n)
                }
                showAlert(e) {
                    let t = {
                            [o.NativePermissionTypes.CAMERA]: "".concat(l.default.Messages.NO_CAMERA_ACCESS, ". ").concat(l.default.Messages.ENABLE_PRIVACY_ACCESS),
                            [o.NativePermissionTypes.AUDIO]: "".concat(l.default.Messages.NO_MICRPHONE_ACCESS, ". ").concat(l.default.Messages.ENABLE_PRIVACY_ACCESS),
                            [o.NativePermissionTypes.PHOTOS]: "".concat(l.default.Messages.NO_PHOTOS_ACCESS, ". ").concat(l.default.Messages.ENABLE_PRIVACY_ACCESS),
                            [o.NativePermissionTypes.INPUT_MONITORING]: "".concat(l.default.Messages.NO_INPUT_MONITORING_ACCESS, ". ").concat(l.default.Messages.ENABLE_PRIVACY_ACCESS),
                            [o.NativePermissionTypes.CONTACTS]: "".concat(l.default.Messages.NO_CONTACTS_ACCESS, ". ").concat(l.default.Messages.ENABLE_PRIVACY_ACCESS)
                        },
                        n = t[e];
                    null != n && this.openAlertModal({
                        title: l.default.Messages.SYSTEM_PERMISSION_GRANT,
                        body: n,
                        onConfirm: () => this.openSettings(e),
                        cancelText: l.default.Messages.CANCEL,
                        confirmText: l.default.Messages.DEVICE_SETTINGS
                    })
                }
                static defaultNativePermissionsRequestOptions(e) {
                    let t = {
                        showAuthorizationError: !0
                    };
                    return null == e ? t : {
                        ...t,
                        ...e
                    }
                }
                constructor() {
                    this.storage = new a.default
                }
            }
        },
        180524: function(e, t, n) {
            "use strict";
            var i, s, a, o, r, l, u, d;
            n.r(t), n.d(t, {
                NativePermissionStatus: function() {
                    return i
                },
                NativePermissionStates: function() {
                    return s
                },
                NativePermissionTypes: function() {
                    return a
                }
            }), (r = i || (i = {})).AUTHORIZED = "authorized", r.DENIED = "denied", r.RESTRICTED = "restricted", r.UNDETERMINED = "undetermined", (l = s || (s = {})).DISMISSED = "dismissed", l.DENIED = "denied", l.ACCEPTED = "accepted", l.NO_DEVICES = "no_devices", l.ERROR = "error", l.NONE = "none", (u = a || (a = {})).AUDIO = "audio", u.CAMERA = "camera", u.STORAGE = "storage", u.NOTIFICATIONS = "notifications", u.PHOTOS = "photos", u.CONTACTS = "contacts", u.INPUT_MONITORING = "input_monitoring", u.SCREEN_RECORDING = "screen_recording", (d = o || (o = {}))[d.UNDETERMINED = 0] = "UNDETERMINED", d[d.DENIED = 1] = "DENIED", d[d.AUTHORIZED = 2] = "AUTHORIZED", d[d.PROVISIONAL = 3] = "PROVISIONAL", d[d.EPHEMERAL = 4] = "EPHEMERAL"
        },
        66265: function(e, t, n) {
            "use strict";
            n.r(t), n.d(t, {
                default: function() {
                    return d
                }
            });
            var i = n("913144"),
                s = n("316272"),
                a = n("773336"),
                o = n("197881"),
                r = n("180524"),
                l = n("49111");
            class u extends s.default {
                isEnabled() {
                    return (0, a.isDesktop)() && (0, a.isMac)() && !o.ProcessArgs.isDiscordTestSet()
                }
                _initialize() {
                    this.isEnabled() && i.default.subscribe("AUDIO_SET_MODE", this.handleAudioSetMode)
                }
                _terminate() {
                    this.isEnabled() && i.default.unsubscribe("AUDIO_SET_MODE", this.handleAudioSetMode)
                }
                handleAudioSetMode(e) {
                    let {
                        mode: t
                    } = e;
                    if (t === l.InputModes.PUSH_TO_TALK) {
                        let e = n("928609").default;
                        e.requestPermission(r.NativePermissionTypes.INPUT_MONITORING)
                    }
                }
            }
            var d = new u
        },
        581892: function(e, t, n) {
            "use strict";
            n.r(t), n.d(t, {
                default: function() {
                    return d
                }
            });
            var i = n("446674"),
                s = n("913144"),
                a = n("599110"),
                o = n("180524"),
                r = n("49111");
            let l = {
                permissionStates: {}
            };
            class u extends i.default.DeviceSettingsStore {
                initialize(e) {
                    l = null != e ? e : l
                }
                getUserAgnosticState() {
                    return l
                }
                hasPermission(e) {
                    let t = l.permissionStates,
                        n = t[e];
                    return null != n && n === o.NativePermissionStates.ACCEPTED
                }
                handleSetNativePermission(e) {
                    let {
                        state: t,
                        permissionType: n
                    } = e, i = l.permissionStates, s = i[n];
                    i[n] = t, s !== t && a.default.track(r.AnalyticEvents.PERMISSIONS_ACKED, {
                        type: n,
                        action: t,
                        previous_action: null != s ? s : o.NativePermissionStates.NONE
                    })
                }
                constructor() {
                    super(s.default, {
                        SET_NATIVE_PERMISSION: e => this.handleSetNativePermission(e)
                    })
                }
            }
            u.displayName = "NativePermissionStore", u.persistKey = "NativePermissionsStore";
            var d = u
        },
        912067: function(e, t, n) {
            "use strict";
            n.r(t), n.d(t, {
                default: function() {
                    return a
                }
            });
            var i = n("426685");
            class s extends i.NativePermissionBaseUtils {
                requestPermissionCore(e, t) {
                    return Promise.resolve(!0)
                }
                hasPermissionCore(e, t) {
                    return Promise.resolve(!0)
                }
                openSettings(e) {}
                didHavePermission(e) {
                    return !0
                }
                openAlertModal(e) {}
            }
            var a = new s
        },
        928609: function(e, t, n) {
            "use strict";
            let i;
            n.r(t), n.d(t, {
                NativePermissionsRequestOptions: function() {
                    return r.NativePermissionsRequestOptions
                },
                default: function() {
                    return l
                }
            });
            var s = n("773336"),
                a = n("197881"),
                o = n("66265"),
                r = n("426685");
            o.default.initialize();
            var l = i = a.ProcessArgs.isDiscordTestSet() ? n("912067").default : (0, s.isDesktop)() ? n("401717").default : n("912067").default
        },
        401717: function(e, t, n) {
            "use strict";
            n.r(t), n.d(t, {
                default: function() {
                    return l
                }
            }), n("222007");
            var i = n("404118"),
                s = n("50885"),
                a = n("426685"),
                o = n("180524");
            class r extends a.NativePermissionBaseUtils {
                requestPermissionCore(e, t) {
                    var n;
                    return this.asyncify(null === (n = this.nativeUtils) || void 0 === n ? void 0 : n.nativePermssionRequestAuthorization, e, t)
                }
                hasPermissionCore(e, t) {
                    var n;
                    return this.asyncify(null === (n = this.nativeUtils) || void 0 === n ? void 0 : n.nativePermssionHasAuthorization, e, t)
                }
                asyncify(e, t, n) {
                    let i = r.requestTypeLookup[t];
                    return void 0 === i ? Promise.resolve(!0) : this.requestAuthorization(t, () => null == e ? Promise.resolve(o.NativePermissionStatus.AUTHORIZED) : new Promise((t, n) => e(t, i)), n)
                }
                openSettings(e) {
                    var t;
                    if ((null === (t = this.nativeUtils) || void 0 === t ? void 0 : t.nativePermissionOpenSettings) == null) return;
                    let n = r.requestTypeLookup[e];
                    void 0 !== n && this.nativeUtils.nativePermissionOpenSettings(n)
                }
                didHavePermission(e) {
                    return this.storage.hasPermission(e)
                }
                openAlertModal(e) {
                    let {
                        title: t,
                        body: n,
                        onConfirm: s,
                        cancelText: a,
                        confirmText: o
                    } = e;
                    i.default.show({
                        title: t,
                        body: n,
                        onConfirm: s,
                        cancelText: a,
                        confirmText: o
                    })
                }
                constructor(...e) {
                    super(...e), this.nativeUtils = s.default.getDiscordUtils()
                }
            }
            r.requestTypeLookup = {
                [o.NativePermissionTypes.CAMERA]: s.NativePermissionRequestType.Camera,
                [o.NativePermissionTypes.AUDIO]: s.NativePermissionRequestType.Microphone,
                [o.NativePermissionTypes.PHOTOS]: s.NativePermissionRequestType.Photo,
                [o.NativePermissionTypes.INPUT_MONITORING]: s.NativePermissionRequestType.InputMonitoring,
                [o.NativePermissionTypes.SCREEN_RECORDING]: s.NativePermissionRequestType.ScreenRecording
            };
            var l = new r
        },
        6791: function(e, t, n) {
            "use strict";
            n.r(t), n.d(t, {
                OVERLAY_SUPPORTED: function() {
                    return E
                },
                OverlayNudgeTypes: function() {
                    return u
                },
                getOverlayNotificationGroup: function() {
                    return g
                },
                OverlayNotificationGroup: function() {
                    return c
                },
                OverlayNotificationType: function() {
                    return h
                },
                OverlayNotificationAction: function() {
                    return p
                },
                BackgroundOpacityClasses: function() {
                    return S
                },
                OverlayMethod: function() {
                    return f
                },
                OpacityBounds: function() {
                    return _
                }
            });
            var i, s, a, o, r, l, u, d, c, h, p, f, m = n("773336");
            let E = m.isPlatformEmbedded && ((0, m.isWindows)() || !1);

            function g(e) {
                switch (e) {
                    case "News Nudge":
                    case "Welcome Nudge":
                    case "Go Live Nudge":
                    case "Go Live Non Voice Nudge":
                    case "Start Broadcast Notification":
                        return 0;
                    case "Text Chat":
                        return 1;
                    case "Activity User Join":
                    case "Activity Invite":
                        return 3;
                    case "Incoming Call":
                        return 2;
                    case "Clips Reminder Notification":
                    case "Clips Notification":
                        return 4;
                    default:
                        return 5
                }
            }(i = u || (u = {}))[i.WELCOME = 0] = "WELCOME", i[i.NEWS = 1] = "NEWS", i[i.GO_LIVE_VOICE = 2] = "GO_LIVE_VOICE", i[i.GO_LIVE_NON_VOICE = 3] = "GO_LIVE_NON_VOICE", i[i.BROADCAST = 4] = "BROADCAST", (s = d || (d = {})).PRIMARY = "PRIMARY", s.BRAND = "BRAND", s.DANGER = "DANGER", (a = c || (c = {}))[a.Nudge = 0] = "Nudge", a[a.TextChat = 1] = "TextChat", a[a.VoiceCall = 2] = "VoiceCall", a[a.Activity = 3] = "Activity", a[a.Clips = 4] = "Clips", a[a.Other = 5] = "Other", (o = h || (h = {})).NewsNudge = "News Nudge", o.WelcomeNudge = "Welcome Nudge", o.TextChat = "Text Chat", o.ActivityUserJoin = "Activity User Join", o.ActivityInvite = "Activity Invite", o.IncomingCall = "Incoming Call", o.GoLiveNudge = "Go Live Nudge", o.GoLiveNonVoiceNudge = "Go Live Non Voice Nudge", o.OverlayCrashed = "Overlay Crashed", o.StartBroadcastNotification = "Start Broadcast Notification", o.ClipsReminderNotification = "Clips Reminder Notification", o.ClipsNotification = "Clips Notification", (r = p || (p = {}))[r.Viewed = 0] = "Viewed", r[r.Clicked = 1] = "Clicked";
            let S = Object.freeze({
                LOW: "background-opacity-low",
                MEDIUM: "background-opacity-medium",
                HIGH: "background-opacity-high",
                FULL: "background-opacity-full",
                DISABLED: null
            });
            (l = f || (f = {}))[l.Disabled = 0] = "Disabled", l[l.Hook = 1] = "Hook", l[l.OutOfProcess = 2] = "OutOfProcess";
            let _ = Object.freeze({
                BOTTOM: 0,
                LOWER: .25,
                UPPER: .75,
                TOP: 1
            })
        },
        32128: function(e, t, n) {
            "use strict";
            n.r(t), n.d(t, {
                OverlayStoredSettings: function() {
                    return r
                }
            });
            var i, s, a = n("95410"),
                o = n("6791");
            (i = s || (s = {})).Version1 = "OverlayStore", i.Version2 = "overlayEnabled", i.Version3 = "OverlayStore3";
            class r {
                static get enabled() {
                    return r.load().enabled
                }
                static get methodOverride() {
                    return r.load().methodOverride
                }
                static update(e) {
                    let t = r.load();
                    "boolean" == typeof e.enabled && (t.enabled = e.enabled), "methodOverride" in e && (t.methodOverride = e.methodOverride), t.save()
                }
                save() {
                    let e = {
                        enabled: this.enabled,
                        methodOverride: this.methodOverride
                    };
                    a.default.set("OverlayStore3", e)
                }
                static load() {
                    return null == r._loaded && (r._loaded = r.loadInternal()), r._loaded
                }
                static loadInternal() {
                    let e = void 0,
                        t = a.default.get("OverlayStore");
                    if (null != t) {
                        let n = "boolean" == typeof t.enabled ? t.enabled : o.OVERLAY_SUPPORTED,
                            i = new r(n, e);
                        return i.save(), a.default.remove("OverlayStore"), i
                    }
                    let n = a.default.get("overlayEnabled");
                    if (null != n) {
                        let t = "boolean" == typeof n ? n : o.OVERLAY_SUPPORTED,
                            i = new r(t, e);
                        return i.save(), a.default.remove("overlayEnabled"), i
                    }
                    let i = a.default.get("OverlayStore3");
                    if (null != i) {
                        var s, l;
                        return new r(null !== (s = i.enabled) && void 0 !== s ? s : o.OVERLAY_SUPPORTED, null !== (l = i.methodOverride) && void 0 !== l ? l : e)
                    }
                    let u = new r(o.OVERLAY_SUPPORTED, e);
                    return u.save(), u
                }
                constructor(e, t) {
                    this.enabled = e, this.methodOverride = t
                }
            }
            r._loaded = null
        },
        861309: function(e, t, n) {
            "use strict";
            n.r(t), n.d(t, {
                default: function() {
                    return i
                }
            });
            var i = n("631734").default
        },
        648030: function(e, t, n) {
            "use strict";
            n.r(t), n.d(t, {
                default: function() {
                    return i
                }
            }), n("843762"), n("424973"), n("70102"), n("222007");
            var i, s = n("627445"),
                a = n.n(s),
                o = n("917351"),
                r = n.n(o),
                l = n("599110"),
                u = n("861309"),
                d = n("694352"),
                c = n("846678"),
                h = n("49111");
            let p = "RPC_STORE_WAIT",
                f = [];
            i = class {
                registerTransport(e) {
                    e.on("connect", e => this.handleConnect(e)), e.on("request", (e, t) => this.handleRequest(e, t)), e.on("disconnect", (e, t) => this.handleDisconnect(e, t))
                }
                handleConnect(e) {
                    this.sockets.add(e), this.onConnect(e);
                    let t = {
                        v: e.version,
                        config: {
                            cdn_host: window.GLOBAL_ENV.CDN_HOST,
                            api_endpoint: window.GLOBAL_ENV.API_ENDPOINT,
                            environment: "production"
                        }
                    };
                    if (e.transport === h.TransportTypes.IPC) {
                        let n = this.getCurrentUser();
                        if (null == n) {
                            e.close(h.RPCCloseCodes.CLOSE_NORMAL, "User logged out");
                            return
                        }
                        t.user = (0, d.default)(n)
                    }
                    this.dispatch(e, null, h.RPCCommands.DISPATCH, h.RPCEvents.READY, t)
                }
                handleDisconnect(e, t) {
                    this.removeSubscriptions(e), this.sockets.delete(e), this.onDisconnect(e, t)
                }
                handleRequest(e, t) {
                    new Promise(n => {
                        if (null == t.nonce || "" === t.nonce) throw new u.default(h.RPCErrors.INVALID_PAYLOAD, "Payload requires a nonce");
                        let i = t.cmd,
                            s = this.commands[i];
                        if (null == s) throw new u.default(h.RPCErrors.INVALID_COMMAND, "Invalid command: ".concat(t.cmd));
                        if (!(0, c.default)(e.authorization.scopes, s.scope)) throw new u.default(h.RPCErrors.INVALID_PERMISSIONS, "Not authenticated or invalid scope");
                        n(s)
                    }).then(e => new Promise(async (n, i) => {
                        if (null != e.validation) {
                            let s = await this.getJoi();
                            a(null != e.validation, "command.validation must not be null"), s.validate(t.args, e.validation(s), {
                                convert: !1
                            }, t => {
                                if (null != t) {
                                    i(new u.default(h.RPCErrors.INVALID_PAYLOAD, t.message));
                                    return
                                }
                                n(e)
                            })
                        } else n(e)
                    })).then(n => {
                        var i;
                        return n.handler({
                            socket: e,
                            server: this,
                            cmd: t.cmd,
                            evt: t.evt,
                            nonce: t.nonce,
                            args: null !== (i = t.args) && void 0 !== i ? i : {},
                            isSocketConnected: () => this.sockets.has(e)
                        })
                    }).then(n => this.dispatch(e, t.nonce, t.cmd, null, n)).catch(n => {
                        let {
                            code: i,
                            message: s
                        } = n;
                        return this.error(e, t.nonce, t.cmd, i, s)
                    })
                }
                setCommandHandler(e, t) {
                    this.commands[e] = t
                }
                setEventHandler(e, t) {
                    this.events[e] = t
                }
                dispatch(e) {
                    let t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : null,
                        n = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : h.RPCCommands.DISPATCH,
                        i = arguments.length > 3 && void 0 !== arguments[3] ? arguments[3] : null,
                        s = arguments.length > 4 && void 0 !== arguments[4] ? arguments[4] : null;
                    e.send({
                        cmd: n,
                        data: s,
                        evt: i,
                        nonce: t
                    })
                }
                error(e) {
                    let t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : null,
                        n = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : h.RPCCommands.DISPATCH,
                        i = arguments.length > 3 && void 0 !== arguments[3] ? arguments[3] : h.RPCErrors.UNKNOWN_ERROR,
                        s = arguments.length > 4 && void 0 !== arguments[4] ? arguments[4] : "Unknown Error";
                    l.default.track(h.AnalyticEvents.RPC_SERVER_ERROR_CAUGHT, {
                        command: n,
                        code: i,
                        message: s
                    }), this.dispatch(e, t, n, h.RPCEvents.ERROR, {
                        code: i,
                        message: s
                    })
                }
                isSubscribed(e, t) {
                    return void 0 !== this.subscriptions.find(n => n.socket.application.id === e && n.evt === t)
                }
                getSubscription(e, t, n) {
                    return this.subscriptions.find(i => i.socket === e && i.evt === t && r.isEqual(i.args, n))
                }
                addSubscription(e, t, n) {
                    let i = arguments.length > 3 && void 0 !== arguments[3] ? arguments[3] : null,
                        s = this.dispatch.bind(this, e, null, h.RPCCommands.DISPATCH, t);
                    null == this.getSubscription(e, t, n) && this.subscriptions.push({
                        update: i,
                        dispatch: s,
                        prevState: i ? i({
                            prevState: null,
                            dispatch: s
                        }) : null,
                        socket: e,
                        evt: t,
                        args: n
                    })
                }
                removeSubscription(e, t, n) {
                    r.remove(this.subscriptions, i => i.socket === e && i.evt === t && r.isEqual(i.args, n))
                }
                removeSubscriptions(e) {
                    r.remove(this.subscriptions, t => t.socket === e)
                }
                dispatchToSubscriptions(e, t, n, i) {
                    var s;
                    if (!(null != i && "" !== i && (s = i, f.includes(s) || (f.unshift(s), f.splice(50), 0)))) this.subscriptions.forEach(i => {
                        var s, a, o;
                        if (i.evt === e) {
                            if (("function" != typeof t || t(i)) && ("object" != typeof t || (a = t, o = null !== (s = i.args) && void 0 !== s ? s : {}, r.isEqual(a, r.pick(o, Object.keys(a)))))) this.dispatch(i.socket, null, h.RPCCommands.DISPATCH, i.evt, n)
                        }
                    })
                }
                updateSubscriptions() {
                    this.subscriptions.forEach(e => {
                        e.update && (e.prevState = e.update(e))
                    })
                }
                storeWait(e, t, n) {
                    let i = t();
                    if (i || 0 === n) return Promise.resolve(i);
                    let s = r.uniqueId(),
                        a = () => this.removeSubscription(e, p, {
                            uniqueId: s
                        });
                    return new Promise((i, o) => {
                        let r = setTimeout(() => {
                            a(), o(Error("timeout"))
                        }, 1e3 * n);
                        this.addSubscription(e, p, {
                            uniqueId: s
                        }, () => {
                            let e = t();
                            e && (clearTimeout(r), i(e))
                        })
                    }).then(e => (a(), e))
                }
                constructor(e) {
                    this.getCurrentUser = () => null, this.onConnect = () => {}, this.onDisconnect = () => {}, this.events = {}, this.commands = {}, this.sockets = new Set, this.subscriptions = [], this.getJoi = e
                }
            }
        },
        694352: function(e, t, n) {
            "use strict";

            function i(e) {
                let {
                    id: t,
                    username: n,
                    discriminator: i,
                    globalName: s,
                    avatar: a,
                    avatarDecoration: o,
                    bot: r,
                    flags: l,
                    premiumType: u
                } = e;
                return {
                    id: t,
                    username: n,
                    discriminator: i,
                    global_name: s,
                    avatar: a,
                    avatar_decoration_data: null != o ? {
                        asset: o.asset,
                        sku_id: o.skuId
                    } : null,
                    bot: r,
                    flags: l,
                    premium_type: null != u ? u : 0
                }
            }
            n.r(t), n.d(t, {
                default: function() {
                    return i
                }
            }), n("702976")
        },
        846678: function(e, t, n) {
            "use strict";
            n.r(t), n.d(t, {
                default: function() {
                    return s
                }
            });
            var i = n("49111");

            function s(e, t) {
                if (null == t) return !0;
                if ("string" == typeof t) return e.includes(t);
                if ("object" != typeof t) return !1;
                let n = t[i.RPC_SCOPE_CONFIG.ANY],
                    s = t[i.RPC_SCOPE_CONFIG.ALL];
                return !!(Array.isArray(n) && n.some(t => e.includes(t)) || Array.isArray(s) && s.every(t => e.includes(t))) || !1
            }
        },
        261131: function(e, t, n) {
            "use strict";
            n.r(t), n.d(t, {
                default: function() {
                    return o
                }
            });
            var i = n("269936"),
                s = n("648030");
            let a = async () => {
                let {
                    default: e
                } = await (0, i.importWithRetry)({
                    createPromise: () => n.el("990599").then(n.t.bind(n, "990599", 23)),
                    webpackId: "990599"
                });
                return e
            };
            var o = new s.default(a)
        },
        901946: function(e, t, n) {
            "use strict";
            n.r(t), n.d(t, {
                default: function() {
                    return a
                }
            });
            var i = n("862205");
            let s = (0, i.createExperiment)({
                kind: "user",
                id: "2023-08_periodic_voice_stats",
                label: "Periodic Voice Stats",
                defaultConfig: {
                    enableSendingVoiceStats: !1,
                    percentageOfCalls: 0
                },
                treatments: [{
                    id: 1,
                    label: "Enable sending periodic voice stats for 100% of calls",
                    config: {
                        enableSendingVoiceStats: !0,
                        percentageOfCalls: 100
                    }
                }, {
                    id: 2,
                    label: "Enable sending periodic voice stats for 50% of calls",
                    config: {
                        enableSendingVoiceStats: !0,
                        percentageOfCalls: 50
                    }
                }, {
                    id: 3,
                    label: "Enable sending periodic voice stats for 20% of calls",
                    config: {
                        enableSendingVoiceStats: !0,
                        percentageOfCalls: 20
                    }
                }, {
                    id: 4,
                    label: "Enable sending periodic voice stats for 10% of calls",
                    config: {
                        enableSendingVoiceStats: !0,
                        percentageOfCalls: 10
                    }
                }, {
                    id: 5,
                    label: "Enable sending periodic voice stats for 5% of calls",
                    config: {
                        enableSendingVoiceStats: !0,
                        percentageOfCalls: 5
                    }
                }]
            });
            var a = s
        },
        891760: function(e, t, n) {
            "use strict";
            n.r(t), n.d(t, {
                shouldReadWriteAudioSettings: function() {
                    return a
                }
            });
            var i = n("862205");
            let s = (0, i.createExperiment)({
                kind: "user",
                id: "2022-09_remote_audio_settings",
                label: "Remote Audio Settings",
                defaultConfig: {
                    readWriteRemoteSettings: !1
                },
                treatments: [{
                    id: 1,
                    label: "Read/write remote audio settings",
                    config: {
                        readWriteRemoteSettings: !0
                    }
                }]
            });

            function a() {
                return s.getCurrentConfig({
                    location: "da0fa6_1"
                }, {
                    autoTrackExposure: !1
                }).readWriteRemoteSettings
            }
        },
        807085: function(e, t, n) {
            "use strict";
            n.r(t), n.d(t, {
                default: function() {
                    return i
                }
            });
            var i, s = n("666038"),
                a = n("782340");
            i = class e extends s.default {
                static createFromServer(t) {
                    return new e({
                        id: t.id,
                        liveBuildId: t.live_build_id,
                        name: t.name
                    })
                }
                getName(e) {
                    return null != this.name ? this.name : this.id === e ? a.default.Messages.APPLICATION_BRANCH_NAME_MASTER : a.default.Messages.APPLICATION_BRANCH_NAME_UNKNOWN
                }
                constructor(e) {
                    super(), this.id = e.id, this.liveBuildId = e.liveBuildId, this.name = e.name
                }
            }
        },
        984273: function(e, t, n) {
            "use strict";
            n.r(t), n.d(t, {
                default: function() {
                    return i
                }
            });
            var i, s = n("666038"),
                a = n("719923"),
                o = n("49111");
            i = class e extends s.default {
                static createFromServer(t) {
                    var n, i;
                    return new e({
                        id: t.id,
                        skuId: t.sku_id,
                        applicationId: t.application_id,
                        userId: t.user_id,
                        gifterId: t.gifter_user_id,
                        type: t.type,
                        branches: null !== (n = t.branches) && void 0 !== n ? n : [],
                        startsAt: null != t.starts_at ? new Date(t.starts_at) : null,
                        endsAt: null != t.ends_at ? new Date(t.ends_at) : null,
                        subscriptionId: t.subscription_id,
                        subscriptionPlanId: null != t.subscription_plan ? t.subscription_plan.id : null,
                        parentId: null != t.parent_id ? t.parent_id : null,
                        consumed: null != t.consumed ? t.consumed : null,
                        giftCodeBatchId: null !== (i = t.gift_code_batch_id) && void 0 !== i ? i : null,
                        giftStyle: t.gift_style,
                        guildId: t.guild_id,
                        deleted: t.deleted
                    })
                }
                get isGiftable() {
                    return this.type === o.EntitlementTypes.USER_GIFT && null == this.gifterId
                }
                isValid(e, t) {
                    let n = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : null;
                    if (this.isGiftable || this.deleted) return !1;
                    if (this.type === o.EntitlementTypes.PREMIUM_SUBSCRIPTION) {
                        let n = t.get(this.skuId);
                        if (null != n && !n.premium || !a.default.canInstallPremiumApplications(e)) return !1
                    }
                    let i = new Date;
                    if (null != this.startsAt && i < this.startsAt || null != this.endsAt && i >= this.endsAt) return !1;
                    if (null != n) {
                        if (0 === this.branches.length) {
                            if (this.applicationId !== n) return !1
                        } else if (!this.branches.includes(n)) return !1
                    }
                    return !0
                }
                constructor(e) {
                    super(), this.id = e.id, this.skuId = e.skuId, this.applicationId = e.applicationId, this.userId = e.userId, this.gifterId = e.gifterId, this.type = e.type, this.branches = e.branches, this.startsAt = e.startsAt, this.endsAt = e.endsAt, this.subscriptionId = e.subscriptionId, this.subscriptionPlanId = e.subscriptionPlanId, this.parentId = e.parentId, this.consumed = e.consumed, this.giftCodeBatchId = e.giftCodeBatchId, this.giftStyle = e.giftStyle, this.guildId = e.guildId, this.deleted = e.deleted
                }
            }
        },
        370999: function(e, t, n) {
            "use strict";
            n.r(t), n.d(t, {
                default: function() {
                    return i
                }
            }), n("702976");
            var i, s = n("866227"),
                a = n.n(s),
                o = n("666038"),
                r = n("299285"),
                l = n("568734"),
                u = n("984273"),
                d = n("49111");
            i = class e extends o.default {
                static createFromServer(t) {
                    return new e({
                        id: t.application.id,
                        branchId: t.branch_id,
                        entitlements: null != t.entitlements ? t.entitlements.map(e => u.default.createFromServer(e)) : [],
                        branch: t.branch,
                        flags: t.flags,
                        createdAt: t.created_at,
                        sku: {
                            id: t.sku.id,
                            type: t.sku.type,
                            premium: t.sku.premium,
                            preorderReleaseAt: null != t.sku.preorder_release_at ? a(t.sku.preorder_release_at) : null,
                            preorderApproximateReleaseDate: null != t.sku.preorder_approximate_release_date ? t.sku.preorder_approximate_release_date : null
                        }
                    })
                }
                static createForTestMode(t) {
                    return new e({
                        id: t.id,
                        entitlements: [],
                        branchId: t.branch.id,
                        branch: t.branch,
                        flags: d.LibraryApplicationFlags.ENTITLED,
                        createdAt: t.branch.created_at,
                        sku: {
                            id: t.skuId,
                            type: d.SKUTypes.DURABLE_PRIMARY,
                            premium: !1
                        },
                        isTestMode: !0
                    })
                }
                getFlags() {
                    return this.flags
                }
                hasFlag(e) {
                    return l.hasFlag(this.flags, e)
                }
                isHidden() {
                    return this.hasFlag(d.LibraryApplicationFlags.HIDDEN)
                }
                isOverlayEnabled() {
                    return !this.hasFlag(d.LibraryApplicationFlags.OVERLAY_DISABLED)
                }
                isMasterBranch() {
                    return this.branchId === this.id
                }
                isDiscordApplication() {
                    return !0
                }
                isEntitled(e, t) {
                    return !!this.isTestMode || this.entitlements.some(n => n.isValid(e, t, this.branchId))
                }
                isPreorder() {
                    return null != this.sku.preorderReleaseAt || null != this.sku.preorderApproximateReleaseDate
                }
                getDistributor() {
                    return d.Distributors.DISCORD
                }
                getBranchName() {
                    return null != this.branch ? this.branch.name : "master"
                }
                getBranchedName(e) {
                    return this.isMasterBranch() || null == this.branch ? e.name : "".concat(e.name, " (").concat(this.branch.name, ")")
                }
                getSkuIdForAnalytics() {
                    return this.sku.id
                }
                getAnalyticsData() {
                    let e = r.default.getApplication(this.id);
                    return {
                        application_id: null != e ? e.id : null,
                        application_name: null != e ? e.name : null,
                        sku_id: this.getSkuIdForAnalytics(),
                        launcher_platform: this.getDistributor()
                    }
                }
                constructor(e) {
                    super(), this.id = e.id, this.createdAt = e.createdAt, this.flags = e.flags, this.branchId = e.branchId, this.entitlements = e.entitlements, this.branch = e.branch, this.sku = e.sku, this.isTestMode = e.isTestMode || !1
                }
            }
        },
        137406: function(e, t, n) {
            "use strict";
            n.r(t), n.d(t, {
                default: function() {
                    return i
                }
            }), n("222007"), n("702976");
            var i, s = n("866227"),
                a = n.n(s),
                o = n("666038"),
                r = n("568734"),
                l = n("653047"),
                u = n("49111");
            let d = ["500428425362931713", "451550535720501248", "471376328319303681", "466696214818193408"];
            i = class e extends o.default {
                static createFromServer(t) {
                    var n, i, s, o, r;
                    let {
                        price: u
                    } = t;
                    return new e({
                        id: t.id,
                        type: t.type,
                        applicationId: t.application_id,
                        application: null != t.application ? l.default.createFromServer(t.application) : null,
                        productLine: t.product_line,
                        name: null !== (n = t.name) && void 0 !== n ? n : "",
                        releaseDate: null != t.release_date ? a(t.release_date) : null,
                        preorderReleaseAt: null != t.preorder_release_at ? a(t.preorder_release_at) : null,
                        preorderApproximateReleaseDate: t.preorder_approximate_release_date,
                        summary: t.summary,
                        features: new Set(t.features),
                        genres: new Set(t.genres),
                        dependentSkuId: t.dependent_sku_id,
                        manifests: t.manifests,
                        availableRegions: t.available_regions,
                        accessType: t.access_type,
                        systemRequirements: t.system_requirements,
                        contentRating: t.content_rating,
                        contentRatingAgency: t.content_rating_agency,
                        legalNotice: t.legal_notice,
                        price: null != u ? {
                            amount: u.amount,
                            currency: u.currency,
                            saleAmount: u.sale_amount,
                            salePercentage: u.sale_percentage,
                            premium: u.premium
                        } : null,
                        premium: null !== (i = t.premium) && void 0 !== i && i,
                        showAgeGate: t.show_age_gate || !1,
                        restricted: t.restricted || !1,
                        slug: null !== (s = t.slug) && void 0 !== s ? s : "",
                        exclusive: t.exclusive || !1,
                        locales: null !== (o = t.locales) && void 0 !== o ? o : ["en-US"],
                        flags: t.flags,
                        externalPurchaseUrl: t.external_purchase_url,
                        deleted: null !== (r = t.deleted) && void 0 !== r && r
                    })
                }
                get supportedOperatingSystems() {
                    let e = null != this.systemRequirements ? Object.keys(this.systemRequirements) : [];
                    return e.length > 0 ? e : [u.OperatingSystems.WINDOWS]
                }
                get isOnSale() {
                    return null != this.price && null != this.price.saleAmount
                }
                isGiftable() {
                    let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : this.price;
                    return this.type === u.SKUTypes.DURABLE_PRIMARY && this.available && this.requiresPayment && null != e && u.GIFTABLE_CURRENCIES.has(e.currency) && null == this.externalPurchaseUrl
                }
                getPrice() {
                    let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : null,
                        t = !(arguments.length > 1) || void 0 === arguments[1] || arguments[1],
                        {
                            price: n
                        } = this;
                    if (null == n) return null;
                    if (null != e) {
                        var i;
                        let t = null === (i = n.premium) || void 0 === i ? void 0 : i[e];
                        if (null != t) return {
                            amount: t.amount,
                            currency: n.currency
                        }
                    }
                    return t && null != n.saleAmount ? {
                        amount: n.saleAmount,
                        currency: n.currency
                    } : {
                        amount: n.amount,
                        currency: n.currency
                    }
                }
                getDisplaySalePercentage() {
                    return null == this.price || null == this.price.salePercentage ? null : "-".concat(this.price.salePercentage, "%")
                }
                get requiresPayment() {
                    let e = this.getPrice();
                    return !this.premium && null != e && e.amount > 0
                }
                get isTheGameAwardsWinner() {
                    return d.includes(this.id)
                }
                get available() {
                    return (0, r.hasFlag)(this.flags, u.SKUFlags.AVAILABLE) || null != this.externalPurchaseUrl
                }
                isAvailableForDistribution() {
                    return this.available && null != this.getPrice() && null == this.externalPurchaseUrl && (!this.premium || (0, r.hasFlag)(this.flags, u.SKUFlags.PREMIUM_AND_DISTRIBUTION))
                }
                isAvailable() {
                    return (0, r.hasFlag)(this.flags, u.SKUFlags.AVAILABLE)
                }
                isPremiumPerk() {
                    return this.premium && ((0, r.hasFlag)(this.flags, u.SKUFlags.PREMIUM_PURCHASE) || (0, r.hasFlag)(this.flags, u.SKUFlags.PREMIUM_AND_DISTRIBUTION))
                }
                hasFeature(e) {
                    return this.features.has(e)
                }
                isPreorder() {
                    return null != this.preorderReleaseAt || null != this.preorderApproximateReleaseDate
                }
                constructor(e) {
                    super(), this.id = e.id, this.type = e.type, this.applicationId = e.applicationId, this.application = e.application, this.productLine = e.productLine, this.name = e.name, this.preorderReleaseAt = e.preorderReleaseAt, this.preorderApproximateReleaseDate = e.preorderApproximateReleaseDate, this.releaseDate = e.releaseDate, this.summary = e.summary, this.features = e.features, this.genres = e.genres, this.dependentSkuId = e.dependentSkuId, this.manifests = e.manifests, this.availableRegions = e.availableRegions, this.accessType = e.accessType, this.systemRequirements = e.systemRequirements, this.contentRating = e.contentRating, this.contentRatingAgency = e.contentRatingAgency, this.legalNotice = e.legalNotice, this.price = e.price, this.premium = e.premium, this.showAgeGate = e.showAgeGate, this.restricted = e.restricted, this.slug = e.slug, this.exclusive = e.exclusive, this.locales = e.locales, this.flags = e.flags, this.externalPurchaseUrl = e.externalPurchaseUrl || null, this.deleted = e.deleted
                }
            }
        },
        628454: function(e, t, n) {
            "use strict";
            n.r(t), n.d(t, {
                default: function() {
                    return i
                }
            });
            var i, s = n("666038");
            i = class extends s.default {
                isVoiceMuted() {
                    return this.selfMute || this.mute || this.suppress || null != this.requestToSpeakTimestamp
                }
                isVoiceDeafened() {
                    return this.selfDeaf || this.deaf
                }
                constructor(e) {
                    super(), this.userId = e.userId || "", this.channelId = e.channelId || null, this.sessionId = e.sessionId || null, this.mute = e.mute || !1, this.deaf = e.deaf || !1, this.selfMute = e.selfMute || !1, this.selfDeaf = e.selfDeaf || !1, this.selfVideo = e.selfVideo || !1, this.selfStream = e.selfStream || !1, this.suppress = e.suppress || !1, this.requestToSpeakTimestamp = e.requestToSpeakTimestamp
                }
            }
        },
        366679: function(e, t, n) {
            "use strict";
            n.r(t), n.d(t, {
                default: function() {
                    return r
                }
            });
            var i = n("446674"),
                s = n("913144");
            let a = n("353927").DEFAULT_VOICE_BITRATE;
            class o extends i.default.Store {
                get bitrate() {
                    return a
                }
            }
            o.displayName = "BitRateStore";
            var r = new o(s.default, {
                SET_CHANNEL_BITRATE: function(e) {
                    a = e.bitrate
                }
            })
        },
        533222: function(e, t, n) {
            "use strict";
            n.r(t), n.d(t, {
                default: function() {
                    return E
                }
            });
            var i = n("917351"),
                s = n.n(i),
                a = n("446674"),
                o = n("95410"),
                r = n("913144"),
                l = n("353927");
            let u = "CertifiedDeviceStore",
                d = {},
                c = {},
                h = 0;

            function p(e, t, n) {
                let i = c[e];
                return null != i ? n(i) : t
            }

            function f(e, t) {
                let n = d[e];
                null != n && n.forEach(e => delete c[e.id]), d[e] = t, t.forEach(e => c[e.id] = e)
            }
            class m extends a.default.Store {
                initialize() {
                    let e = o.default.get(u);
                    null != e && s.forEach(e, (e, t) => {
                        e.forEach(e => {
                            "audioinput" === e.type && e.hardwareMute && (e.hardwareMute = !1)
                        }), f(t, e)
                    })
                }
                isCertified(e) {
                    return null != c[e]
                }
                getCertifiedDevice(e) {
                    return c[e]
                }
                getCertifiedDeviceName(e, t) {
                    let n = this.getCertifiedDevice(e);
                    return null != n ? "".concat(n.vendor.name, " ").concat(n.model.name) : t
                }
                getCertifiedDeviceByType(e) {
                    return s.find(c, t => t.type === e)
                }
                isHardwareMute(e) {
                    return p(e, !1, e => e.type === l.DeviceTypes.AUDIO_INPUT && e.hardwareMute)
                }
                hasEchoCancellation(e) {
                    return p(e, !1, e => e.type === l.DeviceTypes.AUDIO_INPUT && e.echoCancellation)
                }
                hasNoiseSuppression(e) {
                    return p(e, !1, e => e.type === l.DeviceTypes.AUDIO_INPUT && e.noiseSuppression)
                }
                hasAutomaticGainControl(e) {
                    return p(e, !1, e => e.type === l.DeviceTypes.AUDIO_INPUT && e.automaticGainControl)
                }
                getVendor(e) {
                    return p(e, null, e => e.vendor)
                }
                getModel(e) {
                    return p(e, null, e => e.model)
                }
                getRevision() {
                    return h
                }
            }
            m.displayName = "CertifiedDeviceStore";
            var E = new m(r.default, {
                CERTIFIED_DEVICES_SET: function(e) {
                    let {
                        applicationId: t,
                        devices: n
                    } = e;
                    f(t, n), o.default.set(u, d), h++
                }
            })
        },
        86878: function(e, t, n) {
            "use strict";
            n.r(t), n.d(t, {
                default: function() {
                    return u
                }
            }), n("222007");
            var i = n("917351"),
                s = n.n(i),
                a = n("446674"),
                o = n("913144");
            let r = {};
            class l extends a.default.Store {
                isConnected(e) {
                    return null != r[e]
                }
                get connections() {
                    return s.values(r)
                }
                getApplication(e) {
                    return r[e]
                }
                getAllConnections() {
                    return r
                }
            }
            l.displayName = "ConnectedAppsStore";
            var u = new l(o.default, {
                OVERLAY_INITIALIZE: function(e) {
                    let {
                        connectedApps: t
                    } = e;
                    r = {
                        ...t
                    }
                },
                RPC_APP_CONNECTED: function(e) {
                    let {
                        application: t
                    } = e;
                    if (null == t.id) return !1;
                    let n = t.id;
                    null == r[n] && (r[n] = {
                        count: 0,
                        id: t.id,
                        name: t.name,
                        icon: t.icon,
                        coverImage: t.coverImage,
                        authenticated: !1
                    }), r[n].count++
                },
                RPC_APP_AUTHENTICATED: function(e) {
                    let {
                        application: t
                    } = e;
                    null != t.id && null != r[t.id] && (r[t.id].authenticated = !0)
                },
                RPC_APP_DISCONNECTED: function(e) {
                    let {
                        application: t
                    } = e;
                    null != t.id && null != r[t.id] && (r[t.id].count--, 0 === r[t.id].count && delete r[t.id])
                }
            })
        },
        368694: function(e, t, n) {
            "use strict";
            n.r(t), n.d(t, {
                default: function() {
                    return p
                }
            }), n("222007");
            var i = n("446674"),
                s = n("913144"),
                a = n("517001"),
                o = n("305961"),
                r = n("697218"),
                l = n("565034"),
                u = n("963903");
            let d = "production" === u.Environments.DEVELOPMENT || window.GLOBAL_ENV.RELEASE_CHANNEL === u.Environments.STAGING;

            function c() {
                d = (0, a.isStaffEnv)(r.default.getCurrentUser())
            }
            class h extends i.default.Store {
                initialize() {
                    this.waitFor(r.default, o.default), Object.defineProperties(this, {
                        isDeveloper: {
                            configurable: !1,
                            get: () => d
                        }
                    }), c(), setTimeout(() => Object.freeze(this))
                }
                getExperimentDescriptor() {
                    return d ? {
                        type: "developer",
                        name: "discord_dev_testing",
                        revision: 1,
                        override: !0,
                        bucket: l.ExperimentBuckets.TREATMENT_1
                    } : null
                }
                constructor(...e) {
                    super(...e), this.isDeveloper = !1
                }
            }
            h.displayName = "DeveloperExperimentStore";
            var p = new h(s.default, {
                CONNECTION_OPEN: c,
                OVERLAY_INITIALIZE: c,
                CURRENT_USER_UPDATE: c
            })
        },
        546463: function(e, t, n) {
            "use strict";
            let i;
            n.r(t), n.d(t, {
                default: function() {
                    return C
                }
            }), n("222007");
            var s, a = n("446674"),
                o = n("95410"),
                r = n("913144"),
                l = n("845579"),
                u = n("653047"),
                d = n("773336");
            let c = "GameStoreReportedGames",
                h = {},
                p = {},
                f = {},
                m = null !== (s = o.default.get(c)) && void 0 !== s ? s : {},
                E = "";
            let g = null;

            function S(e) {
                return {
                    id: e.id,
                    name: e.name,
                    executables: e.executables,
                    overlayWarn: e.overlayWarn,
                    overlayCompatibilityHook: e.overlayCompatibilityHook,
                    overlay: e.overlay,
                    hook: e.hook,
                    aliases: e.aliases,
                    supportsOutOfProcessOverlay: e.supportsOutOfProcessOverlay
                }
            }

            function _(e) {
                let t = e instanceof u.default ? S(e) : e;
                for (let n of (h[e.id] = t, p[e.name.toLowerCase()] = t, e.aliases)) p[n.toLowerCase()] = t;
                if ((0, d.isDesktop)())
                    for (let n of e.executables) f[n.name] = t
            }
            class v extends a.default.PersistedStore {
                initialize(e) {
                    var t;
                    null != e && (null != e.detectableGamesEtag && (E = e.detectableGamesEtag), null === (t = e.detectableGames) || void 0 === t || t.forEach(e => _(e)))
                }
                getState() {
                    return {
                        detectableGamesEtag: E,
                        detectableGames: Object.values(h)
                    }
                }
                get games() {
                    return Object.values(h)
                }
                getDetectableGame(e) {
                    return h[e]
                }
                getGameByName(e) {
                    if (null == e) return null;
                    let t = e.toLowerCase();
                    return Object.prototype.hasOwnProperty.call(p, t) ? p[t] : null
                }
                get fetching() {
                    return !0 === i
                }
                get detectableGamesEtag() {
                    return E
                }
                get lastFetched() {
                    return g
                }
                getGameByExecutable(e) {
                    return f[e]
                }
                getGameByGameData(e) {
                    var t, n;
                    let i;
                    if (null == e.exePath) return null;
                    let s = e.exePath.split("/").pop(),
                        a = e.exePath.split("/").slice(-2).join("/");
                    if (null != e.name) {
                        if (null != (i = this.getGameByName(e.name)) && null != i.executables) {
                            let e = i.executables.map(e => e.name);
                            if (e.includes(s) || e.includes(a)) return i
                        } else if (null != i) return null
                    }
                    return null !== (n = null !== (t = this.getGameByExecutable(s)) && void 0 !== t ? t : this.getGameByExecutable(a)) && void 0 !== n ? n : i
                }
                shouldReport(e) {
                    let t = null != this.getGameByName(e),
                        n = null != m[e];
                    return l.ShowCurrentGame.getSetting() && !i && !(t || n)
                }
                markGameReported(e) {
                    m[e] = !0, o.default.set(c, m)
                }
            }
            v.displayName = "GameStore", v.persistKey = "GameStore", v.migrations = [e => {
                var t, n;
                if (null == e) return {
                    detectableGamesEtag: "",
                    detectableGames: []
                };
                return {
                    detectableGamesEtag: e.detectableGamesEtag,
                    detectableGames: null !== (n = null === (t = e.detectableGames) || void 0 === t ? void 0 : t.map(e => S(new u.default(e)))) && void 0 !== n ? n : []
                }
            }];
            var C = new v(r.default, {
                OVERLAY_INITIALIZE: function(e) {
                    let {
                        detectableApplications: t
                    } = e;
                    for (let e of t) _(e)
                },
                GAMES_DATABASE_FETCH: function() {
                    i = !0
                },
                GAMES_DATABASE_FETCH_FAIL: function() {
                    i = !1
                },
                GAMES_DATABASE_UPDATE: function(e) {
                    let {
                        games: t,
                        etag: n
                    } = e;
                    for (let e of (null != n && E !== n && (E = n), t)) _(function(e) {
                        var t, n, i, s, a, o;
                        return {
                            id: e.id,
                            name: e.name,
                            executables: (null !== (t = e.executables) && void 0 !== t ? t : []).map(u.createExecutable),
                            overlay: null !== (n = e.overlay) && void 0 !== n && n,
                            overlayWarn: null !== (i = e.overlay_warn) && void 0 !== i && i,
                            overlayCompatibilityHook: null !== (s = e.overlay_compatibility_hook) && void 0 !== s && s,
                            hook: null === (a = e.hook) || void 0 === a || a,
                            aliases: null !== (o = e.aliases) && void 0 !== o ? o : [],
                            supportsOutOfProcessOverlay: u.default.supportsOutOfProcessOverlay(e.overlay_methods)
                        }
                    }(e));
                    i = void 0, g = Date.now()
                }
            })
        },
        855867: function(e, t, n) {
            "use strict";
            n.r(t), n.d(t, {
                default: function() {
                    return l
                }
            });
            var i = n("446674"),
                s = n("913144"),
                a = n("49111");
            let o = {};
            class r extends i.default.Store {
                getHookError(e) {
                    return o[e]
                }
            }
            r.displayName = "HookErrorStore";
            var l = new r(s.default, {
                MEDIA_ENGINE_SET_GO_LIVE_SOURCE: function() {
                    o = {}
                },
                MEDIA_ENGINE_SOUNDSHARE_TRANSMITTING: function() {
                    delete o[a.MediaEngineHookTypes.SOUND]
                },
                MEDIA_ENGINE_SOUNDSHARE_FAILED: function(e) {
                    let {
                        errorMessage: t,
                        errorCode: n
                    } = e;
                    o[a.MediaEngineHookTypes.SOUND] = {
                        errorMessage: t,
                        errorCode: n
                    }
                }
            })
        },
        560733: function(e, t, n) {
            "use strict";
            n.r(t), n.d(t, {
                default: function() {
                    return l
                }
            });
            var i = n("446674"),
                s = n("913144"),
                a = n("49111");
            let o = 0;
            class r extends i.default.Store {
                getId() {
                    return o
                }
            }
            r.displayName = "InstanceIdStore";
            var l = new r(s.default, {
                RPC_SERVER_READY: function(e) {
                    let {
                        port: t
                    } = e;
                    o = a.RPC_STARTING_PORT - t
                }
            })
        },
        686470: function(e, t, n) {
            "use strict";
            n.r(t), n.d(t, {
                default: function() {
                    return b
                }
            }), n("222007"), n("702976"), n("860677");
            var i = n("917351"),
                s = n.n(i),
                a = n("446674"),
                o = n("95410"),
                r = n("913144"),
                l = n("370999"),
                u = n("568734"),
                d = n("964889"),
                c = n("271938"),
                h = n("49111");
            let p = "LibraryApplicationStore";

            function f() {
                var e;
                return null !== (e = o.default.get(p)) && void 0 !== e ? e : {}
            }
            let m = !1,
                E = {},
                g = {},
                S = new Set,
                _ = {},
                v = {},
                C = !1;

            function T() {
                o.default.set(p, {
                    ...f(),
                    activeLaunchOptionIds: v
                })
            }

            function I() {
                o.default.set(p, {
                    ...f(),
                    activeLibraryApplicationBranchIds: _
                })
            }

            function A(e) {
                for (let t of e) {
                    let e = l.default.createFromServer(t),
                        n = (0, d.getComboId)(e.id, e.branchId);
                    E[n] = e
                }
            }

            function N(e) {
                let {
                    libraryApplication: t
                } = e, n = l.default.createFromServer(t), i = (0, d.getComboId)(n.id, n.branchId);
                E[i] = n, S.delete(i)
            }

            function D(e, t) {
                var n;
                let i = (0, d.getComboId)(e, t);
                return null !== (n = E[i]) && void 0 !== n ? n : g[i]
            }

            function O() {
                return {
                    ...g,
                    ...E
                }
            }
            class R extends a.default.Store {
                initialize() {
                    this.waitFor(c.default);
                    let e = o.default.get(p);
                    null != e && (null == e.activeLaunchOptionIds ? T() : v = e.activeLaunchOptionIds, null == e.activeLibraryApplicationBranchIds ? I() : _ = e.activeLibraryApplicationBranchIds)
                }
                get libraryApplications() {
                    return function(e) {
                        let t = O();
                        return Object.keys(t).forEach(n => {
                            !e(t[n]) && delete t[n]
                        }), t
                    }(e => !e.isHidden())
                }
                getAllLibraryApplications() {
                    return O()
                }
                hasLibraryApplication() {
                    return Object.keys(O()).length > 0
                }
                hasApplication(e, t) {
                    let n = arguments.length > 2 && void 0 !== arguments[2] && arguments[2],
                        i = D(e, t);
                    return !(null == i || !n && i.isHidden()) && (0, d.isUserEntitledToLibraryApplication)(i)
                }
                getLibraryApplication(e, t) {
                    let n = arguments.length > 2 && void 0 !== arguments[2] && arguments[2],
                        i = D(e, t);
                    return n && null != i ? (0, d.isUserEntitledToLibraryApplication)(i) ? i : null : i
                }
                getActiveLibraryApplication(e) {
                    let t = arguments.length > 1 && void 0 !== arguments[1] && arguments[1],
                        n = _[e];
                    if (null != n) {
                        var i;
                        let s = (0, d.getComboId)(e, n),
                            a = null !== (i = E[s]) && void 0 !== i ? i : g[s];
                        if (null != a && (0, d.isUserEntitledToLibraryApplication)(a) && (t || !a.isHidden())) return a
                    }
                    let s = O();
                    for (let n in s)
                        if (s[n].id === e) {
                            let e = s[n];
                            if ((0, d.isUserEntitledToLibraryApplication)(e) && (t || !e.isHidden())) return e
                        }
                }
                isUpdatingFlags(e, t) {
                    return S.has((0, d.getComboId)(e, t))
                }
                getActiveLaunchOptionId(e, t) {
                    return v[(0, d.getComboId)(e, t)]
                }
                get fetched() {
                    return m
                }
                get entitledBranchIds() {
                    return s(O()).values().filter(e => (0, d.isUserEntitledToLibraryApplication)(e)).map(e => e.branchId).value()
                }
                get hasRemovedLibraryApplicationThisSession() {
                    return C
                }
                whenInitialized(e) {
                    this.addConditionalChangeListener(() => {
                        if (m) return setImmediate(e), !1
                    })
                }
            }
            R.displayName = "LibraryApplicationStore";
            var b = new R(r.default, {
                LOGOUT: function() {
                    m = !1
                },
                LIBRARY_FETCH_SUCCESS: function(e) {
                    let {
                        libraryApplications: t
                    } = e;
                    E = {}, A(t), m = !0
                },
                SKU_PURCHASE_SUCCESS: function(e) {
                    let {
                        libraryApplications: t
                    } = e;
                    A(t)
                },
                LIBRARY_APPLICATION_FLAGS_UPDATE_START: function(e) {
                    let {
                        applicationId: t,
                        branchId: n,
                        flags: i
                    } = e, s = (0, d.getComboId)(t, n), a = D(t, n);
                    null != a && !a.isHidden() && u.hasFlag(i, h.LibraryApplicationFlags.HIDDEN) && (C = !0), S.add(s)
                },
                LIBRARY_APPLICATION_FLAGS_UPDATE_SUCCESS: N,
                LIBRARY_APPLICATION_UPDATE: N,
                LIBRARY_APPLICATION_ACTIVE_LAUNCH_OPTION_UPDATE: function(e) {
                    let {
                        applicationId: t,
                        branchId: n,
                        launchOptionId: i
                    } = e;
                    v[(0, d.getComboId)(t, n)] = i, T()
                },
                LIBRARY_APPLICATION_ACTIVE_BRANCH_UPDATE: function(e) {
                    let {
                        applicationId: t,
                        branchId: n
                    } = e;
                    if (_[t] === n) return !1;
                    _[t] = n, I()
                },
                LIBRARY_APPLICATIONS_TEST_MODE_ENABLED: function(e) {
                    let {
                        libraryApplications: t
                    } = e;
                    for (let e of t) {
                        let t = (0, d.getComboId)(e.id, e.branchId);
                        g[t] = e
                    }
                },
                DEVELOPER_TEST_MODE_RESET: function() {
                    g = {}
                }
            })
        },
        42887: function(e, t, n) {
            "use strict";
            let i, s, a, o;
            n.r(t), n.d(t, {
                default: function() {
                    return tE
                }
            }), n("222007"), n("808653"), n("506083"), n("424973"), n("256955");
            var r, l, u, d, c = n("627445"),
                h = n.n(c),
                p = n("917351"),
                f = n.n(p),
                m = n("570277"),
                E = n.n(m),
                g = n("446674"),
                S = n("773364"),
                _ = n("95410"),
                v = n("862337"),
                C = n("913144"),
                T = n("49671"),
                I = n("6193"),
                A = n("386045"),
                N = n("18346"),
                D = n("605250"),
                O = n("808122"),
                R = n("733589"),
                b = n("933034"),
                y = n("746800"),
                P = n("584687"),
                L = n("647114");
            n("334280");
            var k = n("705500");
            n("715440");
            var w = n("238847"),
                V = n("981699"),
                M = n("140622"),
                U = n("16001"),
                x = n("631508"),
                F = n("368765"),
                B = n("403770"),
                G = n("940146"),
                H = n("353500"),
                W = n("103979"),
                K = n("665862"),
                Y = n("122530"),
                Q = n("928609"),
                q = n("891760"),
                j = n("374363"),
                z = n("599110"),
                X = n("922932"),
                J = n("773336"),
                Z = n("286235"),
                $ = n("50885"),
                ee = n("13798"),
                et = n("271938"),
                en = n("366679"),
                ei = n("533222"),
                es = n("42203"),
                ea = n("760190"),
                eo = n("855867"),
                er = n("945956"),
                el = n("568307"),
                eu = n("123647"),
                ed = n("49111"),
                ec = n("706530"),
                eh = n("180524"),
                ep = n("397336"),
                ef = n("353927"),
                em = n("782340");
            let eE = new D.default("MediaEngineStore");
            (u = r || (r = {}))[u.DETACHED = 0] = "DETACHED", u[u.WAITING = 1] = "WAITING", u[u.ATTACHED = 2] = "ATTACHED", u[u.STARTED = 3] = "STARTED", u[u.PLAYING = 4] = "PLAYING", u[u.SILENCE = 5] = "SILENCE", (d = l || (l = {}))[d.FAILED = -1] = "FAILED", d[d.OK = 0] = "OK", d[d.ACE_INSTALL_FAILED = 4] = "ACE_INSTALL_FAILED", d[d.ACE_NOT_AUTHORIZED = 5] = "ACE_NOT_AUTHORIZED";
            let eg = "MediaEngineStore",
                eS = {
                    left: 1,
                    right: 1
                };

            function e_() {
                let e = {
                    mode: ed.InputModes.VOICE_ACTIVITY,
                    modeOptions: {
                        threshold: -60,
                        autoThreshold: J.isPlatformEmbedded || __OVERLAY__,
                        vadUseKrisp: !0,
                        vadLeading: 5,
                        vadTrailing: 25,
                        delay: 20,
                        shortcut: []
                    },
                    vadUseKrispSettingVersion: 0,
                    ncUseKrispSettingVersion: 0,
                    ncUseKrispjsSettingVersion: 0,
                    av1EnabledSettingVersion: 0,
                    mute: !1,
                    deaf: !1,
                    echoCancellation: !0,
                    noiseSuppression: !1,
                    automaticGainControl: !0,
                    noiseCancellation: !0,
                    experimentalEncoders: !1,
                    hardwareH264: !0,
                    silenceWarning: !0,
                    attenuation: 0,
                    attenuateWhileSpeakingSelf: !1,
                    attenuateWhileSpeakingOthers: !0,
                    localMutes: {},
                    disabledLocalVideos: {},
                    videoToggleStateMap: {},
                    localVolumes: {},
                    localPans: {},
                    inputVolume: ef.DEFAULT_VOLUME,
                    outputVolume: ef.DEFAULT_VOLUME,
                    inputDeviceId: ef.DEFAULT_DEVICE_ID,
                    outputDeviceId: ef.DEFAULT_DEVICE_ID,
                    videoDeviceId: ef.DEFAULT_DEVICE_ID,
                    qos: !1,
                    qosMigrated: !1,
                    videoHook: ev.supports(ef.Features.VIDEO_HOOK),
                    experimentalSoundshare2: null,
                    openH264: !0,
                    av1Enabled: !0,
                    h265Enabled: !0,
                    vadThrehsoldMigrated: !1,
                    aecDumpEnabled: !1
                };
                return e
            }
            let ev = (0, S.initializeMediaEngine)((0, S.determineMediaEngine)()),
                eC = {},
                eT = new Set([ef.MediaEngineContextTypes.DEFAULT]),
                eI = ev.supports(ef.Features.AUTO_ENABLE),
                eA = !1,
                eN = ef.MediaEngineContextTypes.STREAM,
                eD = {
                    [ef.DEFAULT_DEVICE_ID]: tn(em.default.Messages.NO_INPUT_DEVICES)
                },
                eO = {
                    [ef.DEFAULT_DEVICE_ID]: tn(em.default.Messages.NO_OUTPUT_DEVICES)
                },
                eR = {
                    [ef.DEFAULT_DEVICE_ID]: tn(em.default.Messages.NO_VIDEO_DEVICES)
                },
                eb = !1,
                ey = !1,
                eP = !1,
                eL = !1,
                ek = !1,
                ew = ef.DISABLED_DEVICE_ID,
                eV = !1,
                eM = !1,
                eU = !1,
                ex = null,
                eF = !1,
                eB = !1,
                eG = !1,
                eH = !1,
                eW = !1,
                eK = null,
                eY = !1,
                eQ = ed.SoundshareEnableState.NOT_ENABLED,
                eq = !1,
                ej = !1;
            Q.default.hasPermission(eh.NativePermissionTypes.AUDIO, {
                showAuthorizationError: !1
            }), Q.default.hasPermission(eh.NativePermissionTypes.CAMERA, {
                showAuthorizationError: !1
            });
            let ez = new Set,
                eX = !1,
                eJ = !1,
                eZ = {},
                e$ = {};

            function e0() {
                let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : ef.MediaEngineContextTypes.DEFAULT,
                    t = eC[e];
                return null == t && (t = e_(), eC[e] = t), t
            }

            function e1(e) {
                let t = e0(e.context);
                e.setInputMode(t.mode, {
                    vadThreshold: t.modeOptions.threshold,
                    vadAutoThreshold: t.modeOptions.autoThreshold,
                    vadUseKrisp: t.modeOptions.vadUseKrisp && function() {
                        return eW || !1
                    }(),
                    vadLeading: t.modeOptions.vadLeading,
                    vadTrailing: t.modeOptions.vadTrailing,
                    pttReleaseDelay: t.modeOptions.delay
                })
            }

            function e2(e) {
                let t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : ef.DEFAULT_VOLUME;
                return f.clamp(e, 0, t)
            }

            function e3(e) {
                let t = e0(e.context),
                    n = !eI || t.mute || t.deaf;
                e.context === ef.MediaEngineContextTypes.DEFAULT && (n = n || eb || ey || eP || !Q.default.didHavePermission(eh.NativePermissionTypes.AUDIO)), e.setSelfMute(n), e.setSelfDeaf(t.deaf)
            }

            function e6() {
                var e, t, n;
                let s = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : ek,
                    o = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : a,
                    r = a;
                if ((null == r ? void 0 : r.desktopSource) != null && r.desktopSource.id !== (null == o ? void 0 : null === (e = o.desktopSource) || void 0 === e ? void 0 : e.id) && (null != r.desktopSource.soundshareId && (0, J.isWindows)() && I.cancelAttachToProcess(r.desktopSource.soundshareId), ev.setGoLiveSource(null, eN)), (null == r ? void 0 : r.cameraSource) != null && (r.cameraSource.videoDeviceGuid !== (null == o ? void 0 : null === (t = o.cameraSource) || void 0 === t ? void 0 : t.videoDeviceGuid) || r.cameraSource.audioDeviceGuid !== (null == o ? void 0 : null === (n = o.cameraSource) || void 0 === n ? void 0 : n.audioDeviceGuid)) && ev.setGoLiveSource(null, eN), (ek || s) && (ew = (ek = s) ? ts(eR, e0().videoDeviceId) : ef.DISABLED_DEVICE_ID, ev.setVideoInputDevice(ew)), a = o, null != o) {
                    let e = {
                        resolution: o.quality.resolution,
                        frameRate: o.quality.frameRate
                    };
                    if (null != o.desktopSource) {
                        let {
                            useQuartzCapturer: t
                        } = x.default.getCurrentConfig({
                            location: "f627ab_1"
                        }, {
                            autoTrackExposure: !1
                        }), {
                            hdrCaptureMode: n
                        } = V.default.getCurrentConfig({
                            location: "f627ab_2"
                        }, {
                            autoTrackExposure: !1
                        }), s = !1;
                        e7() && (s = !o.desktopSource.id.startsWith("screen") || L.default.getCurrentConfig({
                            location: "36723fd_wgc"
                        }, {
                            autoTrackExposure: !0
                        }).graphicsCaptureEnabled);
                        let a = e0().videoHook,
                            r = ev.supports(ef.Features.CAPTURE_TIMEOUT_EXPERIMENTS),
                            {
                                videoHookStaleFrameTimeoutMs: l
                            } = G.default.getConfig(r && a, "e225cfdf5_vh1", !0),
                            {
                                graphicsCaptureStaleFrameTimeoutMs: u
                            } = K.default.getConfig(r && e7(), "e225cfdf5_wgc2", !0);
                        ev.setGoLiveSource({
                            desktopDescription: {
                                id: o.desktopSource.id,
                                soundshareId: o.desktopSource.soundshareId,
                                useVideoHook: a,
                                useGraphicsCapture: s,
                                useLoopback: i.getExperimentalSoundshare(),
                                useQuartzCapturer: t,
                                allowScreenCaptureKit: e9(!0),
                                videoHookStaleFrameTimeoutMs: l,
                                graphicsCaptureStaleFrameTimeoutMs: u,
                                hdrCaptureMode: n
                            },
                            quality: e
                        }, eN)
                    }
                    null != o.cameraSource && ev.setGoLiveSource({
                        cameraDescription: {
                            videoDeviceGuid: o.cameraSource.videoDeviceGuid,
                            audioDeviceGuid: o.cameraSource.audioDeviceGuid
                        },
                        quality: e
                    }, eN)
                }
            }

            function e4(e, t, n, i) {
                var s;
                let a = null !== (s = null == e ? void 0 : e.soundshareSession) && void 0 !== s ? s : "";
                null == e$[a] && (e$[a] = new Set);
                let o = null != t && !e$[a].has(t);
                o && e$[a].add(t), (null == t || o) && z.default.track(ed.AnalyticEvents.SOUNDSHARE_FAILED, {
                    soundshare_failure_code: t,
                    soundshare_failure_reason: n,
                    soundshare_failure_will_retry: i,
                    ...(0, b.default)(e)
                })
            }

            function e5(e) {
                let t = e0(),
                    n = t.inputDeviceId;
                if (e.setEchoCancellation(ei.default.hasEchoCancellation(n) || t.echoCancellation), e.setNoiseSuppression(ei.default.hasNoiseSuppression(n) || t.noiseSuppression), e.setAutomaticGainControl(ei.default.hasAutomaticGainControl(n) || t.automaticGainControl), e.setNoiseCancellation(t.noiseCancellation), (0, J.isWeb)()) {
                    let n = t.noiseCancellation ? -150 : -100;
                    e.setSilenceThreshold(n)
                }
            }

            function e7() {
                return (0, J.isWindows)() && E.satisfies(null === T.default || void 0 === T.default ? void 0 : T.default.os.release, ec.WINDOWS_GRAPHICS_CAPTURE_VERSION)
            }

            function e9(e) {
                return !!((0, J.isMac)() && ev.supports(ef.Features.SCREEN_CAPTURE_KIT) && E.satisfies(null === T.default || void 0 === T.default ? void 0 : T.default.os.release, ec.DARWIN_SCKIT_VERSION)) && F.default.getCurrentConfig({
                    location: "screenCaptureKitEnabled"
                }, {
                    autoTrackExposure: e
                }).allowScreenCaptureKit
            }
            let e8 = new class {
                start() {
                    !this.started && (this.started = !0, ev.on(S.MediaEngineEvent.Silence, this.handleSilence))
                }
                stop() {
                    this.started && (this.started = !1, null != this.stateChangeTimeout && (clearTimeout(this.stateChangeTimeout), this.stateChangeTimeout = null), ev.removeListener(S.MediaEngineEvent.Silence, this.handleSilence), C.default.dispatch({
                        type: "AUDIO_INPUT_DETECTED",
                        inputDetected: null
                    }))
                }
                update() {
                    let e = e0();
                    !eF && er.default.getState() === ed.RTCConnectionStates.RTC_CONNECTED && e.mode === ed.InputModes.VOICE_ACTIVITY && e.silenceWarning ? this.start() : this.stop()
                }
                reset() {
                    this.stop(), this.update()
                }
                constructor() {
                    this.noVoiceTimeout = 5e3, this.voiceTimeout = 1500, this.started = !1, this.handleSilence = e => {
                        let t = !e;
                        null != this.stateChangeTimeout && clearTimeout(this.stateChangeTimeout), this.stateChangeTimeout = setTimeout(() => {
                            this.stateChangeTimeout = null, this.started && (C.default.dispatch({
                                type: "AUDIO_INPUT_DETECTED",
                                inputDetected: t
                            }), e && (eB = !0))
                        }, t ? this.voiceTimeout : this.noVoiceTimeout)
                    }
                }
            };

            function te(e) {
                let t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : ef.MediaEngineContextTypes.DEFAULT,
                    n = !(arguments.length > 2) || void 0 === arguments[2] || arguments[2],
                    i = e0(t);
                return Object.assign(i, e), !__OVERLAY__ && n && _.default.set(eg, eC), i
            }

            function tt() {
                !eI && ev.enable().then(() => C.default.dispatch({
                    type: "MEDIA_ENGINE_SET_AUDIO_ENABLED",
                    enabled: !0,
                    unmute: !1
                }))
            }

            function tn(e) {
                return {
                    id: ef.DEFAULT_DEVICE_ID,
                    index: 0,
                    name: e,
                    disabled: !0
                }
            }

            function ti(e, t) {
                if (0 === e.length) {
                    let e = tn(t);
                    return {
                        [e.id]: e
                    }
                }
                return f(e).map(e => ({
                    id: e.id,
                    index: e.index,
                    name: e.name,
                    disabled: !1
                })).keyBy("id").value()
            }

            function ts(e, t) {
                var n;
                let i = null !== (n = e[t]) && void 0 !== n ? n : f(e).values().first();
                return null != i ? i.id : t
            }

            function ta() {
                var e, t;
                let n = arguments.length > 0 && void 0 !== arguments[0] && arguments[0],
                    i = null !== (e = j.default.settings.audioContextSettings) && void 0 !== e ? e : {
                        user: {},
                        stream: {}
                    };
                for (let e of Object.keys(i)) {
                    let s = e === ep.ProtoAudioSettingsContextTypes.USER ? ef.MediaEngineContextTypes.DEFAULT : ef.MediaEngineContextTypes.STREAM,
                        a = s === ef.MediaEngineContextTypes.STREAM ? ef.DEFAULT_STREAM_VOLUME : ef.DEFAULT_VOLUME,
                        o = null !== (t = i[e]) && void 0 !== t ? t : {},
                        {
                            localMutes: r,
                            localVolumes: l
                        } = e0(s);
                    for (let [e, t] of Object.entries(o)) t.muted ? r[e] = !0 : delete r[e], t.volume !== a ? l[e] = t.volume : delete l[e], ev.eachConnection(n => {
                        n.setLocalVolume(e, t.volume), n.setLocalMute(e, t.muted)
                    }, s);
                    if (n) {
                        let e = new Set([...Object.keys(r), ...Object.keys(l)]);
                        for (let t of e) null == o[t] && (delete r[t], delete l[t], ev.eachConnection(e => {
                            e.setLocalVolume(t, a), e.setLocalMute(t, !1)
                        }, s))
                    }
                    te({
                        localMutes: r,
                        localVolumes: l
                    }, s)
                }
            }

            function to(e) {
                if (null == i) return eE.info("Error: trying to get soundshare id before MediaEngineStore is instantiated."), {
                    soundshareId: null,
                    soundshareSession: ""
                };
                {
                    let t = i.getExperimentalSoundshare() ? e : X.default.getAudioPid(e),
                        n = "";
                    return null != t && (n = X.default.generateSessionFromPid(t)), {
                        soundshareId: t,
                        soundshareSession: n
                    }
                }
            }

            function tr(e, t) {
                (0, J.isWindows)() && I.attachToProcess(e, {
                    soundshare_session: t
                }).then(t => {
                    null != t && !el.default.shouldContinueWithoutElevatedProcessForPID(e) && C.default.wait(() => {
                        C.default.dispatch({
                            type: "MEDIA_ENGINE_SOUNDSHARE_FAILED",
                            errorMessage: t
                        })
                    })
                })
            }

            function tl(e) {
                let t = e0();
                z.default.track(ed.AnalyticEvents.VOICE_PROCESSING, {
                    echo_cancellation: t.echoCancellation,
                    noise_cancellation: t.noiseCancellation,
                    noise_suppression: t.noiseSuppression,
                    automatic_gain_control: t.automaticGainControl,
                    location: e
                })
            }

            function tu() {
                let e = e0(),
                    t = e.inputDeviceId,
                    n = ei.default.hasEchoCancellation(t) || e.echoCancellation,
                    i = ei.default.hasNoiseSuppression(t) || e.noiseSuppression,
                    s = ei.default.hasAutomaticGainControl(t) || e.automaticGainControl,
                    a = e.noiseCancellation;
                ev.setLoopback(eJ, {
                    echoCancellation: n,
                    noiseSuppression: i,
                    automaticGainControl: s,
                    noiseCancellation: a
                })
            }

            function td() {
                return eW || !1
            }
            async function tc() {
                try {
                    await $.default.ensureModule("discord_krisp"), $.default.requireModule("discord_krisp"), eW = !0, i.emitChange()
                } catch (t) {
                    eE.warn("Failed to load Krisp module: ".concat(t.message)), Z.default.captureException(t);
                    let e = ef.NoiseCancellerError.INITIALIZED;
                    if (t.message.includes(": ")) {
                        let n = parseInt(t.message.substring(t.message.indexOf(": ") + 1));
                        e = isNaN(n) || 0 === n ? ef.NoiseCancellerError.INITIALIZED : n
                    }
                    z.default.track(ed.AnalyticEvents.VOICE_PROCESSING, {
                        noise_canceller_error: e
                    }), te({
                        noiseCancellation: !1
                    })
                } finally {
                    eH = !1
                }
            }

            function th(e) {
                let {
                    section: t
                } = e;
                return t === ed.UserSettingsSections.VOICE && tt(), !1
            }

            function tp(e) {
                eQ = 0 === e ? ed.SoundshareEnableState.ENABLED : 5 === e ? ed.SoundshareEnableState.ENABLING : -1 === e || 4 === e ? ed.SoundshareEnableState.FAILED_TO_ENABLE : ed.SoundshareEnableState.NOT_ENABLED
            }
            async function tf() {
                if (eQ === ed.SoundshareEnableState.ENABLING) return;
                eQ = ed.SoundshareEnableState.ENABLING;
                let e = {};
                try {
                    let t = await ev.enableSoundshare();
                    tp(t.code), e = {
                        status_code: t.code,
                        message: t.message
                    }
                } catch (t) {
                    eE.warn("Failed to enable macOS soundshare: ".concat(t)), tp(-1), e = {
                        status_code: -1,
                        message: "".concat(t)
                    }
                } finally {
                    i.emitChange(), z.default.track(ed.AnalyticEvents.SOUNDSHARE_ENABLE, e)
                }
            }
            class tm extends g.default.Store {
                initialize() {
                    ev.on(S.MediaEngineEvent.Connection, e => {
                        let {
                            maxSyncDelayOverride: t
                        } = U.default.getCurrentConfig({
                            location: "f627ab_3"
                        }, {
                            autoTrackExposure: !1
                        });
                        t > 0 && ev.setMaxSyncDelayOverride(t), e1(e), e3(e), e5(e);
                        let n = e0();
                        e.setAttenuation(n.attenuation, n.attenuateWhileSpeakingSelf, n.attenuateWhileSpeakingOthers), e.setQoS(n.qos), e.setExperimentalEncoders(n.experimentalEncoders), e.setHardwareH264(n.hardwareH264);
                        let {
                            useExperimentalRateControl: s
                        } = H.default.getCurrentConfig({
                            location: "f627ab_4"
                        }, {
                            autoTrackExposure: !1
                        });
                        s && e.setExperimentFlag(ef.ExperimentFlags.VIDEOTOOLBOX_RATE_CONTROL, !0);
                        {
                            let {
                                signalH265SupportMacOS: t
                            } = k.default.getCurrentConfig({
                                location: "f627ab_8"
                            }, {
                                autoTrackExposure: !0
                            });
                            t && e.setExperimentFlag(ef.ExperimentFlags.SIGNAL_H265_SUPPORT, !0);
                            let {
                                signalH265SupportNvenc: n
                            } = w.default.getCurrentConfig({
                                location: "f627ab_9"
                            }, {
                                autoTrackExposure: !0
                            });
                            n && e.setExperimentFlag(ef.ExperimentFlags.SIGNAL_H265_SUPPORT, !0)
                        }
                        let {
                            signalAV1Support: o
                        } = y.default.getCurrentConfig({
                            location: "f627ab_10"
                        }, {
                            autoTrackExposure: !0
                        });
                        o && e.setExperimentFlag(ef.ExperimentFlags.SIGNAL_AV1_SUPPORT, !0);
                        let {
                            allowSettingFullbandAndroid: r
                        } = M.default.getCurrentConfig({
                            location: "f627ab_14"
                        }, {
                            autoTrackExposure: !0
                        });
                        if (r && ev.setHasFullbandPerformance((0, O.hasPerformanceForKrispFullband)()), (0, N.default)(i) && A.default.getSettings().clipsEnabled) {
                            e.setExperimentFlag(ef.ExperimentFlags.STREAMER_CLIP, !0);
                            let {
                                enableViewerClipping: t
                            } = W.default.getCurrentConfig({
                                location: "f627ab_15"
                            }, {
                                autoTrackExposure: !1
                            });
                            t && e.setExperimentFlag(ef.ExperimentFlags.VIEWER_CLIP, !0)
                        }
                        for (let t of (n = e0(e.context), e.setPostponeDecodeLevel(100), Object.keys(n.localMutes))) t !== et.default.getId() && e.setLocalMute(t, n.localMutes[t]);
                        for (let t of Object.keys(n.localVolumes)) t !== et.default.getId() && e.setLocalVolume(t, n.localVolumes[t]);
                        for (let t of Object.keys(n.localPans)) {
                            let i = n.localPans[t];
                            e.setLocalPan(t, i.left, i.right)
                        }
                        for (let t of Object.keys(n.disabledLocalVideos)) e.setLocalVideoDisabled(t, n.disabledLocalVideos[t]);
                        e.on(S.BaseConnectionEvent.Speaking, (t, n) => {
                            C.default.dispatch({
                                type: "SPEAKING",
                                context: e.context,
                                userId: t,
                                speakingFlags: n
                            })
                        }), e.context === ef.MediaEngineContextTypes.DEFAULT && (eV = !1, e.on(S.BaseConnectionEvent.SpeakingWhileMuted, () => {
                            eV = !0, i.emitChange()
                        })), e.on(S.BaseConnectionEvent.DesktopSourceEnd, () => {
                            C.default.dispatch({
                                type: "MEDIA_ENGINE_SET_GO_LIVE_SOURCE",
                                settings: {
                                    context: e.context
                                }
                            })
                        }), e.on(S.BaseConnectionEvent.SoundshareAttached, () => {
                            (null == a ? void 0 : a.desktopSource) != null && z.default.track(ed.AnalyticEvents.SOUNDSHARE_ATTACHED, (0, b.default)(null == a ? void 0 : a.desktopSource))
                        }), e.on(S.BaseConnectionEvent.SoundshareFailed, e => {
                            let {
                                failureCode: t,
                                failureReason: n,
                                willRetry: i
                            } = e;
                            e4(null == a ? void 0 : a.desktopSource, t, n, i)
                        }), e.on(S.BaseConnectionEvent.SoundshareSpeaking, () => {
                            (null == a ? void 0 : a.desktopSource) != null && (z.default.track(ed.AnalyticEvents.SOUNDSHARE_TRANSMITTING, (0, b.default)(null == a ? void 0 : a.desktopSource)), null != eo.default.getHookError(ed.MediaEngineHookTypes.SOUND) && C.default.wait(() => C.default.dispatch({
                                type: "MEDIA_ENGINE_SOUNDSHARE_TRANSMITTING"
                            })))
                        });
                        let l = new v.Timeout;
                        e.on(S.BaseConnectionEvent.SoundshareTrace, e => {
                            switch (e.type) {
                                case "soundshare_attach_requested":
                                    l.start(5e3, () => {
                                        C.default.dispatch({
                                            type: "MEDIA_ENGINE_SOUNDSHARE_FAILED",
                                            errorMessage: "Sound Hook Failed"
                                        })
                                    });
                                    break;
                                case "soundshare_recv_failed":
                                    let t = e.reason,
                                        n = e.code,
                                        i = e.retry;
                                    (null == a ? void 0 : a.desktopSource) != null && (e4(null == a ? void 0 : a.desktopSource, n, t, i), !i && (l.stop(), C.default.wait(() => C.default.dispatch({
                                        type: "MEDIA_ENGINE_SOUNDSHARE_FAILED",
                                        errorMessage: t,
                                        errorCode: n
                                    }))));
                                    break;
                                case "soundshare_state_transition":
                                    4 === e.newState && (l.stop(), C.default.wait(() => C.default.dispatch({
                                        type: "MEDIA_ENGINE_SOUNDSHARE_TRANSMITTING"
                                    })))
                            }
                        }), e.on(S.BaseConnectionEvent.InteractionRequired, e => {
                            C.default.dispatch({
                                type: "MEDIA_ENGINE_INTERACTION_REQUIRED",
                                required: e
                            })
                        }), e.on(S.BaseConnectionEvent.VideoHookInitialize, (e, t, n, i, s, o) => {
                            (null == a ? void 0 : a.desktopSource) != null && z.default.track(ed.AnalyticEvents.VIDEOHOOK_INITIALIZED, {
                                backend: e,
                                format: t,
                                framebuffer_format: n,
                                sample_count: i,
                                success: s,
                                reinitialization: o,
                                ...(0, b.default)(null == a ? void 0 : a.desktopSource)
                            })
                        }), e.on(S.BaseConnectionEvent.NoiseCancellationError, e => {
                            eE.warn("noisecancellererror event: ".concat(e)), eY = !0, z.default.track(ed.AnalyticEvents.VOICE_PROCESSING, {
                                noise_canceller_error: e
                            }), C.default.dispatch({
                                type: "AUDIO_SET_NOISE_SUPPRESSION",
                                enabled: !0
                            }), C.default.dispatch({
                                type: "AUDIO_SET_NOISE_CANCELLATION",
                                enabled: !1
                            }), C.default.dispatch({
                                type: "MEDIA_ENGINE_NOISE_CANCELLATION_ERROR",
                                code: e
                            })
                        }), e.on(S.BaseConnectionEvent.VoiceActivityDetectorError, e => {
                            eE.warn("voiceactivitydetectorerror event: ".concat(e)), z.default.track(ed.AnalyticEvents.VOICE_PROCESSING, {
                                noise_canceller_error: e
                            }), C.default.dispatch({
                                type: "AUDIO_SET_MODE",
                                context: ef.MediaEngineContextTypes.DEFAULT,
                                mode: ed.InputModes.VOICE_ACTIVITY,
                                options: {
                                    ...e0(ef.MediaEngineContextTypes.DEFAULT).modeOptions,
                                    vadUseKrisp: !1
                                }
                            }), C.default.dispatch({
                                type: "MEDIA_ENGINE_VOICE_ACTIVITY_DETECTION_ERROR",
                                code: e
                            })
                        }), e.on(S.BaseConnectionEvent.VideoState, t => {
                            C.default.dispatch({
                                type: "MEDIA_ENGINE_VIDEO_STATE_CHANGED",
                                videoState: t,
                                context: e.context
                            })
                        }), e.on(S.BaseConnectionEvent.Destroy, () => {
                            l.stop()
                        }), e.setBitRate(en.default.bitrate), e.applyVideoQualityMode(eu.default.mode)
                    }), ev.on(S.MediaEngineEvent.DeviceChange, (e, t, n) => {
                        C.default.dispatch({
                            type: "MEDIA_ENGINE_DEVICES",
                            inputDevices: e,
                            outputDevices: t,
                            videoDevices: n
                        })
                    }), ev.on(S.MediaEngineEvent.VolumeChange, (e, t) => {
                        C.default.dispatch({
                            type: "AUDIO_VOLUME_CHANGE",
                            inputVolume: e,
                            outputVolume: t
                        })
                    }), ev.on(S.MediaEngineEvent.DesktopSourceEnd, () => {
                        C.default.dispatch({
                            type: "MEDIA_ENGINE_SET_GO_LIVE_SOURCE",
                            settings: null
                        })
                    }), ev.on(S.MediaEngineEvent.AudioPermission, e => {
                        ej = !0, C.default.dispatch({
                            type: "MEDIA_ENGINE_PERMISSION",
                            kind: "audio",
                            granted: e
                        })
                    }), ev.on(S.MediaEngineEvent.VideoPermission, e => {
                        C.default.dispatch({
                            type: "MEDIA_ENGINE_PERMISSION",
                            kind: "video",
                            granted: e
                        })
                    }), ev.on(S.MediaEngineEvent.WatchdogTimeout, async () => {
                        let e;
                        try {
                            await X.default.submitLiveCrashReport({
                                message: {
                                    message: "Voice Watchdog Timeout"
                                }
                            })
                        } catch (t) {
                            "number" == typeof t.status && (e = t.status)
                        }
                        eE.warn("Watchdog timeout, report submission status: ".concat(null != e ? e : 200)), z.default.track(ed.AnalyticEvents.VOICE_WATCHDOG_TIMEOUT, {
                            minidump_submission_error: e
                        })
                    }), ev.on(S.MediaEngineEvent.VideoInputInitialized, e => {
                        z.default.track(ed.AnalyticEvents.VIDEO_INPUT_INITIALIZED, {
                            device_name: e.description.name,
                            time_to_first_frame_ms: e.initializationTimerExpired ? null : Math.round(1e3 * e.timeToFirstFrame),
                            timed_out: e.initializationTimerExpired,
                            activity: e.entropy
                        })
                    }), ev.on(S.MediaEngineEvent.ClipsRecordingRestartNeeded, () => {
                        C.default.dispatch({
                            type: "CLIPS_RESTART"
                        })
                    }), ev.on(S.MediaEngineEvent.ClipsInitFailure, (e, t) => {
                        C.default.wait(() => {
                            C.default.dispatch({
                                type: "CLIPS_INIT_FAILURE",
                                errMsg: e,
                                applicationName: t
                            })
                        })
                    }), ev.on(S.MediaEngineEvent.ClipsRecordingEnded, (e, t) => {
                        var n, i;
                        (null == o ? void 0 : null === (n = o.desktopSource) || void 0 === n ? void 0 : n.id) === e && (null != t && (null == a ? void 0 : null === (i = a.desktopSource) || void 0 === i ? void 0 : i.soundshareId) !== t && I.cancelAttachToProcess(t), o = null)
                    }), e8.reset(), ! function() {
                        var e;
                        let t = _.default.get("audio");
                        null != t && (_.default.set(eg, {
                                [ef.MediaEngineContextTypes.DEFAULT]: t
                            }), _.default.remove("audio")), eC = null !== (e = _.default.get(eg)) && void 0 !== e ? e : {}, f.each(eC, e => {
                                if (f.defaultsDeep(e, e_()), null != e.modeOptions && "string" == typeof e.modeOptions.shortcut && (e.modeOptions.shortcut = (0, ee.toCombo)(e.modeOptions.shortcut)), null != e.modeOptions && 4 !== e.vadUseKrispSettingVersion && (e.vadUseKrispSettingVersion = 4, e.modeOptions.vadUseKrisp = !0), !e.qosMigrated && (e.qosMigrated = !0, e.qos = !1), !e.vadThrehsoldMigrated) {
                                    var t;
                                    e.vadThrehsoldMigrated = !0, (null === (t = e.modeOptions) || void 0 === t ? void 0 : t.threshold) === -40 && (e.modeOptions.threshold = -60)
                                }(0, J.isWeb)() ? 1 !== e.ncUseKrispjsSettingVersion && (e.ncUseKrispjsSettingVersion = 1, e.noiseSuppression = !1, e.noiseCancellation = !0): 1 !== e.ncUseKrispSettingVersion && (e.ncUseKrispSettingVersion = 1, e.noiseSuppression = !1, e.noiseCancellation = !0), 1 !== e.av1EnabledSettingVersion && (e.av1EnabledSettingVersion = 1, e.av1Enabled = !0)
                            }),
                            function() {
                                let e = e0();
                                ev.setAudioInputDevice(e.inputDeviceId), ev.setAudioOutputDevice(e.outputDeviceId), e6(), ev.setInputVolume(e.inputVolume), ev.setOutputVolume(e.outputVolume), ev.setH264Enabled(e.openH264), ev.setAv1Enabled(e.av1Enabled), ev.setAecDump(e.aecDumpEnabled)
                            }()
                    }(), !(0, J.isDesktop)() || __OVERLAY__ || eH || eW ? (0, J.isWeb)() && ev.supports(ef.Features.NOISE_CANCELLATION) ? (eW = !0, i.emitChange()) : (0, J.isWeb)() && te({
                        noiseCancellation: !1
                    }) : (eH = !0, tc()), (0, J.isMac)() && ev.supports(ef.Features.SOUNDSHARE) ? ev.getSoundshareStatus().then(e => {
                        tp(e)
                    }).catch(e => {
                        eE.warn("Failed to check if soundshare is enabled: ".concat(e))
                    }) : eQ = ed.SoundshareEnableState.ENABLED, eZ = {
                        [ef.Features.VIDEO]: ev.supports(ef.Features.VIDEO),
                        [ef.Features.DESKTOP_CAPTURE]: ev.supports(ef.Features.DESKTOP_CAPTURE),
                        [ef.Features.HYBRID_VIDEO]: ev.supports(ef.Features.HYBRID_VIDEO)
                    }, this.waitFor(et.default, ei.default, es.default, eo.default, er.default, el.default, Q.default.storage, j.default, ea.default)
                }
                supports(e) {
                    return ev.supports(e)
                }
                supportsInApp(e) {
                    return eZ[e] || ev.supports(e)
                }
                isSupported() {
                    return ev.supported()
                }
                isExperimentalEncodersSupported() {
                    return ev.supports(ef.Features.EXPERIMENTAL_ENCODERS)
                }
                isNoiseSuppressionSupported() {
                    return ev.supports(ef.Features.NOISE_SUPPRESSION)
                }
                isNoiseCancellationSupported() {
                    return eW || !1
                }
                isNoiseCancellationError() {
                    return eY
                }
                isAutomaticGainControlSupported() {
                    return ev.supports(ef.Features.AUTOMATIC_GAIN_CONTROL)
                }
                isAdvancedVoiceActivitySupported() {
                    return eW || !1
                }
                isAecDumpSupported() {
                    return ev.supports(ef.Features.AEC_DUMP)
                }
                isSimulcastSupported() {
                    return ev.supports(ef.Features.VIDEO) && ev.supports(ef.Features.SIMULCAST)
                }
                getAecDump() {
                    return e0().aecDumpEnabled
                }
                getMediaEngine() {
                    return ev
                }
                getVideoComponent() {
                    return ev.supports(ef.Features.DIRECT_VIDEO) && ev.setUseDirectVideo(!0), ev.Video
                }
                getCameraComponent() {
                    return ev.supports(ef.Features.DIRECT_VIDEO) && ev.setUseDirectVideo(!0), ev.Camera
                }
                isEnabled() {
                    return eI
                }
                isMute() {
                    return this.isSelfMute() || eb
                }
                isDeaf() {
                    return this.isSelfDeaf() || eL
                }
                hasContext(e) {
                    return null != eC[e]
                }
                isSelfMutedTemporarily() {
                    let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : ef.MediaEngineContextTypes.DEFAULT;
                    return e === ef.MediaEngineContextTypes.DEFAULT && ey
                }
                isSelfMute() {
                    let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : ef.MediaEngineContextTypes.DEFAULT;
                    return !this.isEnabled() || e0(e).mute || !Q.default.didHavePermission(eh.NativePermissionTypes.AUDIO) || this.isSelfDeaf(e) || e === ef.MediaEngineContextTypes.DEFAULT && eP
                }
                isHardwareMute() {
                    let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : ef.MediaEngineContextTypes.DEFAULT;
                    return !this.isMute() && !this.isSelfMutedTemporarily(e) && ei.default.isHardwareMute(this.getInputDeviceId())
                }
                isSelfDeaf() {
                    let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : ef.MediaEngineContextTypes.DEFAULT;
                    return !this.isSupported() || e0(e).deaf
                }
                isVideoEnabled() {
                    return ek && eU
                }
                isVideoAvailable() {
                    return Object.values(eR).some(e => {
                        let {
                            disabled: t
                        } = e;
                        return !t
                    })
                }
                isScreenSharing() {
                    let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : ef.MediaEngineContextTypes.STREAM;
                    return eN === e && null != a
                }
                isSoundSharing() {
                    var e;
                    let t = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : ef.MediaEngineContextTypes.STREAM;
                    return eN === t && null != a && (null === (e = a.desktopSource) || void 0 === e ? void 0 : e.soundshareId) != null
                }
                isLocalMute(e) {
                    let t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : ef.MediaEngineContextTypes.DEFAULT;
                    return e !== et.default.getId() && (e0(t).localMutes[e] || !1)
                }
                supportsDisableLocalVideo() {
                    return ev.supports(ef.Features.DISABLE_VIDEO)
                }
                isLocalVideoDisabled(e) {
                    var t;
                    let n = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : ef.MediaEngineContextTypes.DEFAULT;
                    return null !== (t = e0(n).disabledLocalVideos[e]) && void 0 !== t && t
                }
                getVideoToggleState(e) {
                    var t;
                    let n = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : ef.MediaEngineContextTypes.DEFAULT;
                    return null !== (t = e0(n).videoToggleStateMap[e]) && void 0 !== t ? t : ed.VideoToggleState.NONE
                }
                isLocalVideoAutoDisabled(e) {
                    let t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : ef.MediaEngineContextTypes.DEFAULT;
                    return t === ef.MediaEngineContextTypes.DEFAULT && ez.has(e)
                }
                isAnyLocalVideoAutoDisabled() {
                    let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : ef.MediaEngineContextTypes.DEFAULT;
                    return e === ef.MediaEngineContextTypes.DEFAULT && ez.size > 0
                }
                isMediaFilterSettingLoading() {
                    return eq
                }
                isNativeAudioPermissionReady() {
                    return ej
                }
                getGoLiveSource() {
                    return a
                }
                getGoLiveContext() {
                    return eN
                }
                getLocalPan(e) {
                    let t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : ef.MediaEngineContextTypes.DEFAULT,
                        n = e0(t).localPans[e];
                    return null != n ? n : eS
                }
                getLocalVolume(e) {
                    let t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : ef.MediaEngineContextTypes.DEFAULT,
                        n = t === ef.MediaEngineContextTypes.STREAM,
                        i = n ? ef.DEFAULT_STREAM_VOLUME : ef.DEFAULT_VOLUME,
                        s = e0(t).localVolumes[e];
                    return null != s ? s : i
                }
                getInputVolume() {
                    return e0().inputVolume
                }
                getOutputVolume() {
                    return e0().outputVolume
                }
                getMode() {
                    let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : ef.MediaEngineContextTypes.DEFAULT;
                    return e0(e).mode
                }
                getModeOptions() {
                    let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : ef.MediaEngineContextTypes.DEFAULT;
                    return e0(e).modeOptions
                }
                getShortcuts() {
                    let e = {};
                    return f.each(eC, (t, n) => {
                        let {
                            mode: i,
                            modeOptions: {
                                shortcut: s
                            }
                        } = t;
                        i === ed.InputModes.PUSH_TO_TALK && eT.has(n) && (e[n] = s)
                    }), e
                }
                getInputDeviceId() {
                    return ts(eD, e0().inputDeviceId)
                }
                getOutputDeviceId() {
                    return ts(eO, e0().outputDeviceId)
                }
                getVideoDeviceId() {
                    return ts(eR, e0().videoDeviceId)
                }
                getInputDevices() {
                    return eD
                }
                getOutputDevices() {
                    return eO
                }
                getVideoDevices() {
                    return eR
                }
                getEchoCancellation() {
                    let e = e0();
                    return ei.default.hasEchoCancellation(e.inputDeviceId) || e.echoCancellation
                }
                getH265Enabled() {
                    return e0().h265Enabled
                }
                getLoopback() {
                    return ev.getLoopback()
                }
                getNoiseSuppression() {
                    let e = e0();
                    return ei.default.hasNoiseSuppression(e.inputDeviceId) || e.noiseSuppression
                }
                getAutomaticGainControl() {
                    let e = e0();
                    return ei.default.hasAutomaticGainControl(e.inputDeviceId) || e.automaticGainControl
                }
                getNoiseCancellation() {
                    return e0().noiseCancellation
                }
                getExperimentalEncoders() {
                    return e0().experimentalEncoders
                }
                getHardwareH264() {
                    return e0().hardwareH264
                }
                getEnableSilenceWarning() {
                    return e0().silenceWarning
                }
                getDebugLogging() {
                    return ev.getDebugLogging()
                }
                getQoS() {
                    return e0().qos
                }
                getAttenuation() {
                    return e0().attenuation
                }
                getAttenuateWhileSpeakingSelf() {
                    return e0().attenuateWhileSpeakingSelf
                }
                getAttenuateWhileSpeakingOthers() {
                    return e0().attenuateWhileSpeakingOthers
                }
                getAudioSubsystem() {
                    return ev.getAudioSubsystem()
                }
                getSettings() {
                    let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : ef.MediaEngineContextTypes.DEFAULT;
                    return e0(e)
                }
                getState() {
                    return {
                        settingsByContext: eC,
                        inputDevices: eD,
                        outputDevices: eO,
                        appSupported: eZ,
                        krispModuleLoaded: eW,
                        goLiveSource: a,
                        goLiveContext: eN
                    }
                }
                getInputDetected() {
                    return ex
                }
                getNoInputDetectedNotice() {
                    return eB
                }
                getPacketDelay() {
                    return J.isPlatformEmbedded || this.getMode() !== ed.InputModes.VOICE_ACTIVITY ? 0 : this.getModeOptions().vadLeading
                }
                setCanHavePriority(e, t) {
                    ev.eachConnection(n => n.setCanHavePriority(e, t))
                }
                isInteractionRequired() {
                    return eA
                }
                getVideoHook() {
                    return e0().videoHook
                }
                supportsVideoHook() {
                    return ev.supports(ef.Features.VIDEO_HOOK)
                }
                getExperimentalSoundshare() {
                    let e = e0().experimentalSoundshare2;
                    return this.supportsExperimentalSoundshare() && (null == e || e)
                }
                supportsExperimentalSoundshare() {
                    return ev.supports(ef.Features.EXPERIMENTAL_SOUNDSHARE) && E.satisfies(null === T.default || void 0 === T.default ? void 0 : T.default.os.release, ec.WINDOWS_SOUNDSHARE_VERSION)
                }
                getOpenH264() {
                    return e0().openH264
                }
                getAv1Enabled() {
                    return e0().av1Enabled
                }
                getEverSpeakingWhileMuted() {
                    return eV
                }
                getSoundshareEnabled() {
                    return eQ
                }
                supportsEnableSoundshare() {
                    return (0, J.isMac)() && ev.supports(ef.Features.SOUNDSHARE) && E.satisfies(null === T.default || void 0 === T.default ? void 0 : T.default.os.release, ec.DARWIN_SOUNDSHARE_VERSION) && !(E.satisfies(null === T.default || void 0 === T.default ? void 0 : T.default.os.release, ec.DARWIN_SCKIT_AUDIO_VERSION) && e9(!1))
                }
                supportsScreenSoundshare() {
                    return (0, J.isMac)() && ev.supports(ef.Features.SOUNDSHARE) && E.satisfies(null === T.default || void 0 === T.default ? void 0 : T.default.os.release, ec.DARWIN_SCKIT_AUDIO_VERSION) && e9(!1)
                }
                getVideoStreamParameters() {
                    let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : ef.MediaEngineContextTypes.DEFAULT,
                        t = this.supports(ef.Features.VIDEO) ? [{
                            rid: "100",
                            type: e === ef.MediaEngineContextTypes.DEFAULT ? ef.MediaTypes.VIDEO : ef.MediaTypes.SCREEN,
                            quality: 100
                        }] : [];
                    return this.isSimulcastSupported() && e === ef.MediaEngineContextTypes.DEFAULT && t.push({
                        rid: "50",
                        type: ef.MediaTypes.VIDEO,
                        quality: 50
                    }), t
                }
                getSupportedSecureFramesProtocolVersion(e) {
                    let t = ev.getSupportedSecureFramesProtocolVersion(),
                        n = B.SecureFramesUserExperiment.getCurrentConfig({
                            location: "MediaEngineStore"
                        }).canSupportSecureFrames;
                    if (n) return t;
                    let i = null != e && B.SecureFramesGuildExperiment.getCurrentConfig({
                        guildId: e,
                        location: "MediaEngineStore"
                    }).canSupportSecureFrames;
                    return i ? t : 0
                }
            }
            tm.displayName = "MediaEngineStore";
            var tE = i = new tm(C.default, {
                VOICE_CHANNEL_SELECT: function(e) {
                    let {
                        guildId: t,
                        channelId: n,
                        currentVoiceChannelId: i,
                        video: s
                    } = e;
                    if (i !== n && e6(s, null), null != t || null == n) {
                        eG = !1;
                        return
                    }
                    if (eG) return;
                    eG = !0;
                    let a = e0();
                    (a.mute || a.deaf) && (te({
                        deaf: !1,
                        mute: !1
                    }), ev.eachConnection(e3))
                },
                VOICE_STATE_UPDATES: function(e) {
                    let {
                        voiceStates: t
                    } = e;
                    return t.reduce((e, t) => {
                        if (s === t.sessionId) {
                            eb = t.mute || t.suppress, eL = t.deaf, ev.eachConnection(e3);
                            let e = null != t.guildId && null != t.channelId && null != eK && eK !== t.channelId,
                                n = !e && ek;
                            return e6(n), eK = t.channelId, !0
                        }
                        return !__OVERLAY__ && t.userId === et.default.getId() && null == er.default.getChannelId() && e6(!1, null), e
                    }, !1)
                },
                CONNECTION_OPEN: function(e) {
                    s = e.sessionId, eb = !1, eL = !1, (0, q.shouldReadWriteAudioSettings)() && ta()
                },
                CONNECTION_CLOSED: function() {
                    s = null
                },
                RTC_CONNECTION_STATE: function(e) {
                    switch (e.state) {
                        case ed.RTCConnectionStates.CONNECTING:
                            tt();
                            break;
                        case ed.RTCConnectionStates.RTC_CONNECTING:
                            eF = !1, eB = !1;
                            break;
                        case ed.RTCConnectionStates.RTC_CONNECTED:
                            e6();
                            break;
                        case ed.RTCConnectionStates.DISCONNECTED:
                            (function() {
                                if (0 === ez.size) return;
                                let e = ef.MediaEngineContextTypes.DEFAULT,
                                    {
                                        disabledLocalVideos: t
                                    } = e0(e);
                                ez.forEach(n => {
                                    h(t[n], "If you are auto-disabled, then you are also disabled."), delete t[n], ev.eachConnection(e => e.setLocalVideoDisabled(n, !1), e)
                                }), ez.clear(), te({
                                    disabledLocalVideos: t
                                }, e, !1)
                            })()
                    }
                    e8.update()
                },
                AUDIO_SET_TEMPORARY_SELF_MUTE: function(e) {
                    let {
                        mute: t
                    } = e;
                    ey = t, ev.eachConnection(e3)
                },
                AUDIO_TOGGLE_SELF_MUTE: function(e) {
                    let {
                        context: t
                    } = e, {
                        mute: n,
                        deaf: i
                    } = e0(t);
                    if (t === ef.MediaEngineContextTypes.DEFAULT && (Q.default.requestPermission(eh.NativePermissionTypes.AUDIO), eP)) return !1;
                    !(n = !i && !n) && (i = !1), te({
                        mute: n,
                        deaf: i
                    }, t), ev.eachConnection(e3)
                },
                AUDIO_TOGGLE_SELF_DEAF: function(e) {
                    let {
                        context: t
                    } = e, n = e0(t);
                    te({
                        deaf: !n.deaf
                    }, t), ev.eachConnection(e3)
                },
                AUDIO_TOGGLE_LOCAL_MUTE: function(e) {
                    let {
                        context: t,
                        userId: n
                    } = e;
                    if (n === et.default.getId()) return;
                    let {
                        localMutes: i
                    } = e0(t);
                    i[n] ? delete i[n] : i[n] = !0, te({
                        localMutes: i
                    }, t), ev.eachConnection(e => e.setLocalMute(n, i[n] || !1), t)
                },
                AUDIO_SET_LOCAL_VIDEO_DISABLED: function(e) {
                    var t, n, i, s, a, o, r;
                    let {
                        context: l,
                        userId: u,
                        videoToggleState: d,
                        persist: c,
                        isAutomatic: p
                    } = e;
                    h(!(c && p), "These are not allowed to both be true.");
                    let f = d === ed.VideoToggleState.DISABLED,
                        {
                            disabledLocalVideos: m
                        } = e0(l),
                        E = null !== (t = m[u]) && void 0 !== t && t,
                        g = ez.has(u),
                        S = d === ed.VideoToggleState.AUTO_ENABLED || d === ed.VideoToggleState.MANUAL_ENABLED;
                    eE.info("disableVideo=".concat(f, " currentlyDisabled=").concat(E, " currentlyAutoDisabled=").concat(g, ", isVideoShown=").concat(S)), h(!(g && !E), "If you are auto-disabled, then you are also disabled.");
                    let _ = f !== E,
                        v = l === ef.MediaEngineContextTypes.DEFAULT,
                        C = p && _ && v,
                        T = c && _ && v;
                    eE.info("changed=".concat(_, " isDefaultContext=").concat(v, " isUpdateCausedByVideoHealthManager=").concat(C, " isManualToggleByUser=").concat(T));
                    let {
                        videoToggleStateMap: I
                    } = e0(l);
                    if (I[u] === ed.VideoToggleState.AUTO_PROBING && d === ed.VideoToggleState.AUTO_ENABLED && (0, Y.default)(u, f ? ef.VideoToggleReason.AUTO_DISABLE : ef.VideoToggleReason.AUTO_ENABLE, S), I[u] = d, te({
                            videoToggleStateMap: I
                        }, l, c), d === ed.VideoToggleState.AUTO_PROBING ? null === (n = er.default.getRTCConnection()) || void 0 === n || n.pauseStatsCollectionForUser(u, !0) : null === (i = er.default.getRTCConnection()) || void 0 === i || i.pauseStatsCollectionForUser(u, !1), !eX && (eE.info("isAutoDisableAllowed=".concat(eX, " - disabling VideoHealthManager")), null === (a = er.default.getRTCConnection()) || void 0 === a || null === (s = a.getVideoHealthManager()) || void 0 === s || s.disable()), C) {
                        if (!f && !g || f && !eX) return;
                        (0, Y.default)(u, f ? ef.VideoToggleReason.AUTO_DISABLE : ef.VideoToggleReason.AUTO_ENABLE, S), f ? ez.add(u) : ez.delete(u)
                    } else T && (g && !f ? (eE.info("disallowing auto-disable for this session because of manual override by user"), eX = !1, null === (r = er.default.getRTCConnection()) || void 0 === r || null === (o = r.getVideoHealthManager()) || void 0 === o || o.disable(), (0, Y.default)(u, ef.VideoToggleReason.MANUAL_REENABLE, S)) : (0, Y.default)(u, f ? ef.VideoToggleReason.MANUAL_DISABLE : ef.VideoToggleReason.MANUAL_ENABLE, S));
                    v && !f && ez.delete(u), f ? m[u] = !0 : delete m[u], te({
                        disabledLocalVideos: m
                    }, l, c), ev.eachConnection(e => {
                        var t;
                        return e.setLocalVideoDisabled(u, null !== (t = m[u]) && void 0 !== t && t)
                    }, l)
                },
                AUDIO_SET_LOCAL_VOLUME: function(e) {
                    let {
                        context: t,
                        userId: n,
                        volume: i
                    } = e;
                    if (n === et.default.getId()) return;
                    let s = t === ef.MediaEngineContextTypes.STREAM,
                        a = s ? ef.DEFAULT_STREAM_VOLUME : ef.DEFAULT_VOLUME,
                        {
                            localVolumes: o
                        } = e0(t);
                    i === a ? delete o[n] : o[n] = i, te({
                        localVolumes: o
                    }, t), ev.eachConnection(e => e.setLocalVolume(n, i), t)
                },
                AUDIO_SET_LOCAL_PAN: function(e) {
                    let {
                        context: t,
                        userId: n,
                        left: i,
                        right: s
                    } = e, {
                        localPans: a
                    } = e0(t);
                    a[n] = {
                        left: i,
                        right: s
                    }, te({
                        localPans: a
                    }, t), ev.eachConnection(e => e.setLocalPan(n, i, s), t)
                },
                AUDIO_SET_MODE: function(e) {
                    let {
                        context: t,
                        mode: n,
                        options: i
                    } = e;
                    te({
                        mode: n,
                        modeOptions: i
                    }, t), ev.eachConnection(e1), e8.update()
                },
                AUDIO_SET_INPUT_VOLUME: function(e) {
                    let {
                        volume: t
                    } = e;
                    te({
                        inputVolume: e2(t)
                    }), ev.setInputVolume(t)
                },
                AUDIO_SET_OUTPUT_VOLUME: function(e) {
                    let {
                        volume: t
                    } = e;
                    te({
                        outputVolume: t
                    }), ev.setOutputVolume(t)
                },
                AUDIO_SET_INPUT_DEVICE: function(e) {
                    let {
                        id: t
                    } = e;
                    te({
                        inputDeviceId: t = ts(eD, t)
                    }), ev.setAudioInputDevice(t)
                },
                AUDIO_SET_OUTPUT_DEVICE: function(e) {
                    let {
                        id: t
                    } = e;
                    te({
                        outputDeviceId: t = ts(eO, t)
                    }), ev.setAudioOutputDevice(t)
                },
                AUDIO_SET_ECHO_CANCELLATION: function(e) {
                    let t = te({
                        echoCancellation: e.enabled
                    });
                    ev.eachConnection(e => e.setEchoCancellation(t.echoCancellation)), tu(), tl(e.location)
                },
                MEDIA_ENGINE_SET_H265: function(e) {
                    let t = te({
                        h265Enabled: e.enabled
                    });
                    ev.setH265Enabled(t.h265Enabled)
                },
                AUDIO_SET_LOOPBACK: function(e) {
                    let {
                        enabled: t
                    } = e;
                    return eJ = t, tu()
                },
                AUDIO_SET_NOISE_SUPPRESSION: function(e) {
                    let t = te({
                        noiseSuppression: e.enabled
                    });
                    ev.eachConnection(e => e.setNoiseSuppression(t.noiseSuppression)), tu(), tl(e.location)
                },
                AUDIO_SET_AUTOMATIC_GAIN_CONTROL: function(e) {
                    let t = te({
                        automaticGainControl: e.enabled
                    });
                    ev.eachConnection(e => e.setAutomaticGainControl(t.automaticGainControl)), tu(), tl(e.location)
                },
                AUDIO_SET_NOISE_CANCELLATION: function(e) {
                    let t = te({
                        noiseCancellation: e.enabled
                    });
                    ev.eachConnection(e => e.setNoiseCancellation(t.noiseCancellation)), tu(), tl(e.location)
                },
                AUDIO_SET_DISPLAY_SILENCE_WARNING: function(e) {
                    te({
                        silenceWarning: e.enabled
                    }), e8.update()
                },
                AUDIO_SET_DEBUG_LOGGING: function(e) {
                    ev.setDebugLogging(e.enabled)
                },
                MEDIA_ENGINE_SET_VIDEO_HOOK: function(e) {
                    te({
                        videoHook: e.enabled
                    })
                },
                MEDIA_ENGINE_SET_EXPERIMENTAL_SOUNDSHARE: function(e) {
                    te({
                        experimentalSoundshare2: e.enabled
                    })
                },
                AUDIO_SET_ATTENUATION: function(e) {
                    let {
                        attenuation: t,
                        attenuateWhileSpeakingSelf: n,
                        attenuateWhileSpeakingOthers: i
                    } = e, s = te({
                        attenuation: t,
                        attenuateWhileSpeakingSelf: n,
                        attenuateWhileSpeakingOthers: i
                    });
                    ev.eachConnection(e => e.setAttenuation(s.attenuation, s.attenuateWhileSpeakingSelf, s.attenuateWhileSpeakingOthers))
                },
                AUDIO_SET_QOS: function(e) {
                    let {
                        enabled: t
                    } = e;
                    te({
                        qos: t
                    }), ev.eachConnection(e => e.setQoS(t))
                },
                MEDIA_ENGINE_DEVICES: function(e) {
                    let {
                        inputDevices: t,
                        outputDevices: n,
                        videoDevices: i
                    } = e;
                    ! function(e) {
                        let t = eD;
                        if (eD = ti(e, em.default.Messages.NO_INPUT_DEVICES), !f.isEqual(eD, t)) {
                            let e = e0(),
                                t = ts(eD, e.inputDeviceId);
                            ev.setAudioInputDevice(t)
                        }
                    }(t), ! function(e) {
                        let t = eO;
                        if (eO = ti(e, em.default.Messages.NO_OUTPUT_DEVICES), !f.isEqual(eO, t)) {
                            let e = e0(),
                                t = ts(eO, e.outputDeviceId);
                            ev.setAudioOutputDevice(t)
                        }
                    }(n), ! function(e) {
                        eU = e.length > 0;
                        let t = eR;
                        if (eR = ti(e, em.default.Messages.NO_VIDEO_DEVICES), ek && !f.isEqual(eR, t)) {
                            var n;
                            let e = void 0 !== eR[ew],
                                i = ew === ef.DEFAULT_DEVICE_ID && (null === (n = t[ef.DEFAULT_DEVICE_ID]) || void 0 === n ? void 0 : n.disabled);
                            e6(e || i)
                        }
                    }(i)
                },
                AUDIO_VOLUME_CHANGE: function(e) {
                    let {
                        inputVolume: t,
                        outputVolume: n
                    } = e;
                    te({
                        inputVolume: e2(t),
                        outputVolume: n
                    })
                },
                AUDIO_RESET: function() {
                    _.default.remove(eg), location.reload()
                },
                AUDIO_INPUT_DETECTED: function(e) {
                    let {
                        inputDetected: t
                    } = e;
                    ex = t, !eF && ex && (eF = !0, e8.update())
                },
                AUDIO_SET_SUBSYSTEM: function(e) {
                    ev.setAudioSubsystem(e.subsystem)
                },
                MEDIA_ENGINE_SET_AUDIO_ENABLED: function(e) {
                    eI = e.enabled, e.unmute && te({
                        mute: !1,
                        deaf: !1
                    }), ev.eachConnection(e3)
                },
                MEDIA_ENGINE_SET_VIDEO_ENABLED: function(e) {
                    let {
                        enabled: t
                    } = e;
                    Q.default.requestPermission(eh.NativePermissionTypes.CAMERA), e6(t)
                },
                MEDIA_ENGINE_PERMISSION: function(e) {
                    let {
                        kind: t,
                        granted: n
                    } = e;
                    if (!n) switch (t) {
                        case "audio":
                            eI = !1, ev.eachConnection(e3);
                            break;
                        case "video":
                            e6(!1)
                    }
                },
                MEDIA_ENGINE_SET_GO_LIVE_SOURCE: function(e) {
                    var t, n, i, s, o;
                    let {
                        settings: r
                    } = e;
                    if ((null == r ? void 0 : r.desktopSettings) != null) {
                        ;
                        let e = null,
                            i = null,
                            {
                                sourceId: s,
                                sound: l
                            } = r.desktopSettings,
                            u = null !== (t = r.context) && void 0 !== t ? t : ef.MediaEngineContextTypes.DEFAULT,
                            d = null !== (n = r.qualityOptions) && void 0 !== n ? n : {
                                resolution: 720,
                                frameRate: 30
                            },
                            c = X.default.getPidFromDesktopSource(s);
                        J.isPlatformEmbedded && !0 === l && ({
                            soundshareId: e,
                            soundshareSession: i
                        } = to(c), null != e && tr(e, i)), (o = u) !== eN && (null != a && ev.setGoLiveSource(null, eN), eN = o);
                        let h = u === ef.MediaEngineContextTypes.STREAM && ek;
                        e6(h, {
                            desktopSource: {
                                id: s,
                                sourcePid: c,
                                soundshareId: e,
                                soundshareSession: i
                            },
                            quality: {
                                resolution: d.resolution,
                                frameRate: d.frameRate
                            }
                        })
                    } else if ((null == r ? void 0 : r.cameraSettings) != null) {
                        let e = null !== (i = r.context) && void 0 !== i ? i : ef.MediaEngineContextTypes.DEFAULT,
                            {
                                videoDeviceGuid: t,
                                audioDeviceGuid: n
                            } = r.cameraSettings,
                            a = e === ef.MediaEngineContextTypes.STREAM && ek,
                            o = null !== (s = r.qualityOptions) && void 0 !== s ? s : {
                                resolution: 720,
                                frameRate: 30
                            };
                        e6(a, {
                            cameraSource: {
                                videoDeviceGuid: t,
                                audioDeviceGuid: n
                            },
                            quality: {
                                resolution: o.resolution,
                                frameRate: o.frameRate
                            }
                        })
                    } else e6(ek, null)
                },
                MEDIA_ENGINE_SET_VIDEO_DEVICE: function(e) {
                    let {
                        id: t
                    } = e;
                    te({
                        videoDeviceId: t = ts(eR, t)
                    }), e6()
                },
                MEDIA_ENGINE_SET_EXPERIMENTAL_ENCODERS: function(e) {
                    let t = te({
                        experimentalEncoders: e.enabled
                    });
                    ev.eachConnection(e => e.setExperimentalEncoders(t.experimentalEncoders))
                },
                MEDIA_ENGINE_INTERACTION_REQUIRED: function(e) {
                    return eA !== e.required && (eA = e.required, !e.required && ev.interact(), !0)
                },
                USER_SETTINGS_MODAL_INIT: th,
                USER_SETTINGS_MODAL_SET_SECTION: th,
                CERTIFIED_DEVICES_SET: function() {
                    return ev.eachConnection(e5), !1
                },
                RPC_APP_CONNECTED: function(e) {
                    let {
                        application: t
                    } = e;
                    eT.add(t.id)
                },
                RPC_APP_DISCONNECTED: function(e) {
                    let {
                        application: t
                    } = e;
                    eT.delete(t.id)
                },
                OVERLAY_INITIALIZE: function(e) {
                    let {
                        mediaEngineState: t
                    } = e;
                    eC = t.settingsByContext, eD = t.inputDevices, eO = t.outputDevices, eZ = t.appSupported, eW = t.krispModuleLoaded, eN = t.goLiveContext
                },
                MEDIA_ENGINE_SET_OPEN_H264: function(e) {
                    let {
                        enabled: t
                    } = e, n = te({
                        openH264: t
                    });
                    ev.setH264Enabled(n.openH264)
                },
                MEDIA_ENGINE_SET_HARDWARE_H264: function(e) {
                    let {
                        enabled: t
                    } = e, n = te({
                        hardwareH264: t
                    });
                    ev.eachConnection(e => e.setHardwareH264(n.hardwareH264))
                },
                MEDIA_ENGINE_SET_AV1: function(e) {
                    let {
                        enabled: t
                    } = e, n = te({
                        av1Enabled: t
                    });
                    ev.setAv1Enabled(n.av1Enabled)
                },
                APP_STATE_UPDATE: function(e) {
                    let {
                        state: t
                    } = e, n = R.default.isEnabled();
                    if (t === ed.AppStates.BACKGROUND && ek && !n) eM = !0, e6(!1);
                    else {
                        if (t !== ed.AppStates.ACTIVE || !eM) return !1;
                        eM = !1, e6(!0)
                    }
                    return !0
                },
                SET_CHANNEL_BITRATE: function(e) {
                    ev.eachConnection(t => t.setBitRate(e.bitrate))
                },
                SET_VAD_PERMISSION: function(e) {
                    let {
                        hasPermission: t
                    } = e, n = !t;
                    if (n === eP) return !1;
                    eP = n, ev.eachConnection(e3)
                },
                SET_NATIVE_PERMISSION: function(e) {
                    let {
                        state: t,
                        permissionType: n
                    } = e, i = t === eh.NativePermissionStates.ACCEPTED;
                    switch (n) {
                        case eh.NativePermissionTypes.AUDIO:
                            ej = !0, ev.eachConnection(e3);
                            break;
                        case eh.NativePermissionTypes.CAMERA:
                            !i && ek && e6(!1);
                            break;
                        default:
                            return !1
                    }
                },
                SET_CHANNEL_VIDEO_QUALITY_MODE: function(e) {
                    ev.eachConnection(t => t.applyVideoQualityMode(e.mode))
                },
                MEDIA_ENGINE_SET_AEC_DUMP: function(e) {
                    let {
                        enabled: t
                    } = e, n = te({
                        aecDumpEnabled: t
                    });
                    ev.setAecDump(n.aecDumpEnabled)
                },
                CHANNEL_DELETE: function() {
                    if (!ek && null == a || null != er.default.getRTCConnectionId()) return !1;
                    e6(!1, null)
                },
                MEDIA_ENGINE_NOISE_CANCELLATION_ERROR_RESET: function() {
                    return !!eY && (eY = !1, !0)
                },
                MEDIA_ENGINE_ENABLE_SOUNDSHARE: function() {
                    tf(), ! function() {
                        var e, t;
                        let n = i.isSoundSharing(),
                            s = null === (e = i.getGoLiveSource()) || void 0 === e ? void 0 : e.desktopSource;
                        if (null != s) {
                            let e = null !== (t = s.soundshareId) && void 0 !== t ? t : 0,
                                a = i.getExperimentalSoundshare();
                            n && ev.setSoundshareSource(e, a, eN)
                        }
                    }()
                },
                MEDIA_ENGINE_APPLY_MEDIA_FILTER_SETTINGS: function(e) {
                    let {
                        settings: t
                    } = e;
                    ev.applyMediaFilterSettings(t).finally(() => {
                        eq = !1, i.emitChange()
                    })
                },
                MEDIA_ENGINE_APPLY_MEDIA_FILTER_SETTINGS_START: function() {
                    eq = !0
                },
                MEDIA_ENGINE_APPLY_MEDIA_FILTER_SETTINGS_ERROR: function() {
                    eq = !1
                },
                USER_SETTINGS_PROTO_UPDATE: function(e) {
                    let {
                        settings: {
                            type: t
                        },
                        local: n,
                        wasSaved: i
                    } = e;
                    if (!(0, q.shouldReadWriteAudioSettings)() || t !== ep.UserSettingsTypes.PRELOADED_USER_SETTINGS || n || null != i) return !1;
                    ta(!0)
                },
                CLIPS_INIT: function(e) {
                    let {
                        sourceId: t,
                        applicationName: n
                    } = e, {
                        enableDecoupledGameClipping: s
                    } = P.default.getCurrentConfig({
                        location: "handleClipsInit"
                    }, {
                        autoTrackExposure: !0
                    }), a = A.default.getSettings().decoupledClipsEnabled;
                    if (!s || !a || null == T.default) return;
                    let r = null,
                        l = null,
                        u = {
                            resolution: 720,
                            frameRate: 30
                        },
                        d = X.default.getPidFromDesktopSource(t);
                    ({
                        soundshareId: r,
                        soundshareSession: l
                    } = to(d));
                    let c = {
                        desktopSource: {
                            id: t,
                            sourcePid: d,
                            soundshareId: r,
                            soundshareSession: l
                        },
                        quality: u
                    };
                    null != o && o.desktopSource.id !== c.desktopSource.id && (ev.setClipsSource(null), (0, J.isWindows)() && null != o.desktopSource.soundshareId && I.cancelAttachToProcess(o.desktopSource.soundshareId)), null != r && tr(r, l), o = c;
                    let {
                        useQuartzCapturer: h
                    } = x.default.getCurrentConfig({
                        location: "f627ab_11"
                    }, {
                        autoTrackExposure: !1
                    }), {
                        hdrCaptureMode: p
                    } = V.default.getCurrentConfig({
                        location: "f627ab_12"
                    }, {
                        autoTrackExposure: !1
                    }), f = e0().videoHook, m = ev.supports(ef.Features.CAPTURE_TIMEOUT_EXPERIMENTS), {
                        videoHookStaleFrameTimeoutMs: E
                    } = G.default.getConfig(m && f, "e225cfdf5_vh2", !1), {
                        graphicsCaptureStaleFrameTimeoutMs: g
                    } = K.default.getConfig(m && e7(), "e225cfdf5_wgc2", !1);
                    ev.setClipsSource({
                        desktopDescription: {
                            id: o.desktopSource.id,
                            soundshareId: o.desktopSource.soundshareId,
                            useVideoHook: f,
                            useGraphicsCapture: !0,
                            useLoopback: i.getExperimentalSoundshare(),
                            useQuartzCapturer: h,
                            allowScreenCaptureKit: e9(!1),
                            videoHookStaleFrameTimeoutMs: E,
                            graphicsCaptureStaleFrameTimeoutMs: g,
                            hdrCaptureMode: p
                        },
                        quality: u,
                        applicationName: n
                    })
                }
            })
        },
        985365: function(e, t, n) {
            "use strict";
            n.r(t), n.d(t, {
                default: function() {
                    return p
                }
            });
            var i = n("446674"),
                s = n("913144"),
                a = n("35468"),
                o = n("49111");
            let r = o.NetworkConnectionTypes.UNKNOWN,
                l = o.NetworkConnectionSpeeds.UNKNOWN,
                u = null;

            function d(e) {
                var t;
                r = null != e.type ? e.type : o.NetworkConnectionTypes.UNKNOWN, l = null !== (t = e.effectiveSpeed) && void 0 !== t ? t : o.NetworkConnectionSpeeds.UNKNOWN, u = e.serviceProvider, h.emitChange()
            }
            class c extends i.default.Store {
                initialize() {
                    a.default.getNetworkInformation().then(d), a.default.addChangeCallback(d)
                }
                getType() {
                    return r
                }
                getEffectiveConnectionSpeed() {
                    return l
                }
                getServiceProvider() {
                    return u
                }
            }
            c.displayName = "NetworkStore";
            let h = new c(s.default, {});
            var p = h
        },
        945956: function(e, t, n) {
            "use strict";
            let i, s;
            n.r(t), n.d(t, {
                default: function() {
                    return b
                }
            }), n("70102"), n("808653");
            var a = n("446674"),
                o = n("913144"),
                r = n("422791"),
                l = n("241718"),
                u = n("733589"),
                d = n("76393"),
                c = n("122530"),
                h = n("271938"),
                p = n("316133"),
                f = n("49111"),
                m = n("353927");
            let E = null,
                g = null,
                S = null,
                _ = null,
                v = !1,
                C = !1;

            function T(e, t) {
                if (null == s) throw Error("Creating RTCConnection without session.");
                let i = h.default.getId(),
                    a = n("997722").default,
                    u = new a({
                        userId: i,
                        sessionId: s,
                        guildId: e,
                        channelId: t
                    });
                return u.on(r.RTCConnectionEvent.State, (e, t, n) => {
                    o.default.wait(() => o.default.dispatch({
                        type: "RTC_CONNECTION_STATE",
                        state: e,
                        ...t,
                        ...n
                    }))
                }), u.on(r.RTCConnectionEvent.Video, (e, t, n, i, s) => {
                    o.default.wait(() => o.default.dispatch({
                        type: "RTC_CONNECTION_VIDEO",
                        guildId: e,
                        channelId: t,
                        userId: n,
                        streamId: i,
                        rtcServerId: s,
                        context: m.MediaEngineContextTypes.DEFAULT
                    }))
                }), u.on(r.RTCConnectionEvent.Ping, (e, t) => {
                    o.default.wait(() => o.default.dispatch({
                        type: "RTC_CONNECTION_PING",
                        pings: e,
                        quality: t
                    }))
                }), u.on(r.RTCConnectionEvent.OutboundLossRate, e => {
                    o.default.wait(() => o.default.dispatch({
                        type: "RTC_CONNECTION_LOSS_RATE",
                        lossRate: e
                    }))
                }), u.on(r.RTCConnectionEvent.Speaking, (e, t) => {
                    null == S || S.setSpeaking(e, t)
                }), u.on(r.RTCConnectionEvent.Flags, (e, t) => {
                    o.default.wait(() => {
                        o.default.dispatch({
                            type: "RTC_CONNECTION_FLAGS",
                            flags: t,
                            userId: e,
                            guildId: u.guildId,
                            channelId: u.channelId,
                            context: u.context
                        })
                    })
                }), u.on(r.RTCConnectionEvent.Platform, (e, t, n) => {
                    o.default.wait(() => {
                        o.default.dispatch({
                            type: "RTC_CONNECTION_PLATFORM",
                            platform: t,
                            userId: e,
                            channelId: n
                        })
                    })
                }), null == S && (S = new l.default(h.default.getId(), t)), _ = null, v = !1, C = !1, u
            }

            function I() {
                if (null == i) return !1;
                _ = i.getDuration(), i.destroy(), i = null
            }

            function A() {
                E = null
            }

            function N(e) {
                let {
                    channel: t
                } = e;
                if (null == i || i.channelId !== t.id) return !1;
                I()
            }

            function D() {
                return !0
            }
            class O extends a.default.Store {
                initialize() {
                    this.waitFor(p.default), (0, c.setVideoToggleAnalyticsParams)(this.getRTCConnectionId, this.getMediaSessionId)
                }
                getRTCConnection() {
                    return i
                }
                getState() {
                    return null != i ? i.state : f.RTCConnectionStates.DISCONNECTED
                }
                isConnected() {
                    return this.getState() === f.RTCConnectionStates.RTC_CONNECTED
                }
                isDisconnected() {
                    return this.getState() === f.RTCConnectionStates.DISCONNECTED
                }
                getRemoteDisconnectVoiceChannelId() {
                    return E
                }
                getLastSessionVoiceChannelId() {
                    return g
                }
                setLastSessionVoiceChannelId(e) {
                    g = e
                }
                getGuildId() {
                    return null == i ? void 0 : i.guildId
                }
                getChannelId() {
                    return null == i ? void 0 : i.channelId
                }
                getHostname() {
                    return null != i ? i.hostname : ""
                }
                getQuality() {
                    return null != i ? i.quality : f.RTCConnectionQuality.UNKNOWN
                }
                getPings() {
                    return null != i ? i.getPings() : []
                }
                getAveragePing() {
                    return null != i ? null == i ? void 0 : i.getAveragePing() : 0
                }
                getLastPing() {
                    return null == i ? void 0 : i.getLastPing()
                }
                getOutboundLossRate() {
                    return null == i ? void 0 : i.getOutboundLossRate()
                }
                getMediaSessionId() {
                    return null == i ? void 0 : i.getMediaSessionId()
                }
                getRTCConnectionId() {
                    return null == i ? void 0 : i.getRTCConnectionId()
                }
                getDuration() {
                    var e;
                    return null !== (e = null == i ? void 0 : i.getDuration()) && void 0 !== e ? e : _
                }
                getPacketStats() {
                    return null == i ? void 0 : i.getPacketStats()
                }
                getVoiceStateStats() {
                    return null == S ? void 0 : S.getStats()
                }
                getWasEverMultiParticipant() {
                    return v
                }
                getWasEverRtcConnected() {
                    return C
                }
            }
            O.displayName = "RTCConnectionStore";
            let R = new O(o.default, __OVERLAY__ ? {} : {
                CONNECTION_OPEN: function(e) {
                    return s = e.sessionId, E = null, g = null, I(), !1
                },
                CONNECTION_CLOSED: function() {
                    s = null, E = null, g = null, I()
                },
                RTC_CONNECTION_STATE: function(e) {
                    return e.state === f.RTCConnectionStates.RTC_CONNECTED && (C = !0), !0
                },
                RTC_CONNECTION_PING: D,
                RTC_CONNECTION_LOSS_RATE: D,
                RTC_CONNECTION_UPDATE_ID: function(e) {
                    return e.connection === i
                },
                VOICE_STATE_UPDATES: function(e) {
                    let {
                        voiceStates: t
                    } = e;
                    return t.reduce((e, t) => {
                        var n, a, o;
                        if (null == S || S.updateVoiceStates(t.userId, t.channelId), v = v || (null !== (n = null == S ? void 0 : S.getStats().max_voice_state_count) && void 0 !== n ? n : 0) > 1, h.default.getId() !== t.userId) return !1;
                        if (null != i) {
                            if (t.sessionId === s) null != t.guildId && t.guildId === i.guildId || null == t.guildId && t.channelId === i.channelId ? null == t.channelId ? I() : i.channelId = t.channelId : (t.guildId !== i.guildId && null == t.channelId || I(), null != t.channelId && (E = null, g = null, i = T(t.guildId, t.channelId), v = (null !== (a = null == S ? void 0 : S.getStats().max_voice_state_count) && void 0 !== a ? a : 0) > 1));
                            else if (t.guildId === i.guildId) {
                                let e = null != d.default.getAwaitingRemoteSessionInfo() && null != d.default.getRemoteSessionId();
                                !e && (E = i.channelId), I()
                            }
                        } else {
                            if (t.sessionId !== s || null == t.channelId) return e;
                            E = null, g = null, i = T(t.guildId, t.channelId), v = (null !== (o = null == S ? void 0 : S.getStats().max_voice_state_count) && void 0 !== o ? o : 0) > 1
                        }
                        return !0
                    }, !1)
                },
                VOICE_CHANNEL_SELECT: function(e) {
                    let {
                        channelId: t
                    } = e;
                    if (null == i || null != t && i.channelId === t) return !1;
                    I()
                },
                VOICE_SERVER_UPDATE: function(e) {
                    if (null == i || null != e.guildId && e.guildId !== i.guildId || null != e.channelId && e.channelId !== i.channelId) return !1;
                    i.connect(e.endpoint, e.token)
                },
                CLEAR_REMOTE_DISCONNECT_VOICE_CHANNEL_ID: A,
                REMOTE_SESSION_CONNECT: A,
                CLEAR_LAST_SESSION_VOICE_CHANNEL_ID: function() {
                    g = null
                },
                GUILD_DELETE: function(e) {
                    let {
                        guild: t
                    } = e;
                    if (null == i || i.guildId !== t.id) return !1;
                    I()
                },
                CHANNEL_DELETE: N,
                THREAD_DELETE: N,
                CALL_DELETE: function(e) {
                    let {
                        channelId: t
                    } = e;
                    if (null == i || i.channelId !== t) return !1;
                    I()
                },
                APP_STATE_UPDATE: function(e) {
                    if (null != i) {
                        let t = e.state === f.AppStates.BACKGROUND,
                            n = u.default.isEnabled();
                        i.setAppBackgrounded(t, n)
                    }
                    return e.state === f.AppStates.ACTIVE && null != i && i.resetBackoff("App state is active"), !1
                },
                RTC_LOG_MARKER: function(e) {
                    if (null == i) {
                        console.warn("handleRtcLogMarker: Unexpected state, no rtcConnection.");
                        return
                    }
                    i.setRtcLogMarker(e.marker)
                }
            });
            n.el("599110").then(n.bind(n, "599110")).then(e => {
                let {
                    addExtraAnalyticsDecorator: t
                } = e;
                t(e => {
                    e.client_rtc_state = R.getState()
                })
            });
            var b = R
        },
        661919: function(e, t, n) {
            "use strict";
            n.r(t), n.d(t, {
                graphs: function() {
                    return f
                },
                keySection: function() {
                    return v
                },
                parseSection: function() {
                    return C
                },
                default: function() {
                    return N
                }
            }), n("222007"), n("424973");
            var i = n("446674"),
                s = n("773364"),
                a = n("913144"),
                o = n("673777"),
                r = n("42887"),
                l = n("697218"),
                u = n("49111"),
                d = n("353927");
            let c = v(d.MediaEngineContextTypes.DEFAULT, u.RTCDebugSections.TRANSPORT, 0),
                h = c,
                p = {},
                f = {
                    availableOutgoingBitrate: !0,
                    bitrate: !0,
                    bitrateTarget: !0,
                    bytesReceived: !0,
                    bytesSent: !0,
                    encoderQualityPsnr: !0,
                    encoderQualityVmaf: !0,
                    encodeUsage: !0,
                    frameRateDecode: !0,
                    frameRateEncode: !0,
                    frameRateInput: !0,
                    frameRateNetwork: !0,
                    frameRateRender: !0,
                    inboundBitrateEstimate: !0,
                    packetsLost: !0,
                    packetsReceived: !0,
                    packetsSent: !0,
                    ping: !0
                };

            function m(e, t, n) {
                return "".concat(e, ":").concat(t, ":").concat(n)
            }
            class E {
                static empty() {
                    return new E({})
                }
                put(e, t, n, i) {
                    if ("" === i) {
                        let i = {
                            ...this.state
                        };
                        return delete i[m(e, t, n)], new E(i)
                    }
                    return new E({
                        [m(e, t, n)]: i,
                        ...this.state
                    })
                }
                get(e, t, n) {
                    let i = this.state[m(e, t, n)];
                    return null != i ? i : null
                }
                constructor(e) {
                    this.state = e
                }
            }
            let g = E.empty(),
                S = !1,
                _ = null;

            function v(e, t, n) {
                return "".concat(e, ":").concat(t, ":").concat(n)
            }

            function C(e) {
                let [t, n] = e.split(":");
                return {
                    context: t,
                    section: n
                }
            }

            function T() {
                Object.values(d.MediaEngineContextTypes).forEach(e => {
                    p[e] = {}
                })
            }
            T();

            function I() {
                null != _ && (_.destroy(), _ = null)
            }
            class A extends i.default.Store {
                getSection() {
                    return h
                }
                getStats() {
                    let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : d.MediaEngineContextTypes.DEFAULT;
                    return p[e][0]
                }
                getAllStats() {
                    let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : d.MediaEngineContextTypes.DEFAULT;
                    return Object.values(p[e])
                }
                getVideoStreams() {
                    return g
                }
                shouldRecordNextConnection() {
                    return S
                }
            }
            A.displayName = "RTCDebugStore";
            var N = new A(a.default, {
                RTC_DEBUG_MODAL_OPEN: function(e) {
                    var t;
                    h = null !== (t = e.section) && void 0 !== t ? t : c
                },
                RTC_DEBUG_MODAL_CLOSE: function() {
                    I()
                },
                RTC_DEBUG_MODAL_SET_SECTION: function(e) {
                    h = e.section
                },
                RTC_DEBUG_MODAL_UPDATE: function(e) {
                    let {
                        context: t,
                        stats: n,
                        index: i
                    } = e, s = p[t];
                    if (null != n) {
                        let [e, a, o] = h.split(":");
                        if (e === t && parseInt(o) === i) {
                            let e = l.default.getUser(a);
                            if (null != e) {
                                let {
                                    rtp: {
                                        inbound: e
                                    }
                                } = n;
                                !Object.keys(e).includes(a) && (h = c)
                            }
                        }
                        s[i] = function e(t) {
                            let n = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {},
                                i = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : Date.now(),
                                s = {};
                            for (let [a, o] of Object.entries(t)) {
                                let t = n[a];
                                if (Array.isArray(o)) {
                                    if ("object" == typeof o[0]) {
                                        let n = Array.isArray(t) ? t : [],
                                            r = s[a] = [];
                                        for (let t = 0; t < o.length; t++) {
                                            let s = n[t],
                                                a = "object" == typeof s ? s : {};
                                            r.push(e(o[t], a, i))
                                        }
                                    } else s[a] = o
                                } else if ("object" == typeof o && null !== o) {
                                    let n = "object" == typeof t && null !== t ? t : {};
                                    s[a] = e(o, n, i)
                                } else if (a in f && "number" == typeof o) {
                                    let e = s[a] = Array.isArray(t) ? t : [];
                                    e.push({
                                        value: o,
                                        time: i
                                    }), e.length > 600 && e.shift()
                                } else s[a] = o
                            }
                            return s
                        }(n, s[i])
                    } else delete s[i]
                },
                RTC_DEBUG_MODAL_OPEN_REPLAY: function(e) {
                    o.chooseReplayPath()
                },
                RTC_DEBUG_MODAL_OPEN_REPLAY_AT_PATH: function(e) {
                    let {
                        path: t
                    } = e, n = r.default.getMediaEngine();
                    if (I(), !n.supports(d.Features.CONNECTION_REPLAY) || 0 === t.length) return;
                    let i = n.createReplayConnection(d.MediaEngineContextTypes.DEFAULT, t);
                    null != i && (_ = i, i.on(s.BaseConnectionEvent.Video, (e, t, n, s, o) => {
                        a.default.dispatch({
                            type: "RTC_DEBUG_MODAL_UPDATE_VIDEO_OUTPUT",
                            mediaEngineConnectionId: i.mediaEngineConnectionId,
                            userId: e,
                            videoSsrc: null != s ? s : 0,
                            streamId: null != t ? t : ""
                        })
                    }), a.default.wait(() => o.open()))
                },
                RTC_DEBUG_MODAL_UPDATE_VIDEO_OUTPUT: function(e) {
                    g = g.put(e.mediaEngineConnectionId, e.userId, e.videoSsrc, e.streamId)
                },
                RTC_DEBUG_SET_RECORDING_FLAG: function(e) {
                    let {
                        value: t
                    } = e;
                    S = t
                },
                VOICE_CHANNEL_SELECT: function() {
                    T()
                }
            });
            r.default.getMediaEngine().on(s.MediaEngineEvent.ConnectionStats, function(e) {
                Object.values(d.MediaEngineContextTypes).forEach(t => {
                    e.filter(e => {
                        let {
                            connection: n
                        } = e;
                        return n.context === t
                    }).forEach((e, n) => {
                        a.default.dispatch({
                            type: "RTC_DEBUG_MODAL_UPDATE",
                            stats: e.stats,
                            context: t,
                            index: n,
                            mediaEngineConnectionId: e.connection.mediaEngineConnectionId
                        })
                    })
                })
            })
        },
        590401: function(e, t, n) {
            "use strict";
            n.r(t), n.d(t, {
                default: function() {
                    return d
                }
            });
            var i = n("917351"),
                s = n.n(i),
                a = n("446674"),
                o = n("913144");
            let r = {
                    preferredRegion: null,
                    lastTestTimestamp: null,
                    lastGeoRankedOrder: null
                },
                l = r;
            class u extends a.default.DeviceSettingsStore {
                initialize(e) {
                    l = null != e ? e : r
                }
                shouldIncludePreferredRegion() {
                    return null != l.preferredRegion
                }
                getPreferredRegion() {
                    return l.preferredRegion
                }
                getRegion(e) {
                    if (null != e) return e.substr(0, e.search(/\d/))
                }
                getUserAgnosticState() {
                    return l
                }
                shouldPerformLatencyTest(e) {
                    var t, n;
                    return null === l.preferredRegion || !s.isEqual(e, null !== (t = l.lastGeoRankedOrder) && void 0 !== t ? t : []) || Date.now() - (null !== (n = l.lastTestTimestamp) && void 0 !== n ? n : 0) >= 864e5
                }
            }
            u.displayName = "RTCRegionStore", u.persistKey = "RTCRegionStore";
            var d = new u(o.default, {
                RTC_LATENCY_TEST_COMPLETE: function(e) {
                    e.latencyRankedRegions.length > 0 && (l.lastGeoRankedOrder = e.geoRankedRegions, l.preferredRegion = e.latencyRankedRegions[0]), l.lastTestTimestamp = Date.now()
                }
            })
        },
        568307: function(e, t, n) {
            "use strict";
            let i;
            n.r(t), n.d(t, {
                gameInDatabase: function() {
                    return $
                },
                getOverlayGameStatus: function() {
                    return ee
                },
                transformForGameSettings: function() {
                    return ei
                },
                default: function() {
                    return eu
                }
            }), n("222007"), n("424973"), n("808653"), n("781738"), n("843762");
            var s, a, o = n("917351"),
                r = n.n(o),
                l = n("866227"),
                u = n.n(l),
                d = n("446674"),
                c = n("95410"),
                h = n("913144"),
                p = n("115718"),
                f = n("376556"),
                m = n("605250"),
                E = n("630915"),
                g = n("756898"),
                S = n("32128"),
                _ = n("599110"),
                v = n("269180"),
                C = n("449008"),
                T = n("773336"),
                I = n("50885"),
                A = n("546463"),
                N = n("686470"),
                D = n("535974"),
                O = n("49111"),
                R = n("6791");
            let b = new m.default("RunningGameStore"),
                y = "RunningGameStore",
                P = [{
                    executables: [{
                        os: "win32",
                        name: "obs/obs.exe"
                    }, {
                        os: "win32",
                        name: "obs32.exe"
                    }, {
                        os: "win32",
                        name: "obs64.exe"
                    }, {
                        os: "darwin",
                        name: "OBS.app"
                    }, {
                        os: "linux",
                        name: "obs"
                    }],
                    name: "OBS",
                    streamerTool: !0
                }, {
                    executables: [{
                        os: "win32",
                        name: "XSplit.Gamecaster.exe"
                    }, {
                        os: "win32",
                        name: "XSplit.Core.exe"
                    }, {
                        os: "win32",
                        name: "Gamecaster.exe"
                    }],
                    name: "XSplit",
                    streamerTool: !0
                }, {
                    executables: [{
                        os: "win32",
                        name: "bebo.exe"
                    }],
                    name: "Bebo",
                    streamerTool: !0
                }, {
                    executables: [{
                        os: "win32",
                        name: "Streamlabs OBS.exe"
                    }, {
                        os: "win32",
                        name: "Streamlabs Desktop.exe"
                    }, {
                        os: "darwin",
                        name: "Streamlabs Desktop.app"
                    }],
                    name: "Streamlabs Desktop",
                    streamerTool: !0
                }, {
                    executables: [{
                        os: "win32",
                        name: "TwitchStudio.exe"
                    }, {
                        os: "darwin",
                        name: "Twitch Studio.app"
                    }],
                    name: "Twitch Studio",
                    streamerTool: !0
                }, {
                    executables: [{
                        os: "win32",
                        name: "Spotify.exe"
                    }, {
                        os: "darwin",
                        name: "Spotify.app"
                    }, {
                        os: "linux",
                        name: "spotify"
                    }],
                    name: f.default.get(O.PlatformTypes.SPOTIFY).name
                }],
                L = !0,
                k = new Set,
                w = [],
                V = [],
                M = [],
                U = null,
                x = [],
                F = {},
                B = {},
                G = {
                    gamesSeen: [],
                    gameOverrides: {},
                    enableOverlay: {},
                    enableDetection: {}
                },
                H = function() {},
                W = {},
                K = 0,
                Y = null,
                Q = null,
                q = {};

            function j(e, t, n) {
                let i = e[t];
                void 0 !== i && (delete e[t], e[n] = i)
            }

            function z(e, t) {
                null != t.lastLaunched ? e.lastLaunched = t.lastLaunched : null != t.start && (e.lastLaunched = t.start)
            }

            function X(e) {
                return P.some(t => t.name === e.name && !0 === t.streamerTool)
            }

            function J() {
                if (M.length > 0) {
                    let e = U;
                    U = M[0], null != e && U.pid === e.pid ? U.start = e.start : U.start = Date.now()
                } else U = null;
                let e = [];
                for (let t of M) !(t.pid in q) && (q[t.pid] = t, e.push(t));
                let t = [];
                for (let e of Object.values(q)) !M.some(t => t.pid === e.pid) && (t.push(e), delete q[e.pid]);
                b.info("games", {
                    runningGames: M,
                    added: e,
                    removed: t,
                    previousGames: q
                }), h.default.dispatch({
                    type: "RUNNING_GAMES_CHANGE",
                    games: M,
                    added: e,
                    removed: t
                })
            }

            function Z(e) {
                let t = null != e.name ? e.name : "";
                return "".concat(e.exePath, ":").concat(t)
            }

            function $(e) {
                let t = A.default.getGameByName(e.name);
                return null != t || void 0 !== e.nativeProcessObserverId && (2147483648 & e.nativeProcessObserverId) == 0
            }

            function ee(e) {
                if (e.isLauncher) return {
                    source: "LAUNCHER",
                    enabled: !1,
                    overlayMethod: R.OverlayMethod.Disabled
                };
                let t = A.default.getGameByName(e.name);
                if (null != t) {
                    let e = N.default.getActiveLibraryApplication(t.id);
                    if (null != e) return {
                        source: "LIBRARY_APPLICATION",
                        enabled: e.isOverlayEnabled(),
                        overlayMethod: R.OverlayMethod.Disabled
                    }
                }
                let n = E.isOOPExperimentEnabled(),
                    i = null == e.id ? null : W[e.id],
                    s = n && null != i && i.supportsOutOfProcessOverlay,
                    a = s ? R.OverlayMethod.OutOfProcess : R.OverlayMethod.Hook,
                    o = S.OverlayStoredSettings.methodOverride;
                if (null != o && o !== R.OverlayMethod.Disabled) {
                    let t = R.OverlayMethod[a],
                        n = R.OverlayMethod[o];
                    b.info("getOverlayGameStatus: overlay method overriden ".concat(t, " -> ").concat(n, " (").concat(e.name, ")")), a = o
                }
                let r = G.enableOverlay[Z(e)];
                return null != r ? {
                    source: "USER_OVERRIDE",
                    enabled: r,
                    overlayMethod: a
                } : null != i ? {
                    source: "DATABASE",
                    enabled: i.enabled || s,
                    overlayMethod: a
                } : {
                    source: "DEFAULT",
                    enabled: !1,
                    overlayMethod: R.OverlayMethod.Hook
                }
            }(a = s || (s = {})).LAUNCHER = "LAUNCHER", a.LIBRARY_APPLICATION = "LIBRARY_APPLICATION", a.USER_OVERRIDE = "USER_OVERRIDE", a.DATABASE = "DATABASE", a.DEFAULT = "DEFAULT";

            function et(e) {
                let t = G.enableDetection[Z(e)];
                return null == t || t
            }

            function en() {
                c.default.set(y, G)
            }

            function ei(e) {
                var t, n;
                let i = {
                    ...e,
                    played: null != e.lastFocused && 0 !== e.lastFocused ? u(new Date(1e3 * e.lastFocused)).fromNow() : " ",
                    overlay: (t = e, null !== (n = G.enableOverlay[Z(t)]) && void 0 !== n ? n : ee(t).enabled),
                    verified: $(e),
                    detectable: et(e)
                };
                if (null != e.id && null != W[e.id]) {
                    let t = W[e.id];
                    i.overlayWarn = t.warn
                }
                return i
            }

            function es() {
                let e = !1;
                return w = r.values(N.default.libraryApplications).reduce((t, n) => {
                    let i = A.default.getDetectableGame(n.id);
                    if (null == i) return t;
                    let s = D.default.getLaunchOptions(n.id, n.branchId);
                    for (let a of s) {
                        let s = "".concat(n.id, ":").concat(n.branchId);
                        !k.has(s) && (e = !0, k.add(s));
                        let {
                            fullExecutablePath: o
                        } = a, r = o.replace(/\\/g, "/").toLowerCase();
                        F[r] = i.id, t.push({
                            id: i.id,
                            name: i.name,
                            exePath: r,
                            cmdLine: "",
                            lastFocused: 0,
                            add: !0
                        })
                    }
                    return t
                }, []), e && ea(), e
            }

            function ea() {
                if (!__OVERLAY__ && T.isPlatformEmbedded) {
                    let e = [...w, ...r.values(G.gameOverrides)];
                    I.default.setGameCandidateOverrides(e)
                }
            }

            function eo(e) {
                null != e && 0 !== e.length && (e.forEach(e => {
                    let t = G.gamesSeen.some(t => {
                        if (t.name === e.name) {
                            if (e.lastFocused) {
                                t.lastFocused = e.lastFocused;
                                let n = G.gameOverrides[Z(e)];
                                null != n && (n.lastFocused = e.lastFocused)
                            }
                            return z(t, e), !0
                        }
                        return !1
                    });
                    if (t);
                    else {
                        if (e.hidden) return;
                        G.gamesSeen.unshift(function(e) {
                            let t = {
                                exePath: e.exePath,
                                cmdLine: e.cmdLine,
                                lastFocused: e.lastFocused
                            };
                            return null != e.id && (t.id = e.id), null != e.nativeProcessObserverId && (t.nativeProcessObserverId = e.nativeProcessObserverId), null != e.name && (t.name = e.name), e.add && (t.add = !0), e.block && (t.block = !0), z(t, e), t
                        }(e))
                    }
                }), G.gamesSeen.sort((e, t) => t.lastFocused - e.lastFocused), en(), v.default.setRecentGames(er().map(e => ei(e))))
            }

            function er() {
                let e = r.values(G.gameOverrides),
                    t = G.gamesSeen.filter(e => void 0 === G.gameOverrides[Z(e)]);
                return t.concat(e)
            }!__OVERLAY__ && (0, T.isDesktop)() && (H = function() {
                let e = [],
                    t = new Set;
                i = {};
                let n = A.default.games;
                for (let e of n) {
                    var s, a, o, r;
                    W[e.id] = {
                        compatibilityHook: null !== (s = e.overlayCompatibilityHook) && void 0 !== s ? s : p.DEFAULT_OVERLAY_OPTIONS.compatibilityHook,
                        warn: null !== (a = e.overlayWarn) && void 0 !== a ? a : p.DEFAULT_OVERLAY_OPTIONS.warn,
                        enabled: null !== (o = e.overlay) && void 0 !== o ? o : p.DEFAULT_OVERLAY_OPTIONS.enabled,
                        allowHook: null !== (r = e.hook) && void 0 !== r ? r : p.DEFAULT_OVERLAY_OPTIONS.allowHook,
                        supportsOutOfProcessOverlay: e.supportsOutOfProcessOverlay
                    }
                } [...n, ...P].forEach(n => {
                    var i;
                    let s = null != n.executables ? null === (i = n.executables) || void 0 === i ? void 0 : i.filter(e => {
                            let {
                                os: t
                            } = e;
                            return t === (0, T.getPlatformName)()
                        }) : [],
                        a = {};
                    s.forEach(e => {
                        let n = null != e.arguments && e.arguments.length > 0 ? e.arguments : "null";
                        null == a[n] && (a[n] = []), a[n].push(e.name), e.isLauncher && t.add(e.name)
                    }), Object.keys(a).forEach(t => e.push({
                        name: n.name,
                        id: n.id,
                        executables: a[t],
                        cmdLine: "null" !== t ? t : null
                    }))
                }), e = e.filter(e => null != e.executables && e.executables.length > 0), I.default.setObservedGamesCallback(e, e => {
                    let n = [],
                        s = {};
                    e = e.filter(e => (e.distributor = function(e) {
                        if (null != F[e.exePath]) return O.Distributors.DISCORD;
                        if (/steamapps/.test(e.cmdLine)) return O.Distributors.STEAM;
                        if (/-epicapp/.test(e.cmdLine)) return O.Distributors.EPIC;
                        return e.distributor
                    }(e), e.isLauncher = t.has(e.exeName), e.isLauncher && null != e.id && (s[e.id] = e), e.windowHandle = function(e, t) {
                        if (void 0 === t) {
                            let t = I.default.getDiscordUtils();
                            if (null != t && null != t.getWindowHandleFromPid) {
                                let n = t.getWindowHandleFromPid(e);
                                return null != n && "0" !== n ? n : null
                            }
                            return null
                        }
                        return "0" === t ? null : t
                    }(e.pid, e.windowHandle), null == P.find(t => {
                        let {
                            name: n
                        } = t;
                        return n === e.name
                    }) || (n.push(e), !1)));
                    let a = n.filter(X).length;
                    a !== K && (K = a, h.default.dispatch({
                        type: "RUNNING_STREAMER_TOOLS_CHANGE",
                        count: K
                    })), M = e, x = n, i = s, J()
                }), ea()
            });
            class el extends d.default.Store {
                initialize() {
                    var e, t, n, i;
                    let s = null !== (e = c.default.get(y)) && void 0 !== e ? e : {
                        gamesSeen: [],
                        gameOverrides: {},
                        enableOverlay: {},
                        enableDetection: {}
                    };
                    G.gameOverrides = {};
                    let a = !1;
                    if (r.values(null !== (t = s.gameOverrides) && void 0 !== t ? t : {}).forEach(e => {
                            let t = Z(e);
                            G.gameOverrides[t] = e
                        }), G.enableOverlay = null !== (n = s.enableOverlay) && void 0 !== n ? n : {}, G.enableDetection = null !== (i = s.enableDetection) && void 0 !== i ? i : {}, ea(), Array.isArray(s.gamesSeen))
                        for (let e of s.gamesSeen) "number" == typeof e.id && (e.nativeProcessObserverId = e.id, delete e.id, a = !0);
                    eo(s.gamesSeen), this.waitFor(A.default), this.syncWith([N.default, A.default, D.default], r.throttle(es, 1e3)), a && en()
                }
                getVisibleGame() {
                    return null != U && (U.hidden || !et(U)) ? null : U
                }
                getCurrentGameForAnalytics() {
                    return U
                }
                getRunningDiscordApplicationIds() {
                    let e = [];
                    for (let t of M) null != F[t.exePath] && e.push(F[t.exePath]);
                    return e
                }
                getRunningVerifiedApplicationIds() {
                    return this.getRunningGames().map(e => A.default.getGameByName(e.name)).filter(C.isNotNullish).map(e => e.id)
                }
                getGameForPID(e) {
                    var t;
                    return null !== (t = M.find(t => t.pid === e)) && void 0 !== t ? t : null
                }
                getLauncherForPID(e) {
                    let t = this.getGameForPID(e);
                    return null != t ? null != t.id ? i[t.id] : null : null
                }
                getOverlayOptionsForPID(e) {
                    let t = this.getGameForPID(e);
                    return null == t || t.isLauncher || null == t.id ? null : {
                        ...W[t.id]
                    }
                }
                shouldElevateProcessForPID(e) {
                    return null != Y && Y === e
                }
                shouldContinueWithoutElevatedProcessForPID(e) {
                    return null != Q && Q === e
                }
                getCandidateGames() {
                    return V.filter(e => e.hidden || null == e.id).filter(e => void 0 === G.gameOverrides[Z(e)])
                }
                getRunningGames() {
                    return M
                }
                getGamesSeen(e) {
                    let t = !(arguments.length > 1) || void 0 === arguments[1] || arguments[1],
                        n = er();
                    if (e) {
                        let e = this.getVisibleGame();
                        if (null != e) {
                            let t = Z(e);
                            n = n.filter(e => Z(e) !== t)
                        }
                    }
                    return t && n.sort((e, t) => t.lastFocused - e.lastFocused), n
                }
                getSeenGameByName(e) {
                    return G.gamesSeen.find(t => null != t.name && t.name.toLowerCase() === e.toLowerCase())
                }
                isObservedAppRunning(e) {
                    return x.some(t => t.name === e)
                }
                getOverrides() {
                    return Object.values(G.gameOverrides)
                }
                getOverrideForGame(e) {
                    return G.gameOverrides[Z(e)]
                }
                getGameOverlayStatus(e) {
                    if (e.hidden || e.isLauncher || e.elevated || e.sandboxed) return b.verbose("getGameOverlayStatus: Overlay not supported.", e), null;
                    let t = ee(e);
                    return t.enabled ? t : null
                }
                getObservedAppNameForWindow(e) {
                    var t, n;
                    return null !== (n = null === (t = x.find(t => (0, g.default)(e, t.windowHandle))) || void 0 === t ? void 0 : t.name) && void 0 !== n ? n : null
                }
                get canShowAdminWarning() {
                    return L
                }
            }
            el.displayName = "RunningGameStore";
            var eu = new el(h.default, {
                RUNNING_GAMES_CHANGE: function(e) {
                    eo(M)
                },
                CANDIDATE_GAMES_CHANGE: function(e) {
                    V = e.games
                },
                PERMISSION_CLEAR_PTT_ADMIN_WARNING: function() {
                    L = !1
                },
                PERMISSION_REQUEST_ELEVATED_PROCESS: function(e) {
                    let {
                        pid: t
                    } = e;
                    Y = t, Q = null
                },
                PERMISSION_CLEAR_ELEVATED_PROCESS: function() {
                    Y = null
                },
                PERMISSION_CONTINUE_NONELEVATED_PROCESS: function(e) {
                    let {
                        pid: t
                    } = e;
                    Q = t, Y = null
                },
                RUNNING_GAME_ADD_OVERRIDE: function(e) {
                    let t;
                    let n = e.pid,
                        i = M.find(e => e.pid === n);
                    if (null == i) {
                        let e = V.find(e => e.pid === n);
                        if (null == e) return;
                        (i = {
                            ...e
                        }).hidden = !1, M.push(i), t = Z(i)
                    } else t = Z(i), i.hidden && (B[t] = !0), i.hidden = !1;
                    (null == i.lastFocused || 0 === i.lastFocused) && (i.lastFocused = Math.floor(Date.now() / 1e3)), G.gameOverrides[t] = {
                        ...i,
                        add: !0
                    }, eo(M), ea(), en(), J()
                },
                RUNNING_GAME_TOGGLE_OVERLAY: function(e) {
                    if (G.enableOverlay[Z(e.game)] = e.newEnabledValue, en(), !__OVERLAY__) {
                        let t = null != e.game.id ? A.default.getDetectableGame(e.game.id) : null;
                        null != t && _.default.track(O.AnalyticEvents.OVERLAY_TOGGLED, {
                            enabled: e.newEnabledValue,
                            setting_type: "overlay toggled - game",
                            application_id: t.id,
                            application_name: t.name
                        })
                    }
                },
                RUNNING_GAME_TOGGLE_DETECTION: function(e) {
                    let {
                        game: t
                    } = e, n = et(t);
                    G.enableDetection[Z(t)] = !n, en()
                },
                RUNNING_GAME_EDIT_NAME: function(e) {
                    let t = Z(e.game),
                        n = G.gameOverrides[t];
                    if (null == n) {
                        var i;
                        (n = {
                            name: (i = e.game).name,
                            exePath: i.exePath,
                            cmdLine: i.cmdLine,
                            lastFocused: i.lastFocused
                        }).add = !0
                    }
                    n.name = e.newName;
                    let s = Z(n);
                    delete G.gameOverrides[t], G.gameOverrides[s] = n, j(G.enableOverlay, t, s), j(G.enableDetection, t, s), j(B, t, s), G.gamesSeen.forEach(n => {
                        Z(n) === t && (n.name = e.newName)
                    });
                    let a = !1;
                    M.forEach(n => {
                        Z(n) === t && (n.name = e.newName, a = !0)
                    }), ea(), en(), a && J()
                },
                RUNNING_GAME_DELETE_ENTRY: function(e) {
                    let t = Z(e.game);
                    delete G.gameOverrides[t], delete G.enableOverlay[t], delete G.enableDetection[t], G.gamesSeen = G.gamesSeen.filter(e => Z(e) !== t), B[t] && (M.forEach(e => {
                        t === Z(e) && (e.hidden = !0)
                    }), delete B[t], J()), ea(), en()
                },
                GAMES_DATABASE_UPDATE: H,
                GAME_LAUNCH_SUCCESS: function(e) {
                    var t;
                    if (__OVERLAY__ || !T.isPlatformEmbedded) return;
                    let n = I.default.getDiscordUtils().notifyGameLaunched;
                    if (null == n) return;
                    let i = A.default.getDetectableGame(e.applicationId);
                    null != i && n(i.id, i.name, null !== (t = e.pids) && void 0 !== t ? t : [])
                },
                GAME_DETECTION_WATCH_CANDIDATE_GAMES_START: function() {
                    ea()
                }
            })
        },
        18494: function(e, t, n) {
            "use strict";
            let i, s, a, o, r, l, u;
            n.r(t), n.d(t, {
                findFirstVoiceChannelId: function() {
                    return U
                },
                default: function() {
                    return H
                }
            }), n("222007"), n("808653");
            var d = n("917351"),
                c = n.n(d),
                h = n("446674"),
                p = n("95410"),
                f = n("913144"),
                m = n("21121"),
                E = n("446411"),
                g = n("934306"),
                S = n("393414"),
                _ = n("233069"),
                v = n("449008"),
                C = n("271938"),
                T = n("42203"),
                I = n("923959"),
                A = n("305961"),
                N = n("42887"),
                D = n("162771"),
                O = n("49111"),
                R = n("724210");
            let b = "SelectedChannelStore",
                y = {},
                P = {},
                L = {},
                k = new Set;

            function w() {
                !__OVERLAY__ && p.default.set(b, {
                    selectedChannelId: a,
                    selectedVoiceChannelId: r,
                    lastChannelFollowingDestination: o,
                    lastConnectedTime: l,
                    selectedChannelIds: y,
                    mostRecentSelectedTextChannelIds: L,
                    knownThreadIds: c(y).values().concat(c.values(L)).filter(v.isNotNullish).uniq().filter(e => {
                        let t = T.default.getBasicChannel(e);
                        return k.has(e) || null != t && _.THREAD_CHANNEL_TYPES.has(t.type)
                    }).value()
                })
            }

            function V(e) {
                if (null != e) {
                    let t = I.default.getDefaultChannel(e);
                    if (null != t) return t.id
                }
            }

            function M(e, t) {
                if (null == e || null == t || L[e] === t) return !1;
                let n = T.default.getChannel(t),
                    i = null != n && (0, _.isGuildTextChannelType)(n.type),
                    s = (null == n ? void 0 : n.getGuildId()) === e;
                return !!i && !!s && (L[e] = t, !0)
            }

            function U(e) {
                let t = T.default.getMutableBasicGuildChannelsForGuild(e),
                    n = c.find(t, e => e.type === O.ChannelTypes.GUILD_VOICE);
                return null == n ? void 0 : n.id
            }

            function x() {
                let e = !1,
                    t = A.default.getGuilds();
                return c.each(y, (t, n) => {
                    (null == t || !T.default.hasChannel(t) && t !== a && !k.has(t) && !(0, R.isGuildHomeChannel)(t)) && (delete y[n], delete P[n], e = !0)
                }), c.each(L, (t, n) => {
                    (null == t || !T.default.hasChannel(t) && !k.has(t)) && (delete L[n], e = !0)
                }), c.each(t, e => {
                    let t = y[e.id];
                    null == L[e.id] && M(e.id, t)
                }), null != l && Date.now() - l >= 3e5 && (r = null, e = !0), e
            }

            function F(e, t) {
                if (k.delete(e), null == t) {
                    let n = D.default.getGuildId();
                    y[String(n)] === e && (t = n)
                }
                let n = null != A.default.getGuild(t) ? t : null,
                    i = !1;
                r === e && (r = null, i = !0), !(0, m.isInMainTabsExperiment)() && (y[String(n)] === e && (y[String(n)] = V(String(n)), D.default.getGuildId() === n && (0, S.replaceWith)(O.Routes.CHANNEL(t, y[String(n)])), i = !0), null != n && L[n] === e && (delete L[n], i = !0)), i && w()
            }

            function B(e) {
                let {
                    channel: {
                        id: t,
                        guild_id: n
                    }
                } = e;
                F(t, n)
            }
            class G extends h.default.Store {
                initialize() {
                    if (!__OVERLAY__) {
                        var e, t;
                        let n = null !== (e = p.default.get(b)) && void 0 !== e ? e : {
                            selectedChannelId: a,
                            selectedVoiceChannelId: r,
                            lastChannelFollowingDestination: o,
                            lastConnectedTime: l,
                            selectedChannelIds: y,
                            mostRecentSelectedTextChannelIds: L
                        };
                        null != n.knownThreadIds && (k = new Set(n.knownThreadIds)), r = n.selectedVoiceChannelId, o = n.lastChannelFollowingDestination, l = n.lastConnectedTime, L = null !== (t = n.mostRecentSelectedTextChannelIds) && void 0 !== t ? t : {}, null != n.selectedChannelIds && (y = {
                            ...n.selectedChannelIds,
                            null: null
                        })
                    }
                    this.mustEmitChanges(e => "CONNECTION_OPEN" !== e.type && "VOICE_STATE_UPDATES" !== e.type), this.waitFor(A.default, T.default, D.default, I.default, N.default)
                }
                getChannelId(e) {
                    var t, n;
                    let i = !(arguments.length > 1) || void 0 === arguments[1] || arguments[1];
                    return e = String(e === O.ME ? null : null !== (t = null != e ? e : D.default.getGuildId()) && void 0 !== t ? t : null), i ? null !== (n = y[e]) && void 0 !== n ? n : V(e) : y[e]
                }
                getVoiceChannelId() {
                    return N.default.isSupported() ? r : null
                }
                getMostRecentSelectedTextChannelId(e) {
                    var t;
                    return null == e ? null : null !== (t = L[e]) && void 0 !== t ? t : null
                }
                getCurrentlySelectedChannelId(e) {
                    return null != e ? y[e] : a
                }
                getLastSelectedChannelId(e) {
                    return null != e ? P[e] : s
                }
                getLastSelectedChannels(e) {
                    return P[e]
                }
                getLastChannelFollowingDestination() {
                    return o
                }
            }
            G.displayName = "SelectedChannelStore";
            var H = new G(f.default, {
                CONNECTION_OPEN: function(e) {
                    i = e.sessionId, null != r && null == T.default.getChannel(r) && (r = null);
                    let t = x();
                    t && w()
                },
                OVERLAY_INITIALIZE: function(e) {
                    i = e.sessionId, r = e.selectedVoiceChannelId, y = {}, P = {}, a = e.selectedChannelId, y[e.selectedGuildId] = e.selectedChannelId, M(e.selectedGuildId, a), x()
                },
                CONNECTION_CLOSED: function() {
                    i = null
                },
                CHANNEL_SELECT: function(e) {
                    let {
                        guildId: t,
                        channelId: n
                    } = e;
                    if (void 0 === t) return !1;
                    null == n && (!(0, m.isInMainTabsExperiment)() || (0, g.shouldHandleNewPanelsRoute)(t) || (0, E.isOnGlobalPanels)()) && (n = V(t)), null != a && n !== a && (s = a), a = n, M(t, n), y[String(t)] !== n && (P[String(t)] = y[String(t)], y[String(t)] = a), w()
                },
                CHANNEL_CREATE: function(e) {
                    let {
                        channel: t
                    } = e;
                    switch (t.type) {
                        case O.ChannelTypes.GUILD_ANNOUNCEMENT:
                        case O.ChannelTypes.GUILD_TEXT:
                            let n = t.guild_id;
                            if (null != n && null == L[n] && (L[n] = t.id), null != n && null == y[n]) return y[n] = V(n), !0
                    }
                    return !1
                },
                CHANNEL_DELETE: B,
                CHANNEL_UPDATES: function(e) {
                    let {
                        channels: t
                    } = e;
                    for (let e of t) e.isScheduledForDeletion() && F(e.id, e.guild_id)
                },
                THREAD_DELETE: B,
                GUILD_CREATE: function(e) {
                    let {
                        guild: t
                    } = e;
                    if (null == y[t.id]) {
                        let e = V(t.id);
                        y[t.id] = e, M(t.id, e), w()
                    }
                },
                GUILD_DELETE: function(e) {
                    let {
                        guild: {
                            id: t,
                            unavailable: n
                        }
                    } = e;
                    if (r === y[t] && (r = null), n) return !1;
                    delete L[t], delete y[t], w()
                },
                VOICE_CHANNEL_SELECT: function(e) {
                    let {
                        channelId: t
                    } = e;
                    if (null == t) {
                        let e = T.default.getChannel(r),
                            t = null == e ? void 0 : e.guild_id;
                        null != t && t !== D.default.getGuildId() && y[t] === r && (y[t] = V(t))
                    }
                    r = t, w()
                },
                VOICE_STATE_UPDATES: function(e) {
                    let {
                        voiceStates: t
                    } = e;
                    return t.reduce((e, t) => {
                        var n, s, a;
                        if (t.sessionId === i) {
                            clearInterval(u);
                            let e = null === (n = T.default.getChannel(r)) || void 0 === n ? void 0 : n.getGuildId();
                            t.guildId !== e && null == t.channelId || (r = t.channelId), l = Date.now(), null != r && (u = setInterval(() => {
                                l = Date.now(), w()
                            }, 6e4)), w()
                        } else {
                            if (t.userId !== C.default.getId()) return e;
                            clearInterval(u), u = void 0, l = 0;
                            let n = null === (s = T.default.getChannel(r)) || void 0 === s ? void 0 : s.getGuildId(),
                                i = null === (a = T.default.getChannel(t.channelId)) || void 0 === a ? void 0 : a.getGuildId();
                            null != n && i === n && (r = null), w()
                        }
                        return !0
                    }, !1)
                },
                CHANNEL_FOLLOWER_CREATED: function(e) {
                    let {
                        channelId: t,
                        guildId: n
                    } = e;
                    (null == o || t !== o.channelId) && (o = {
                        channelId: t,
                        guildId: n
                    }, w())
                },
                LOGOUT: function() {
                    y = {}, a = null, s = void 0, L = {}, o = {}, r = null, p.default.remove(b)
                }
            })
        },
        162771: function(e, t, n) {
            "use strict";
            n.r(t), n.d(t, {
                default: function() {
                    return g
                }
            });
            var i = n("446674"),
                s = n("913144"),
                a = n("982527");
            n("21121");
            var o = n("393414"),
                r = n("271938"),
                l = n("305961"),
                u = n("49111");
            let d = null,
                c = null,
                h = {};

            function p() {
                null != d && null == l.default.getGuild(d) && null == a.default.getRequest(d) && (d = null), null != c && null == l.default.getGuild(c) && null == a.default.getRequest(c) && (c = null), f(d)
            }

            function f(e) {
                null != e && (h[e] = Date.now())
            }

            function m(e) {
                let t = !1;
                return delete h[e], c === e && (c = null, t = !0), d === e && (Object.values(l.default.getGuilds()).find(t => t.id !== e), d = null, (0, o.replaceWith)(u.Routes.ME), t = !0), t
            }
            class E extends i.default.PersistedStore {
                initialize(e) {
                    var t, n, i;
                    this.mustEmitChanges(e => "CONNECTION_OPEN" !== e.type), this.waitFor(l.default, r.default), h = null !== (t = null == e ? void 0 : e.selectedGuildTimestampMillis) && void 0 !== t ? t : {}, d = null !== (n = null == e ? void 0 : e.selectedGuildId) && void 0 !== n ? n : null, c = null !== (i = null == e ? void 0 : e.lastSelectedGuildId) && void 0 !== i ? i : null
                }
                getState() {
                    return {
                        selectedGuildTimestampMillis: h,
                        selectedGuildId: d,
                        lastSelectedGuildId: c
                    }
                }
                getGuildId() {
                    return d
                }
                getLastSelectedGuildId() {
                    return c
                }
                getLastSelectedTimestamp(e) {
                    return d === e ? -1 : h[e]
                }
            }
            E.displayName = "SelectedGuildStore", E.persistKey = "SelectedGuildStore";
            var g = new E(s.default, {
                CONNECTION_OPEN: p,
                OVERLAY_INITIALIZE: function(e) {
                    d = e.selectedGuildId, c = void 0, p()
                },
                CHANNEL_SELECT: function(e) {
                    let {
                        guildId: t
                    } = e;
                    if (d === t) return !1;
                    f(d), f(t), null != t && (c = t), d = t
                },
                GUILD_MEMBER_REMOVE: function(e) {
                    let {
                        guildId: t,
                        user: n
                    } = e;
                    return n.id === r.default.getId() && m(t)
                },
                GUILD_DELETE: function(e) {
                    let {
                        guild: {
                            id: t,
                            unavailable: n
                        }
                    } = e;
                    return !0 !== n && m(t)
                },
                LOGOUT: function() {
                    d = null, c = null
                }
            })
        },
        235660: function(e, t, n) {
            "use strict";
            n.r(t), n.d(t, {
                default: function() {
                    return h
                }
            });
            var i = n("917351"),
                s = n.n(i),
                a = n("446674"),
                o = n("913144"),
                r = n("271938");
            let l = Object.freeze([]),
                u = {};

            function d(e) {
                u = {}, e.sessions.forEach(e => {
                    u[e.sessionId] = e
                })
            }
            class c extends a.default.Store {
                initialize() {
                    this.waitFor(r.default)
                }
                getSessions() {
                    return u
                }
                getSession() {
                    let e = r.default.getSessionId();
                    return null != e ? this.getSessionById(e) : null
                }
                getRemoteActivities() {
                    let e = r.default.getSessionId(),
                        t = s.find(u, t => t.active && t.sessionId !== e);
                    return null != t ? t.activities : l
                }
                getSessionById(e) {
                    return u[e]
                }
                getActiveSession() {
                    return s.find(u, e => {
                        let {
                            active: t
                        } = e;
                        return t
                    })
                }
            }
            c.displayName = "SessionsStore";
            var h = new c(o.default, {
                CONNECTION_OPEN: d,
                SESSIONS_REPLACE: d
            })
        },
        123647: function(e, t, n) {
            "use strict";
            n.r(t), n.d(t, {
                default: function() {
                    return r
                }
            });
            var i = n("446674"),
                s = n("913144");
            let a = n("49111").VideoQualityMode.AUTO;
            class o extends i.default.Store {
                get mode() {
                    return a
                }
            }
            o.displayName = "VideoQualityModeStore";
            var r = new o(s.default, {
                SET_CHANNEL_VIDEO_QUALITY_MODE: function(e) {
                    a = e.mode
                }
            })
        },
        800762: function(e, t, n) {
            "use strict";
            let i, s;
            n.r(t), n.d(t, {
                default: function() {
                    return D
                }
            }), n("808653"), n("222007");
            var a = n("917351"),
                o = n.n(a),
                r = n("446674"),
                l = n("913144"),
                u = n("628454"),
                d = n("49111"),
                c = n("99795");
            let h = 0,
                p = 0,
                f = {},
                m = {},
                E = {},
                g = {},
                S = {};

            function _(e, t) {
                return "".concat(e, ":").concat(t)
            }

            function v(e, t) {
                let n = e[t];
                return null == n && (n = {}, e[t] = n), n
            }

            function C(e) {
                var t;
                let n = null !== (t = f[d.ME]) && void 0 !== t ? t : {},
                    i = {};
                o.each(n, (t, n) => {
                    t.channelId !== e && (i[n] = t)
                }), f[d.ME] = i
            }

            function T(e, t, n) {
                let i = v(f, null != e ? e : d.ME),
                    s = i[t],
                    a = n(s);
                return s === a ? [!1, a, s] : (null != s && (delete i[t], null != s.channelId && (delete v(m, s.channelId)[t], delete v(E, s.channelId)[t]), null != s.sessionId && delete v(g, t)[s.sessionId]), null != a && (i[t] = a, null != a.channelId && (v(m, a.channelId)[t] = a, a.selfVideo && (v(E, a.channelId)[t] = a)), null != a.sessionId && (v(g, t)[a.sessionId] = a)), [!0, a, s])
            }

            function I(e, t) {
                return T(e, t.userId, e => {
                    if (null == t.channelId) return null;
                    {
                        let n = {
                            channelId: t.channelId,
                            deaf: t.deaf,
                            mute: t.mute,
                            requestToSpeakTimestamp: t.requestToSpeakTimestamp,
                            selfDeaf: t.selfDeaf,
                            selfMute: t.selfMute,
                            selfStream: t.selfStream,
                            selfVideo: t.selfVideo,
                            sessionId: t.sessionId,
                            suppress: t.suppress,
                            userId: t.userId
                        };
                        return null != e ? e.merge(n) : new u.default(n)
                    }
                })
            }

            function A(e) {
                let {
                    guild: t
                } = e;
                o.forEach(f[t.id], e => {
                    T(t.id, e.userId, () => null)
                }), delete f[t.id]
            }
            class N extends r.default.Store {
                getAllVoiceStates() {
                    return f
                }
                getVoiceStateVersion() {
                    return p
                }
                getVoiceStates(e) {
                    return v(f, null != e ? e : d.ME)
                }
                getVoiceStatesForChannel(e) {
                    return v(m, e)
                }
                getVideoVoiceStatesForChannel(e) {
                    return v(E, e)
                }
                getVoiceState(e, t) {
                    return this.getVoiceStates(e)[t]
                }
                getVoiceStateForChannel(e) {
                    var t;
                    let n = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : i;
                    return null === (t = v(m, e)) || void 0 === t ? void 0 : t[n]
                }
                getVoiceStateForUser(e) {
                    return Object.values(v(g, e))[0]
                }
                getVoiceStateForSession(e, t) {
                    var n;
                    return null != t ? null === (n = v(g, e)) || void 0 === n ? void 0 : n[t] : null
                }
                getUserVoiceChannelId(e, t) {
                    var n;
                    return null === (n = this.getVoiceState(e, t)) || void 0 === n ? void 0 : n.channelId
                }
                getCurrentClientVoiceChannelId(e) {
                    let t = this.getVoiceState(e, i);
                    return null != t && null != s && t.sessionId === s ? t.channelId : null
                }
                isCurrentClientInVoiceChannel() {
                    var e;
                    return null != s && (null === (e = g[i]) || void 0 === e ? void 0 : e[s]) != null
                }
                isInChannel(e) {
                    let t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : i;
                    if (null == e) return !1;
                    let n = this.getVoiceStateForChannel(e, t);
                    return null != n && (t !== i || null != s && n.sessionId === s)
                }
                hasVideo(e) {
                    return Object.values(v(E, e)).length > 0
                }
                getVoicePlatformForChannel(e, t) {
                    var n, a;
                    let o = null != s && (null === (a = g[i]) || void 0 === a ? void 0 : null === (n = a[s]) || void 0 === n ? void 0 : n.channelId);
                    return t === i && e === o ? c.VoicePlatforms.DESKTOP : S[_(t, e)]
                }
                get userHasBeenMovedVersion() {
                    return h
                }
            }
            N.displayName = "VoiceStateStore";
            var D = new N(l.default, {
                CONNECTION_OPEN: function(e) {
                    let {
                        user: t,
                        sessionId: n
                    } = e;
                    f = {}, m = {}, g = {}, E = {}, i = t.id, s = n
                },
                OVERLAY_INITIALIZE: function(e) {
                    let {
                        voiceStates: t,
                        user: n,
                        sessionId: a
                    } = e;
                    for (let [e, n] of(f = {}, m = {}, g = {}, E = {}, Object.entries(t)))
                        for (let [t, i] of Object.entries(n)) T(e, t, () => new u.default(i));
                    i = n.id, s = a
                },
                VOICE_CHANNEL_SELECT: function(e) {
                    let {
                        guildId: t,
                        channelId: n
                    } = e, [s] = T(t, i, e => null == e ? void 0 : e.set("channelId", n));
                    return s
                },
                VOICE_STATE_UPDATES: function(e) {
                    let {
                        voiceStates: t
                    } = e;
                    return t.reduce((e, t) => {
                        let [n, i, a] = I(t.guildId, t);
                        return n ? (t.sessionId === s && null != i && null != a && a.channelId !== i.channelId && (h += 1), p++, !0) : e
                    }, !1)
                },
                GUILD_DELETE: A,
                GUILD_CREATE: A,
                CHANNEL_DELETE: function(e) {
                    let {
                        channel: t
                    } = e;
                    C(t.id)
                },
                CALL_DELETE: function(e) {
                    let {
                        channelId: t
                    } = e;
                    C(t)
                },
                PASSIVE_UPDATE_V1: function(e) {
                    var t, n;
                    let i = !1,
                        s = Object.keys(null !== (t = f[e.guildId]) && void 0 !== t ? t : {}),
                        a = new Set(s);
                    for (let t of null !== (n = e.voiceStates) && void 0 !== n ? n : []) {
                        let [n] = I(e.guildId, t);
                        i = i || n, a.delete(t.userId)
                    }
                    for (let t of a) T(e.guildId, t, () => null), i = !0;
                    return i && p++, i
                },
                RTC_CONNECTION_PLATFORM: function(e) {
                    let {
                        userId: t,
                        channelId: n,
                        platform: i
                    } = e;
                    S[_(t, n)] = i
                }
            })
        },
        677225: function(e, t, n) {
            "use strict";
            n.r(t), n.d(t, {
                default: function() {
                    return b
                }
            }), n("222007"), n("424973");
            var i = n("917351"),
                s = n.n(i),
                a = n("446674"),
                o = n("862337"),
                r = n("913144"),
                l = n("157552"),
                u = n("71313"),
                d = n("190017"),
                c = n("299285"),
                h = n("686470"),
                p = n("535974"),
                f = n("98328"),
                m = n("964889"),
                E = n("602043");
            let g = new Set,
                S = {},
                _ = new Set,
                v = {},
                C = new Set,
                T = {},
                I = new o.Timeout;

            function A(e) {
                I.start(e + 6e5 * Math.random(), l.fetchBranches)
            }

            function N() {
                if (!(0, E.isSupportedPlatform)()) return !1;
                let e = h.default.entitledBranchIds,
                    t = [];
                for (let n of e) !T.hasOwnProperty(n) && (T[n] = null, t.push(n));
                if (0 === t.length) return !1;
                r.default.wait(() => l.fetchBranches(t))
            }

            function D(e, t) {
                if (null != S[t] && f.default.shouldBeInstalled(e, t)) {
                    let n = S[t],
                        i = n.manifestIds,
                        a = p.default.getState(e, t);
                    null != a && a.shouldPatch && (a.buildId !== n.id || !s.isEqual(a.manifestIds, i)) && r.default.wait(() => {
                        let s = c.default.getApplication(e);
                        null != s ? (C.delete((0, m.getComboId)(e, t)), (0, d.updateApplication)(s, t, n.id, i, !0)) : C.add((0, m.getComboId)(e, t))
                    })
                }
            }

            function O() {
                I.stop()
            }
            class R extends a.default.Store {
                initialize() {
                    this.syncWith([h.default], N), this.waitFor(p.default, h.default, c.default)
                }
                getTargetBuildId(e, t) {
                    return null == S[t] ? null : S[t].id
                }
                getTargetManifests(e, t) {
                    return null == S[t] ? null : S[t].manifestIds
                }
                hasNoBuild(e, t) {
                    return _.has(t)
                }
                isFetching(e, t) {
                    return g.has(t)
                }
                needsToFetchBuildSize(e) {
                    return !v.hasOwnProperty(e)
                }
                getBuildSize(e) {
                    return v[e]
                }
            }
            R.displayName = "ApplicationBuildStore";
            var b = new R(r.default, {
                CONNECTION_OPEN: function() {
                    return A(216e5), N()
                },
                GAMES_DATABASE_UPDATE: function() {
                    if (!(0, E.isSupportedPlatform)()) return !1;
                    for (let e of C) {
                        let {
                            applicationId: t,
                            branchId: n
                        } = (0, m.convertComboId)(e), i = c.default.getApplication(t);
                        null != i && (C.delete(e), D(t, n))
                    }
                },
                APPLICATION_BUILD_FETCH_START: function(e) {
                    let {
                        branchId: t
                    } = e;
                    g.add(t)
                },
                APPLICATION_BUILD_FETCH_SUCCESS: function(e) {
                    let {
                        applicationId: t,
                        branchId: n,
                        locale: i,
                        build: s
                    } = e;
                    g.delete(n);
                    let a = s.manifests.map(e => {
                            let {
                                id: t
                            } = e;
                            return t
                        }),
                        o = s.id;
                    _.delete(n), S[n] = {
                        id: o,
                        applicationId: t,
                        branchId: n,
                        locale: i,
                        manifestIds: a
                    }, D(t, n)
                },
                APPLICATION_BUILD_NOT_FOUND: function(e) {
                    let {
                        branchId: t
                    } = e;
                    g.delete(t), _.add(t)
                },
                APPLICATION_BUILD_SIZE_FETCH_START: function(e) {
                    let {
                        buildId: t
                    } = e;
                    !v.hasOwnProperty(t) && (v[t] = null)
                },
                APPLICATION_BUILD_SIZE_FETCH_SUCCESS: function(e) {
                    let {
                        buildId: t,
                        sizeKB: n
                    } = e;
                    v[t] = n
                },
                APPLICATION_BUILD_SIZE_FETCH_FAIL: function(e) {
                    let {
                        buildId: t
                    } = e;
                    null == v[t] && delete v[t]
                },
                APPLICATION_BRANCHES_FETCH_SUCCESS: function(e) {
                    let {
                        branches: t
                    } = e, n = {};
                    for (let e in h.default.libraryApplications) {
                        let t = h.default.libraryApplications[e];
                        n[t.branchId] = t
                    }
                    for (let e of t) {
                        let {
                            id: t,
                            liveBuildId: i
                        } = e, s = T[t];
                        if (i !== s) {
                            let e = n[t];
                            null != e && r.default.wait(() => u.fetchLiveBuild(e.id, e.branchId, !0))
                        }
                        T[t] = i
                    }
                    A(216e5)
                },
                APPLICATION_BRANCHES_FETCH_FAIL: function() {
                    A(6e5)
                },
                CONNECTION_CLOSED: O,
                LOGOUT: O,
                SKU_PURCHASE_SUCCESS: function(e) {
                    let {
                        entitlements: t
                    } = e;
                    if (!(0, E.isSupportedPlatform)()) return !1;
                    let n = new Set;
                    for (let e of t) n.add(e.application_id);
                    for (let e in h.default.libraryApplications) {
                        let t = h.default.libraryApplications[e];
                        n.has(t.id) && (0, m.isUserEntitledToLibraryApplication)(t) && r.default.wait(() => u.fetchLiveBuild(t.id, t.branchId))
                    }
                }
            })
        },
        552712: function(e, t, n) {
            "use strict";
            let i;
            n.r(t), n.d(t, {
                default: function() {
                    return T
                }
            }), n("222007");
            var s = n("446674"),
                a = n("913144"),
                o = n("915639"),
                r = n("137406"),
                l = n("546463");
            let u = new Set,
                d = new Set,
                c = {},
                h = {},
                p = {};

            function f(e) {
                c[e.id] = r.default.createFromServer(e)
            }

            function m(e) {
                u.delete(e.id), d.delete(e.id), f(e)
            }

            function E(e) {
                f(e.sku), null != e.child_skus && e.child_skus.forEach(e => f(e)), null != e.alternative_skus && e.alternative_skus.forEach(e => f(e))
            }

            function g(e) {
                let {
                    storeListings: t
                } = e;
                for (let e of t) E(e)
            }

            function S(e) {
                let {
                    entitlements: t
                } = e;
                for (let e of t) null != e.sku && f(e.sku)
            }

            function _() {
                u = new Set, d = new Set, c = {}, h = {}, p = {}
            }

            function v() {
                if (i === o.default.locale) return !1;
                i = o.default.locale, _()
            }
            class C extends s.default.Store {
                initialize() {
                    this.waitFor(o.default, l.default), this.syncWith([o.default], v), i = o.default.locale
                }
                get(e) {
                    return c[e]
                }
                getForApplication(e) {
                    let t = h[e];
                    return null == t ? [] : Array.from(t).map(e => c[e])
                }
                isFetching(e) {
                    return u.has(e)
                }
                getSKUs() {
                    return c
                }
                didFetchingSkuFail(e) {
                    return d.has(e)
                }
            }
            C.displayName = "SKUStore";
            var T = new C(a.default, {
                STORE_LISTINGS_FETCH_SUCCESS: g,
                APPLICATION_STORE_DIRECTORY_FETCH_SUCCESS: g,
                STORE_LISTING_FETCH_SUCCESS: function(e) {
                    let {
                        storeListing: t
                    } = e;
                    E(t)
                },
                GIFT_CODE_RESOLVE_SUCCESS: function(e) {
                    let {
                        giftCode: t
                    } = e;
                    if (null == t.store_listing) return !1;
                    f(t.store_listing.sku)
                },
                SKU_FETCH_START: function(e) {
                    let {
                        skuId: t
                    } = e;
                    u.add(t)
                },
                SKU_FETCH_SUCCESS: function(e) {
                    let {
                        sku: t
                    } = e;
                    m(t)
                },
                SKU_FETCH_FAIL: function(e) {
                    let {
                        skuId: t
                    } = e;
                    u.delete(t), d.add(t)
                },
                SKUS_FETCH_SUCCESS: function(e) {
                    let {
                        guildId: t,
                        applicationId: n,
                        skus: i
                    } = e;
                    for (let e of i) m(e);
                    null != t && (p[t] = new Set(i.map(e => e.id))), null != n && (h[n] = new Set(i.map(e => e.id)))
                },
                ENTITLEMENTS_GIFTABLE_FETCH_SUCCESS: S,
                APPLICATION_STORE_CLEAR_DATA: _,
                APPLICATION_SUBSCRIPTIONS_FETCH_ENTITLEMENTS_SUCCESS: S,
                ENTITLEMENTS_FETCH_FOR_USER_SUCCESS: S
            })
        },
        316133: function(e, t, n) {
            "use strict";
            n.r(t), n.d(t, {
                getComparator: function() {
                    return C
                },
                default: function() {
                    return O
                }
            }), n("222007"), n("808653");
            var i = n("917351"),
                s = n.n(i),
                a = n("446674"),
                o = n("407846"),
                r = n("913144"),
                l = n("766274"),
                u = n("271938"),
                d = n("42203"),
                c = n("26989"),
                h = n("697218"),
                p = n("800762"),
                f = n("158998"),
                m = n("49111");
            let E = Object.freeze([]),
                g = {};

            function S(e) {
                let t = g[e];
                return null == t && (t = new I(e), g[e] = t), t
            }

            function _(e, t) {
                return c.default.getMember(e, t.id)
            }

            function v(e, t, n) {
                var i;
                let s = null !== (i = null == t ? void 0 : t.nick) && void 0 !== i ? i : f.default.getName(n);
                return {
                    member: t,
                    comparator: C(e, s)
                }
            }

            function C(e, t) {
                return "".concat(e.selfStream ? "\x00" : "\x01").concat(t.toLowerCase(), "\x00").concat(e.userId)
            }

            function T(e, t, n) {
                let i = h.default.getUser(n),
                    s = null == i;
                null == i && (i = new l.default({
                    id: n,
                    username: "...",
                    discriminator: n.slice(-5, -1)
                }));
                let {
                    member: a,
                    comparator: o
                } = function(e, t, n) {
                    let i = _(e, t);
                    return v(n, i, t)
                }(t, i, e), r = {
                    voiceState: e,
                    user: i,
                    member: a,
                    comparator: o,
                    nick: null == a ? void 0 : a.nick
                };
                return s && (r._isPlaceholder = !0), r
            }
            class I {
                updateVoiceState(e) {
                    if (null != this._pending) return this._pending.add(e), !1;
                    let t = p.default.getVoiceState(this.guildId, e),
                        n = this._voiceStates.get(e),
                        i = h.default.getUser(e);
                    if (null != t && null != i) {
                        if (null == n) return this._voiceStates.set(e, T(t, this.guildId, e)), !0;
                        if (n.voiceState !== t) {
                            var s;
                            let a = _(this.guildId, i),
                                o = null !== (s = null == a ? void 0 : a.nick) && void 0 !== s ? s : f.default.getName(i);
                            return this._voiceStates.set(e, {
                                ...n,
                                member: a,
                                comparator: C(t, o),
                                nick: o,
                                voiceState: t
                            }), !0
                        }
                    } else if (null != n) return this._voiceStates.delete(e), !0;
                    return !1
                }
                updateMember(e) {
                    if (null != this._pending) return this._pending.add(e), !1;
                    let t = this._voiceStates.get(e),
                        n = h.default.getUser(e);
                    if (null != t && null != n) {
                        var i, s;
                        let a = _(this.guildId, n);
                        if ((null == a ? void 0 : a.nick) !== (null === (i = t.member) || void 0 === i ? void 0 : i.nick) || (null == a ? void 0 : a.avatar) !== (null === (s = t.member) || void 0 === s ? void 0 : s.avatar)) {
                            let {
                                comparator: i
                            } = v(t.voiceState, a, n);
                            return this._voiceStates.set(e, {
                                ...t,
                                member: a,
                                comparator: i,
                                nick: null == a ? void 0 : a.nick
                            }), !0
                        }
                    }
                    return !1
                }
                updateUsers() {
                    return null == this._pending && this._voiceStates.values().reduce((e, t) => {
                        let n = h.default.getUser(t.user.id);
                        return null != n && t.user !== n ? (this._voiceStates.set(n.id, T(t.voiceState, this.guildId, n.id)), !0) : e
                    }, !1)
                }
                getUserIds() {
                    return this.processPending(), this._voiceStates.keys()
                }
                getVoiceStates() {
                    return this.processPending(), this._voiceStates.indexes()
                }
                getVoiceStatesForChannel(e) {
                    this.processPending();
                    let t = this._voiceStates.values(e);
                    return 0 === t.length ? E : t
                }
                countVoiceStatesForChannel(e) {
                    return this.processPending(), this._voiceStates.size(e)
                }
                getVersion() {
                    return this.processPending(), this._voiceStates.version
                }
                processPending() {
                    if (null != this._pending) {
                        let e = this._pending;
                        this._pending = void 0, e.forEach(e => this.updateVoiceState(e))
                    }
                }
                constructor(e) {
                    this._pending = new Set, this._voiceStates = new o.default(e => {
                        let {
                            voiceState: {
                                channelId: t
                            }
                        } = e;
                        return null != t ? [t] : []
                    }, e => {
                        let {
                            comparator: t
                        } = e;
                        return t
                    }), this.guildId = e
                }
            }

            function A() {
                return s.reduce(g, (e, t) => t.updateUsers() || e, !1)
            }

            function N() {
                g = {};
                let e = p.default.getAllVoiceStates();
                Object.keys(e).forEach(t => {
                    Object.keys(e[t]).forEach(e => {
                        S(null != t ? t : m.ME).updateVoiceState(e)
                    })
                })
            }
            class D extends a.default.Store {
                initialize() {
                    N(), this.waitFor(u.default, h.default, c.default, p.default), this.syncWith([h.default], A)
                }
                getVoiceStates(e) {
                    return S(null != e ? e : m.ME).getVoiceStates()
                }
                getAllVoiceStates() {
                    return g
                }
                getVoiceStatesForChannel(e) {
                    let t = e.getGuildId(),
                        n = e.id;
                    return S(null != t ? t : m.ME).getVoiceStatesForChannel(n)
                }
                getVoiceStatesForChannelAlt(e, t) {
                    return S(null != t ? t : m.ME).getVoiceStatesForChannel(e)
                }
                countVoiceStatesForChannel(e) {
                    let t = d.default.getChannel(e);
                    if (null == t) return 0;
                    let n = t.getGuildId();
                    return S(null != n ? n : m.ME).countVoiceStatesForChannel(e)
                }
                getVoiceStateVersion(e) {
                    return S(null != e ? e : m.ME).getVersion()
                }
            }
            D.displayName = "SortedVoiceStateStore";
            var O = new D(r.default, {
                CONNECTION_OPEN: function() {
                    g = {}
                },
                OVERLAY_INITIALIZE: function() {
                    N()
                },
                VOICE_CHANNEL_SELECT: function(e) {
                    let {
                        guildId: t
                    } = e, n = u.default.getId();
                    return null != n && S(null != t ? t : m.ME).updateVoiceState(n)
                },
                VOICE_STATE_UPDATES: function(e) {
                    let {
                        voiceStates: t
                    } = e;
                    return t.reduce((e, t) => {
                        let {
                            guildId: n,
                            userId: i
                        } = t;
                        return S(null != n ? n : m.ME).updateVoiceState(i) || e
                    }, !1)
                },
                GUILD_MEMBER_UPDATE: function(e) {
                    let {
                        guildId: t,
                        user: n
                    } = e;
                    return S(t).updateMember(n.id)
                },
                GUILD_CREATE: function(e) {
                    let {
                        guild: t
                    } = e;
                    delete g[t.id]
                },
                GUILD_DELETE: function(e) {
                    let {
                        guild: t
                    } = e;
                    delete g[t.id]
                },
                PASSIVE_UPDATE_V1: function(e) {
                    var t, n;
                    let i = !1,
                        s = new Set(null === (t = g[e.guildId]) || void 0 === t ? void 0 : t.getUserIds()),
                        a = new Set(null === (n = e.voiceStates) || void 0 === n ? void 0 : n.map(e => e.userId)),
                        o = new Set([...s, ...a]);
                    for (let t of o) i = S(e.guildId).updateVoiceState(t) || i;
                    for (let t of a) s.has(t) && (i = S(e.guildId).updateMember(t) || i);
                    return i
                }
            })
        },
        316661: function(e, t, n) {
            "use strict";
            n.r(t), n.d(t, {
                default: function() {
                    return l
                }
            });
            var i = n("446674"),
                s = n("913144");
            let a = null,
                o = !1;
            class r extends i.default.Store {
                getLastProgress() {
                    return a
                }
                isRunning() {
                    return o
                }
            }
            r.displayName = "DispatchApplicationLaunchSetupStore";
            var l = new r(s.default, {
                DISPATCH_APPLICATION_LAUNCH_SETUP_START: function() {
                    o = !0
                },
                DISPATCH_APPLICATION_INSTALL_SCRIPTS_PROGRESS_UPDATE: function(e) {
                    let {
                        progress: t,
                        total: n,
                        name: i
                    } = e;
                    a = {
                        progress: t,
                        total: n,
                        name: i
                    }
                },
                DISPATCH_APPLICATION_LAUNCH_SETUP_COMPLETE: function() {
                    a = null, o = !1
                }
            })
        },
        535974: function(e, t, n) {
            "use strict";
            n.r(t), n.d(t, {
                default: function() {
                    return U
                }
            }), n("222007"), n("70102"), n("860677");
            var i, s = n("917351"),
                a = n.n(s),
                o = n("446674"),
                r = n("913144"),
                l = n("49671"),
                u = n("70513"),
                d = n("271938"),
                c = n("686470"),
                h = n("645672"),
                p = n("964889"),
                f = n("773336"),
                m = n("602043"),
                E = n("352326"),
                g = n("98328"),
                S = n("49111");
            (i || (i = {})).DISPATCH_APPLICATION_PROGRESS = "dispatch_application_progress";
            let _ = {},
                v = "file://",
                C = !1,
                T = 0,
                I = 0,
                A = 0,
                N = [],
                D = [],
                O = [],
                R = !1;

            function b(e) {
                return e.type === S.LocalDispatchApplicationStates.INSTALLING || e.type === S.LocalDispatchApplicationStates.UPDATING || e.type === S.LocalDispatchApplicationStates.REPAIRING ? e.networkProgress : null
            }

            function y(e) {
                return e.type === S.LocalDispatchApplicationStates.INSTALLING || e.type === S.LocalDispatchApplicationStates.UPDATING || e.type === S.LocalDispatchApplicationStates.REPAIRING ? e.diskProgress : null
            }

            function P(e) {
                return e.type === S.LocalDispatchApplicationStates.INSTALLING || e.type === S.LocalDispatchApplicationStates.UPDATING || e.type === S.LocalDispatchApplicationStates.REPAIRING ? e.readerProgress : null
            }
            let L = a.throttle(function(e) {
                    D = (D = [{
                        bytes: e,
                        timestamp: Date.now()
                    }, ...D]).slice(0, 200)
                }, 200),
                k = a.throttle(function(e) {
                    let t = Date.now(),
                        n = t - 6e4;
                    N = (N = [{
                        bytes: e,
                        timestamp: t
                    }, ...N]).slice(0, 200).filter(e => {
                        let {
                            timestamp: t
                        } = e;
                        return t >= n
                    })
                }, 200),
                w = a.throttle(function(e) {
                    O = (O = [{
                        bytes: e,
                        timestamp: Date.now()
                    }, ...O]).slice(0, 200)
                }, 200);

            function V(e, t, n) {
                let i = n(_[t]),
                    s = n(e[t]);
                return null != i && null != s && 0 !== i ? Math.max(s - i, 0) : 0
            }
            class M extends o.default.Store {
                initialize() {
                    this.waitFor(d.default)
                }
                getState(e, t) {
                    let n = (0, p.getComboId)(e, t);
                    return _[n]
                }
                isUpToDate(e, t) {
                    let n = _[(0, p.getComboId)(e, t)];
                    return null != n && n.type === S.LocalDispatchApplicationStates.UP_TO_DATE
                }
                shouldPatch(e, t) {
                    let n = _[(0, p.getComboId)(e, t)];
                    return null != n && !0 === n.shouldPatch
                }
                isInstalled(e, t) {
                    let n = _[(0, p.getComboId)(e, t)];
                    return null != n ? n.type !== S.LocalDispatchApplicationStates.UNINSTALLING : g.default.shouldBeInstalled(e, t)
                }
                supportsCloudSync(e, t) {
                    null == t && (t = e);
                    let n = _[(0, p.getComboId)(e, t)];
                    return null != n && null != n.storage && !!n.storage.sync
                }
                isLaunchable(e, t) {
                    if (!(0, m.isSupportedPlatform)()) return !1;
                    let n = _[(0, p.getComboId)(e, t)];
                    return null != n && n.type === S.LocalDispatchApplicationStates.UP_TO_DATE && null != n.launchOptions && 0 !== n.launchOptions.length
                }
                getDefaultLaunchOption(e, t) {
                    let n = _[(0, p.getComboId)(e, t)];
                    if (null == n) return null;
                    let {
                        defaultLaunchOptionId: i,
                        launchOptions: s
                    } = n;
                    return null == i || null == s ? null : s[i]
                }
                getLaunchOptions(e, t) {
                    let n = _[(0, p.getComboId)(e, t)];
                    return null == n || null == n.launchOptions ? [] : Object.values(n.launchOptions)
                }
                getHistoricalTotalBytesRead() {
                    return N
                }
                getHistoricalTotalBytesDownloaded() {
                    return D
                }
                getHistoricalTotalBytesWritten() {
                    return O
                }
                whenInitialized(e) {
                    this.addConditionalChangeListener(() => {
                        if (C) return setImmediate(e), !1
                    })
                }
            }
            M.displayName = "DispatchApplicationStore";
            var U = new M(r.default, {
                CONNECTION_OPEN: function() {
                    C = !1
                },
                DISPATCH_APPLICATION_STATE_UPDATE: function(e) {
                    let {
                        state: t
                    } = e;
                    C = !0;
                    let n = {},
                        i = t.applications,
                        s = null != t.currentTask ? t.currentTask.branchId : null,
                        o = !1;
                    for (let e in i)
                        for (let t in i[e]) {
                            let d = (0, p.getComboId)(e, t);
                            if (n[d] = function(e) {
                                    let {
                                        build_id: t,
                                        target_build_id: n,
                                        manifest_ids: i,
                                        target_manifest_ids: s,
                                        application_id: o,
                                        branch_id: r,
                                        launch_commands: u,
                                        launch_options: d,
                                        storage: c,
                                        install_path: p,
                                        installed_size: m,
                                        repairing: E
                                    } = e, {
                                        should_patch: g
                                    } = e;
                                    switch (null == g && (g = !0), e.state.type) {
                                        case S.DispatchApplicationStates.COMPLETE: {
                                            let e;
                                            let C = {},
                                                T = null;
                                            if (E) e = S.LocalDispatchApplicationStates.REPAIRING;
                                            else if (null == t) e = S.LocalDispatchApplicationStates.INSTALL_REQUIRED;
                                            else if (g && (t !== n || null != i && 0 !== a.difference(i, s).length)) e = S.LocalDispatchApplicationStates.UPDATE_REQUIRED;
                                            else if (e = S.LocalDispatchApplicationStates.UP_TO_DATE, null != p) {
                                                let e = l.default.fileManager.join(p, "content"),
                                                    t = (0, h.getBuildPlatform)();
                                                if (null != d && 0 !== d.length) {
                                                    var _;
                                                    if (t === S.BuildPlatformTypes.WIN64 && (_ = t, !d.some(e => e.platforms.includes(_)))) t = S.BuildPlatformTypes.WIN32;
                                                    for (let n of d)
                                                        if (n.platforms.includes(t)) {
                                                            let t;
                                                            let {
                                                                executable: i,
                                                                name: s,
                                                                working_dir: a
                                                            } = n, o = l.default.fileManager.join(e, i);
                                                            (0, f.isMac)() && !o.startsWith(v) && (o = "".concat(v).concat(o)), t = null != a ? l.default.fileManager.join(e, a) : l.default.fileManager.dirname(o), C[s] = {
                                                                ...n,
                                                                id: s,
                                                                fullExecutablePath: o,
                                                                fullWorkingDir: t
                                                            }, null == T && (T = s)
                                                        }
                                                } else if (null != u) {
                                                    t === S.BuildPlatformTypes.WIN64 && null == u[t] && (t = S.BuildPlatformTypes.WIN32);
                                                    let n = u[t];
                                                    if (null != n) {
                                                        let {
                                                            executable: i
                                                        } = n, s = "Default";
                                                        C[s] = {
                                                            ...n,
                                                            name: s,
                                                            id: s,
                                                            fullExecutablePath: l.default.fileManager.join(e, i),
                                                            fullWorkingDir: e,
                                                            platforms: [t]
                                                        }, T = s
                                                    }
                                                }
                                            }
                                            return {
                                                type: e,
                                                applicationId: o,
                                                branchId: r,
                                                buildId: t,
                                                manifestIds: i,
                                                targetBuildId: n,
                                                targetManifestIds: s,
                                                installPath: p,
                                                installedSize: m,
                                                launchOptions: C,
                                                defaultLaunchOptionId: T,
                                                shouldPatch: g,
                                                storage: c
                                            }
                                        }
                                        case S.DispatchApplicationStates.TRANSITION: {
                                            let a;
                                            let {
                                                stage: l,
                                                disk_progress: u,
                                                network_progress: d,
                                                reader_progress: c,
                                                progress: h,
                                                total: f,
                                                paused: _
                                            } = e.state, v = l.type;
                                            return {
                                                type: a = v === S.DispatchApplicationStages.UNINSTALLING ? S.LocalDispatchApplicationStates.UNINSTALLING : E ? S.LocalDispatchApplicationStates.REPAIRING : null == t ? S.LocalDispatchApplicationStates.INSTALLING : S.LocalDispatchApplicationStates.UPDATING,
                                                stage: v,
                                                applicationId: o,
                                                branchId: r,
                                                buildId: t,
                                                manifestIds: i,
                                                targetBuildId: n,
                                                targetManifestIds: s,
                                                installPath: p,
                                                installedSize: m,
                                                diskProgress: u,
                                                networkProgress: d,
                                                readerProgress: c,
                                                progress: h,
                                                total: f,
                                                paused: _,
                                                shouldPatch: g
                                            }
                                        }
                                    }
                                    throw Error("Invalid Dispatch State. state=".concat(e.state.type))
                                }(i[e][t]), null != _[d]) {
                                let e = V(n, d, b);
                                e > 0 && L(T += e);
                                let i = V(n, d, y);
                                i > 0 && w(I += i);
                                let a = V(n, d, P);
                                if (a > 0 && k(A += a), s === t) {
                                    let e = n[d];
                                    if (!0 !== e.paused && (e.type === S.LocalDispatchApplicationStates.UNINSTALLING || e.type === S.LocalDispatchApplicationStates.INSTALLING || e.type === S.LocalDispatchApplicationStates.UPDATING)) switch (e.stage) {
                                        case S.DispatchApplicationStages.PATCHING:
                                        case S.DispatchApplicationStages.FINALIZING:
                                        case S.DispatchApplicationStages.VERIFYING:
                                        case S.DispatchApplicationStages.REPAIRING:
                                        case S.DispatchApplicationStages.POST_INSTALL_SCRIPTS:
                                            u.default.setProgress("dispatch_application_progress", (0, p.calculateProgressPercentage)(e.progress, e.total) / 100), o = !0
                                    }
                                }
                            }
                            if (!R) {
                                let i = l.default.fileManager.dirname(n[d].installPath);
                                g.default.getInstallationPath(e, t) !== i && r.default.wait(() => {
                                    r.default.dispatch({
                                        type: "DISPATCH_APPLICATION_ADD_TO_INSTALLATIONS",
                                        applicationId: e,
                                        branchId: t,
                                        installationPath: i
                                    })
                                }), -1 === E.default.getQueuePosition(e, t) && (n[d].type === S.LocalDispatchApplicationStates.INSTALLING || n[d].type === S.LocalDispatchApplicationStates.UPDATING) && c.default.hasApplication(e, t) && g.default.shouldBeInstalled(e, t) && r.default.wait(() => {
                                    r.default.dispatch({
                                        type: "DISPATCH_APPLICATION_UPDATE",
                                        applicationId: e,
                                        branchId: t,
                                        automatic: !0
                                    })
                                })
                            }
                        }!o && "dispatch_application_progress" === u.default.taskID && u.default.clearProgress("dispatch_application_progress"), _ = n, R = !0
                }
            })
        },
        352326: function(e, t, n) {
            "use strict";
            n.r(t), n.d(t, {
                default: function() {
                    return H
                }
            }), n("222007"), n("70102"), n("424973"), n("843762");
            var i, s, a, o, r = n("917351"),
                l = n.n(r),
                u = n("446674"),
                d = n("95410"),
                c = n("913144"),
                h = n("190017"),
                p = n("271938"),
                f = n("568307"),
                m = n("677225"),
                E = n("964889"),
                g = n("152723"),
                S = n("773336"),
                _ = n("535974"),
                v = n("49111");
            (a = i || (i = {})).INSTALL = "Install", a.REPAIR = "Repair", (o = s || (s = {})).PATCH = "Patch", o.REPAIR = "Repair";
            let C = [v.DispatchErrorCodes.AUTHENTICATION_FAILED, v.DispatchErrorCodes.NOT_ENTITLED],
                T = "DispatchManagerStore",
                I = [],
                A = [],
                N = !1,
                D = null,
                O = null,
                R = !1,
                b = new Map,
                y = !1,
                P = null;

            function L() {
                let e = {
                    queue: I,
                    paused: N,
                    userActions: Array.from(b)
                };
                d.default.set(T, e)
            }

            function k() {
                let e = I[0];
                if (null != e) {
                    var t, n;
                    let {
                        comboId: i,
                        action: s
                    } = e, {
                        applicationId: a,
                        branchId: o
                    } = (0, E.convertComboId)(i);
                    if (t = a, n = o, (null == D || D.applicationId !== t || D.branchId !== n) && (null == O || O.applicationId !== t || O.branchId !== n)) {
                        let e = p.default.getToken(),
                            t = p.default.getId();
                        if (null == e) throw Error("missing user token");
                        y = !g.default.setCurrentTask(a, o, s, t, e)
                    }
                }
            }

            function w(e, t) {
                let n = (0, E.getComboId)(e, t);
                return I.findIndex(e => e.comboId === n)
            }

            function V(e, t, n, i) {
                let s = (0, E.getComboId)(e, t),
                    a = {
                        comboId: s,
                        action: i
                    },
                    o = A.indexOf(s); - 1 !== o && A.splice(o, 1);
                let r = w(e, t);
                0 !== r && (n ? -1 === r && (I.push(a), k()) : (r > 0 && I.splice(r, 1), I.unshift(a), k())), !n && N && g.default.resume(), L()
            }

            function M(e, t) {
                let n = (0, E.getComboId)(e, t),
                    i = A.indexOf(n); - 1 !== i && A.splice(i, 1);
                let s = w(e, t); - 1 !== s && (I.splice(s, 1), L()), k()
            }

            function U(e) {
                let {
                    applicationId: t,
                    branchId: n
                } = e;
                M(t, n)
            }

            function x(e) {
                let {
                    applicationId: t,
                    branchId: n
                } = e, i = (0, E.getComboId)(t, n), s = A.indexOf(i); - 1 !== s && A.splice(s, 1)
            }

            function F() {
                let e = p.default.getToken(),
                    t = p.default.getId();
                null != e && g.default.setCredentials(t, e)
            }

            function B() {
                for (let e of f.default.getRunningDiscordApplicationIds()) h.cancel(e, e);
                let e = f.default.getVisibleGame();
                return !N && null != e && e.pid !== P && h.pause(), P = null == e ? null : e.pid, !1
            }
            class G extends u.default.Store {
                initialize() {
                    var e;
                    let t = null !== (e = d.default.get(T)) && void 0 !== e ? e : {
                        queue: null,
                        paused: null,
                        userActions: null
                    };
                    if (null != t.queue) I = t.queue.map(e => "string" == typeof e ? {
                        comboId: e,
                        action: "Patch"
                    } : e);
                    null != t.paused && (N = t.paused), null != t.userActions && (b = new Map(Array.from(t.userActions))), this.waitFor(_.default, f.default), this.syncWith([f.default], B), this.waitFor(_.default)
                }
                get activeItems() {
                    return I.map(e => {
                        let {
                            comboId: t
                        } = e;
                        return (0, E.convertComboId)(t)
                    })
                }
                get finishedItems() {
                    return A.map(E.convertComboId)
                }
                get paused() {
                    return N
                }
                getQueuePosition(e, t) {
                    return w(e, t)
                }
                isCorruptInstallation() {
                    return y
                }
            }
            G.displayName = "DispatchManagerStore";
            var H = new G(c.default, {
                DISPATCH_APPLICATION_INSTALL: function(e) {
                    let {
                        applicationId: t,
                        branchId: n
                    } = e;
                    b.set((0, E.getComboId)(t, n), "Install"), V(t, n, !1, "Patch")
                },
                DISPATCH_APPLICATION_UPDATE: function(e) {
                    let {
                        applicationId: t,
                        branchId: n,
                        automatic: i
                    } = e;
                    V(t, n, i, "Patch")
                },
                DISPATCH_APPLICATION_UNINSTALL: function(e) {
                    U(e), x(e)
                },
                DISPATCH_APPLICATION_CANCEL: U,
                DISPATCH_APPLICATION_REPAIR: function(e) {
                    let {
                        applicationId: t,
                        branchId: n
                    } = e;
                    b.set((0, E.getComboId)(t, n), "Repair"), V(t, n, !1, "Repair")
                },
                DISPATCH_APPLICATION_MOVE_UP: function(e) {
                    let {
                        applicationId: t,
                        branchId: n
                    } = e, i = w(t, n);
                    if (i < 1) return !1;
                    I.splice(0, 0, I.splice(i, 1)[0]), k(), N && g.default.resume(), L()
                },
                DISPATCH_APPLICATION_REMOVE_FINISHED: x,
                DISPATCH_APPLICATION_STATE_UPDATE: function(e) {
                    let {
                        state: t
                    } = e;
                    !R && (R = !0, k(), !N && g.default.resume());
                    let n = N;
                    N = t.paused, D = t.currentTask, O = t.nextTask;
                    let i = !1;
                    I = I.filter(e => {
                        let {
                            comboId: t
                        } = e, {
                            applicationId: n,
                            branchId: s
                        } = (0, E.convertComboId)(t), a = _.default.getState(n, s), o = m.default.getTargetBuildId(n, s), r = m.default.getTargetManifests(n, s);
                        if (null != a && a.type === v.LocalDispatchApplicationStates.UP_TO_DATE && a.buildId === a.targetBuildId && a.buildId === o && l.isEqual(a.manifestIds, a.targetManifestIds) && l.isEqual(a.manifestIds, r)) {
                            if (A.push(t), b.has(t)) {
                                let e = b.get(t);
                                switch (e) {
                                    case "Install":
                                        h.completeInstall(n, a);
                                        break;
                                    case "Repair":
                                        h.completeRepair(n, a)
                                }
                                b.delete(t)
                            }
                            return i = !0, !1
                        }
                        return !0
                    }), k(), (i || n !== N) && L()
                },
                DISPATCH_APPLICATION_ERROR: function(e) {
                    let {
                        error: t
                    } = e, {
                        code: n
                    } = t;
                    if (null != n) {
                        if (C.includes(n)) F();
                        else if (n === v.DispatchErrorCodes.APPLICATION_NOT_FOUND) {
                            let {
                                context: e
                            } = t;
                            if (null != e) {
                                let {
                                    application_id: t,
                                    branch_id: n
                                } = e;
                                M(t, n)
                            }
                        }
                    }
                },
                CONNECTION_OPEN: function() {
                    (0, S.isDesktop)() && F()
                },
                LOGOUT: function() {
                    d.default.remove(T), (0, S.isDesktop)() && g.default.pause()
                }
            })
        },
        98328: function(e, t, n) {
            "use strict";
            let i;
            n.r(t), n.d(t, {
                default: function() {
                    return g
                }
            }), n("222007"), n("781738");
            var s = n("446674"),
                a = n("913144"),
                o = n("49671"),
                r = n("773336"),
                l = n("535974"),
                u = n("782340");
            let d = {},
                c = (0, r.isWindows)() ? "".concat(o.default.process.env.LOCALAPPDATA, "\\DiscordGames") : (0, r.isMac)() ? "/Applications/DiscordGames" : "/tmp";

            function h(e, t) {
                var n;
                d = {
                    ...d,
                    [e]: {
                        ...null !== (n = d[e]) && void 0 !== n ? n : {},
                        ...t
                    }
                }
            }

            function p(e) {
                let {
                    applicationId: t,
                    branchId: n,
                    installationPath: s
                } = e;
                null == i.installations[t] && (i.installations[t] = {}), i.installations[t][n] = {
                    installationPath: s
                }, !i.installationPaths.has(s) && m({
                    path: s,
                    metadata: {}
                })
            }

            function f(e) {
                let {
                    applicationId: t,
                    branchId: n
                } = e;
                if (null == i.installations[t]) return !1;
                delete i.installations[t][n], 0 === Object.keys(i.installations[t]).length && delete i.installations[t]
            }

            function m(e) {
                if (i.installationPaths.has(e.path)) return !1;
                h(e.path, e.metadata);
                let t = new Set(i.installationPaths);
                t.add(e.path), i.installationPaths = t
            }
            class E extends s.default.PersistedStore {
                initialize(e) {
                    let t = {
                        ...e
                    };
                    null == t.installations && (t.installations = {}), null == t.defaultInstallationPath && (t.defaultInstallationPath = c), null == t.installationPaths ? t.installationPaths = new Set([t.defaultInstallationPath]) : t.installationPaths = new Set(Array.from(t.installationPaths)), null == t.pathLabels && (t.pathLabels = {}), i = t
                }
                getState() {
                    return i
                }
                get defaultInstallationPath() {
                    return i.defaultInstallationPath
                }
                get installationPaths() {
                    return Array.from(i.installationPaths).map(e => ({
                        path: e,
                        label: i.pathLabels[e]
                    }))
                }
                get installationPathsMetadata() {
                    return d
                }
                hasGamesInstalledInPath(e) {
                    let {
                        installations: t
                    } = i;
                    for (let n in t)
                        for (let i in t[n])
                            if (t[n][i].installationPath === e) return !0;
                    return !1
                }
                shouldBeInstalled(e, t) {
                    return null != i.installations[e] && null != i.installations[e][t]
                }
                getInstallationPath(e, t) {
                    return null == i.installations[e] || null == i.installations[e][t] ? null : i.installations[e][t].installationPath
                }
                getLabelFromPath(e) {
                    var t, n;
                    return e === c ? u.default.Messages.INSTALL_LOCATION_MAIN : null !== (n = null !== (t = o.default.fileManager.basename(e)) && void 0 !== t ? t : e.replace(/[/\\]+$/, "").split(/[/\\]+/g).slice(-1)[0]) && void 0 !== n ? n : "?"
                }
            }
            E.displayName = "InstallationManagerStore", E.persistKey = "InstallationManagerStore";
            var g = new E(a.default, {
                DISPATCH_APPLICATION_INSTALL: p,
                DISPATCH_APPLICATION_UNINSTALL: f,
                DISPATCH_APPLICATION_CANCEL: function(e) {
                    let {
                        applicationId: t,
                        branchId: n
                    } = e, i = l.default.getState(t, n);
                    null != i && null == i.buildId && null == i.manifestIds && f({
                        applicationId: t,
                        branchId: n
                    })
                },
                INSTALLATION_LOCATION_ADD: m,
                INSTALLATION_LOCATION_REMOVE: function(e) {
                    var t;
                    let {
                        path: n
                    } = e;
                    if (!i.installationPaths.has(n) || i.defaultInstallationPath === n) return !1;
                    let s = new Set(i.installationPaths);
                    s.delete(n), i.installationPaths = s, t = n, d = {
                        ...d
                    }, delete d[t], ! function(e) {
                        if (null == i.pathLabels[e]) return;
                        i.pathLabels = {
                            ...i.pathLabels
                        }, delete i.pathLabels[e]
                    }(n)
                },
                INSTALLATION_LOCATION_UPDATE: function(e) {
                    let {
                        path: t,
                        label: n,
                        isDefault: s
                    } = e;
                    if (!i.installationPaths.has(t)) return !1;
                    if (null != n && "" !== n && i.pathLabels[t] !== n) {
                        var a, o;
                        a = t, o = n, i.pathLabels = {
                            ...i.pathLabels,
                            [a]: o
                        }
                    }
                    s && i.defaultInstallationPath !== t && (i.defaultInstallationPath = t)
                },
                INSTALLATION_LOCATION_FETCH_METADATA: function(e) {
                    let {
                        metadataPayload: t
                    } = e;
                    for (let e in t) h(e, t[e])
                },
                DISPATCH_APPLICATION_ADD_TO_INSTALLATIONS: p
            })
        },
        645672: function(e, t, n) {
            "use strict";
            n.r(t), n.d(t, {
                getBuildPlatform: function() {
                    return r
                }
            }), n("70102");
            var i, s, a = n("773336"),
                o = n("49111");

            function r() {
                switch ((0, a.getPlatform)()) {
                    case a.PlatformTypes.WINDOWS:
                        let e = "x86",
                            t = window.DiscordNative;
                        if (null != t && (e = window.DiscordNative.os.arch), "x86" === e || "ia32" === e) return o.BuildPlatformTypes.WIN32;
                        return o.BuildPlatformTypes.WIN64;
                    case a.PlatformTypes.OSX:
                        return o.BuildPlatformTypes.MACOS;
                    case a.PlatformTypes.LINUX:
                        return o.BuildPlatformTypes.LINUX;
                    default:
                        throw Error("Unsupported build type")
                }
            }(s = i || (i = {})).X86 = "x86", s.IA32 = "ia32"
        },
        269180: function(e, t, n) {
            "use strict";
            n.r(t), n.d(t, {
                default: function() {
                    return D
                }
            }), n("70102"), n("222007");
            var i = n("157552"),
                s = n("605250"),
                a = n("831610"),
                o = n("261131"),
                r = n("271938"),
                l = n("86878"),
                u = n("368694"),
                d = n("560733"),
                c = n("152723"),
                h = n("773336"),
                p = n("253981"),
                f = n("50885"),
                m = n("49111");
            let E = new s.default("Games"),
                g = {},
                S = 0,
                _ = null;

            function v() {
                return null != _ ? Promise.resolve(_) : (0, h.isDesktop)() ? f.default.ensureModule("discord_game_utils").then(() => {
                    let e = f.default.getGameUtils();
                    return null != e && null != e.findLaunchable ? (_ = e, e) : Promise.reject(Error("game utils not found"))
                }) : Promise.reject(Error("not desktop client"))
            }

            function C(e) {
                let t = {
                        id: e.id,
                        name: e.name,
                        thirdPartySkus: e.thirdPartySkus,
                        executables: e.executables.filter(e => e.os === (0, h.getPlatformName)()).map(e => e.name)
                    },
                    n = e.aliases.map(e => ({
                        ...t,
                        name: e
                    }));
                return [t, ...n]
            }

            function T(e) {
                return {
                    id: e
                }
            }
            async function I(e) {
                if (!Array.isArray(e) && (e = [e]), !u.default.isDeveloper && (e = e.filter(e => null == e.thirdPartySkus || -1 === e.thirdPartySkus.findIndex(e => {
                        let {
                            distributor: t
                        } = e;
                        return t === m.Distributors.BATTLENET
                    }))), 0 === e.length) throw Error("No remaining launchable queries");
                let t = Date.now();
                t > S && (S = t + 36e5, g = {});
                let n = await v();
                for (let t of e) {
                    let e = g[t.id];
                    if (null != e) return e;
                    let i = await new Promise(e => n.findLaunchable(t, e));
                    if (null != i) return g[t.id] = i, i
                }
                throw Error("could not find launchable")
            }

            function A(e, t, n) {
                let i = arguments.length > 3 && void 0 !== arguments[3] ? arguments[3] : 0;
                if (e()) {
                    t();
                    return
                }
                setTimeout(() => {
                    250 * i <= 12e4 ? A(e, t, n, i + 1) : n()
                }, 250)
            }

            function N(e) {
                return E.info("launch", e), new Promise((t, n) => {
                    let i = p.default.safeParseWithQuery(e.launchTarget);
                    null == i ? n(Error("Failed to parse launch target. ".concat(e.launchTarget))) : (window.open(e.launchTarget), t([]))
                })
            }
            var D = {
                waitSubscribed: (e, t) => new Promise((n, i) => A(() => o.default.isSubscribed(e, t), n, i)),
                waitConnected(e) {
                    return new Promise(A.bind(this, () => l.default.isConnected(e)))
                },
                isLaunchable: e => I(C(e)).then(e => null != e).catch(() => !1),
                launch: e => I(C(e)).then(N),
                launchDispatchApplication(e, t, n, s, o) {
                    let {
                        launchOptions: l,
                        defaultLaunchOptionId: u,
                        installPath: h,
                        applicationId: p,
                        branchId: f,
                        buildId: E,
                        shouldPatch: g
                    } = e;
                    if (null == l || null == u || null == h) throw Error("Couldn't construct launchable for ".concat(e.applicationId));
                    null == o && (o = u);
                    let S = l[o];
                    if (null == S) throw Error("Couldn't construct launchable for ".concat(e.applicationId, ". No launch option."));
                    return (0, i.fetchBranches)([f]).then(e => {
                        let t = e[0];
                        if (null == t) return Promise.reject(Error("branch is null"));
                        let {
                            liveBuildId: n
                        } = t;
                        if (g && n !== E) return Promise.reject(Error("live build id changed"))
                    }).then(() => c.default.runLaunchSetup(p, f)).then(() => {
                        let e = (0, a.default)(h),
                            i = {
                                DISCORD_INSTANCE_ID: d.default.getId().toString(),
                                DISCORD_ACCESS_TOKEN: null != t ? t : "",
                                DISCORD_CURRENT_LOCALE: n,
                                DISCORD_CURRENT_BRANCH: s,
                                DISCORD_STORAGE_PATH: m.DefaultCloudSyncConfiguration.ROOT_STORAGE_PATH(e, r.default.getId())
                            };
                        return c.default.launch(p, f, S.name, i)
                    })
                },
                removeShortcuts: e => (0, h.isWindows)() ? v().then(t => {
                    var n, i;
                    return null !== (i = null === (n = t.removeShortcuts) || void 0 === n ? void 0 : n.call(t, e)) && void 0 !== i && i
                }) : Promise.resolve(!1),
                createShortcuts(e, t, n, i, s) {
                    if (null == s || !(0, h.isWindows)()) return Promise.resolve(!1);
                    let a = "discord:///library/".concat(i, "/launch"),
                        o = "".concat(s, "\\icon.ico");
                    return v().then(i => {
                        var s, r;
                        return null !== (r = null === (s = i.createShortcuts) || void 0 === s ? void 0 : s.call(i, e, t, n, a, o)) && void 0 !== r && r
                    })
                },
                isGameLaunchable: e => I({
                    id: e
                }).then(e => null != e).catch(() => !1),
                launchGame(e) {
                    if (l.default.isConnected(e)) return Promise.resolve();
                    return I({
                        id: e
                    }).then(N)
                },
                isProtocolRegistered: e => v().then(t => {
                    var n, i;
                    return null !== (i = null === (n = t.isProtocolSchemeRegistered) || void 0 === n ? void 0 : n.call(t, e)) && void 0 !== i && i
                }),
                setRecentGames(e) {
                    v().then(t => {
                        var n;
                        return null === (n = t.setRecentGames) || void 0 === n ? void 0 : n.call(t, e)
                    }).catch(() => {})
                }
            }
        },
        964889: function(e, t, n) {
            "use strict";
            n.r(t), n.d(t, {
                getComboId: function() {
                    return r
                },
                convertComboId: function() {
                    return l
                },
                shouldShareApplicationActivity: function() {
                    return u
                },
                calculateProgressPercentage: function() {
                    return d
                },
                shouldShowGameInLibrary: function() {
                    return c
                },
                convertToTransitionState: function() {
                    return h
                },
                getCombinedProgress: function() {
                    return p
                },
                isUserEntitledToLibraryApplication: function() {
                    return f
                }
            }), n("222007"), n("808653");
            var i = n("845579"),
                s = n("697218"),
                a = n("552712"),
                o = n("49111");

            function r(e, t) {
                return "".concat(e, ":").concat(t)
            }

            function l(e) {
                let [t, n] = e.split(":");
                return {
                    applicationId: t,
                    branchId: n
                }
            }

            function u(e, t) {
                if (!i.ShowCurrentGame.getSetting() || i.StatusSetting.getSetting() === o.StatusTypes.INVISIBLE) return !1;
                let n = t.getActiveLibraryApplication(e);
                return null == n || !n.hasFlag(o.LibraryApplicationFlags.PRIVATE)
            }

            function d(e, t) {
                return 0 === t ? 100 : e / t * 100
            }

            function c(e, t, n) {
                return !(null == t || n.enabled && t.hasFlag(o.LibraryApplicationFlags.PRIVATE)) && !t.isHidden()
            }

            function h(e) {
                return null == e ? null : e.type === o.LocalDispatchApplicationStates.INSTALLING || e.type === o.LocalDispatchApplicationStates.UPDATING || e.type === o.LocalDispatchApplicationStates.UNINSTALLING ? e : null
            }

            function p(e) {
                return e.reduce((e, t) => {
                    let n = h(t);
                    return null == n || t.type === o.LocalDispatchApplicationStates.UP_TO_DATE ? e : {
                        total: e.total + Number(n.total),
                        progress: e.progress + Number(n.progress)
                    }
                }, {
                    total: 0,
                    progress: 0
                })
            }

            function f(e) {
                return !!e.isDiscordApplication() && e.isEntitled(s.default.getCurrentUser(), a.default)
            }
        },
        152723: function(e, t, n) {
            "use strict";
            let i, s;
            n.r(t), n.d(t, {
                default: function() {
                    return S
                }
            }), n("222007"), n("70102");
            var a = n("913144"),
                o = n("846071"),
                r = n("605250"),
                l = n("697218"),
                u = n("316661"),
                d = n("599110"),
                c = n("773336"),
                h = n("50885"),
                p = n("49111");
            let f = new r.default("NativeDispatchUtils");

            function m() {
                return null == s && f.warn("Tried getting Dispatch instance before instantiated"), s
            }

            function E(e) {
                let t = JSON.parse(e);
                return f.log("Native Dispatch error", t), new o.default(t)
            }

            function g(e, t) {
                "" !== e && E(e)
            }
            var S = {
                init(e) {
                    let {
                        userToken: t,
                        userId: n,
                        installPaths: a,
                        platform: o,
                        stateCallback: r,
                        errorCallback: u
                    } = e;
                    null == s && (null != i ? Promise.resolve(i) : (0, c.isDesktop)() ? Promise.all([h.default.ensureModule("discord_dispatch"), h.default.ensureModule("discord_modules")]).then(() => {
                        h.default.requireModule("discord_modules");
                        let e = h.default.getDispatch();
                        return null != e ? (i = e, e) : Promise.reject(Error("dispatch not found"))
                    }) : Promise.reject(Error("not desktop client"))).then(e => {
                        var i;
                        let c = {
                                environment: window.GLOBAL_ENV.RELEASE_CHANNEL,
                                build_number: "249561"
                            },
                            h = l.default.getCurrentUser();
                        null != h && (c.user_id = h.id, c.user_name = h.tag, null != h.email && (c.email = h.email));
                        let f = {
                            user_token: t,
                            user_id: n,
                            install_paths: a.map(e => {
                                let {
                                    path: t
                                } = e;
                                return t
                            }),
                            api_endpoint: "".concat((i = "https:", "https:")).concat(window.GLOBAL_ENV.API_ENDPOINT),
                            environment: window.GLOBAL_ENV.PROJECT_ENV,
                            sentry: c,
                            platform: o
                        };
                        s = new e.Dispatch(JSON.stringify(f), e => {
                            let t = JSON.parse(e);
                            r({
                                applications: t.applications,
                                paused: t.paused,
                                currentTask: null != t.current_task ? {
                                    applicationId: t.current_task.application_id,
                                    branchId: t.current_task.branch_id
                                } : null,
                                nextTask: null != t.next_task ? {
                                    applicationId: t.next_task.application_id,
                                    branchId: t.next_task.branch_id
                                } : null
                            })
                        }, e => {
                            let t = E(e);
                            u(t)
                        }, e => {
                            let t = JSON.parse(e);
                            ! function(e) {
                                let {
                                    properties: t
                                } = e;
                                switch (null != t.stage && null != t.stage.type && (t.stage = t.stage.type), e.event_name) {
                                    case p.AnalyticEvents.DISPATCH_PATCH_STARTED:
                                    case p.AnalyticEvents.DISPATCH_PATCH_PAUSED:
                                    case p.AnalyticEvents.DISPATCH_PATCH_FAILED:
                                    case p.AnalyticEvents.DISPATCH_PATCH_VERIFICATION_FAILED:
                                    case p.AnalyticEvents.DISPATCH_PATCH_COMPLETE:
                                    case p.AnalyticEvents.DISPATCH_PATCH_CANCELLED:
                                    case p.AnalyticEvents.DISPATCH_APPLICATION_UNINSTALLED:
                                        d.default.track(e.event_name, t)
                                }
                            }(t)
                        })
                    })
                },
                destroy() {
                    let e = m();
                    null != e && void 0 !== e.destroy && (e.destroy(), s = null)
                },
                setTargetManifest(e) {
                    let {
                        applicationId: t,
                        applicationName: n,
                        applicationIcon: i,
                        branchId: s,
                        buildId: a,
                        manifestIds: o,
                        installationPath: r
                    } = e, l = m();
                    null != l && l.command(JSON.stringify({
                        command: "SetTargetManifest",
                        application_id: t,
                        application_name: n,
                        application_icon: i,
                        branch_id: s,
                        build_id: a,
                        manifest_ids: o,
                        install_path: r
                    }), g)
                },
                setCurrentTask(e, t, n, i, s) {
                    let a = m();
                    return null != a && (a.command(JSON.stringify({
                        command: "SetCurrentTask",
                        application_id: e,
                        branch_id: t,
                        action: n,
                        user_id: i,
                        user_token: s
                    }), g), !0)
                },
                setCredentials(e, t) {
                    let n = m();
                    null != n && n.command(JSON.stringify({
                        command: "SetCredentials",
                        user_id: e,
                        user_token: t
                    }), g)
                },
                cancel(e, t) {
                    let n = m();
                    null != n && n.command(JSON.stringify({
                        command: "Cancel",
                        application_id: e,
                        branch_id: t
                    }), g)
                },
                uninstall(e, t) {
                    let n = m();
                    null != n && n.command(JSON.stringify({
                        command: "Uninstall",
                        application_id: e,
                        branch_id: t
                    }), g)
                },
                pause() {
                    let e = m();
                    null != e && e.command(JSON.stringify({
                        command: "Pause"
                    }), g)
                },
                resume() {
                    let e = m();
                    null != e && e.command(JSON.stringify({
                        command: "Resume"
                    }), g)
                },
                queryDirectory(e, t) {
                    let n = m();
                    null != n && n.command(JSON.stringify({
                        command: "QueryDirectory",
                        path: e
                    }), (e, n) => {
                        if ("" !== e) t(JSON.parse(e));
                        else if (null != n) {
                            let e = JSON.parse(n);
                            t(null, {
                                hasPermission: e.has_permission,
                                availableKB: parseInt(e.available_kb),
                                totalKB: parseInt(e.total_kb)
                            })
                        }
                    })
                },
                runLaunchSetup: (e, t) => u.default.isRunning() ? Promise.reject(Error("Already running launch setup.")) : (a.default.dispatch({
                    type: "DISPATCH_APPLICATION_LAUNCH_SETUP_START"
                }), new Promise((n, i) => {
                    let s = m();
                    if (null == s) {
                        i(Error("native dispatch instance not found"));
                        return
                    }
                    s.command(JSON.stringify({
                        command: "RunLaunchSetup",
                        application_id: e,
                        branch_id: t
                    }), (e, t, s) => {
                        if ("" !== e) {
                            a.default.dispatch({
                                type: "DISPATCH_APPLICATION_LAUNCH_SETUP_COMPLETE"
                            });
                            let t = E(e);
                            a.default.dispatch({
                                type: "DISPATCH_APPLICATION_ERROR",
                                error: t
                            }), null != t.code && t.code === p.DispatchErrorCodes.POST_INSTALL_CANCELLED ? i(t) : n();
                            return
                        }
                        if ("" !== t) {
                            a.default.dispatch({
                                type: "DISPATCH_APPLICATION_LAUNCH_SETUP_COMPLETE"
                            }), n();
                            return
                        }
                        if ("" !== s) {
                            let e = JSON.parse(s);
                            a.default.dispatch({
                                type: "DISPATCH_APPLICATION_INSTALL_SCRIPTS_PROGRESS_UPDATE",
                                progress: e.progress,
                                total: e.total,
                                name: e.name
                            })
                        }
                    })
                })),
                launch: (e, t, n, i) => new Promise((s, a) => {
                    let o = m();
                    if (null == o) {
                        a(Error("native dispatch instance not found"));
                        return
                    }
                    o.command(JSON.stringify({
                        command: "Launch",
                        application_id: e,
                        branch_id: t,
                        option_name: n,
                        environment: i
                    }), function(e, t) {
                        if ("" !== e) a(E(e));
                        else {
                            let e = JSON.parse(t);
                            s([e.pid])
                        }
                    })
                })
            }
        },
        602043: function(e, t, n) {
            "use strict";
            n.r(t), n.d(t, {
                isSupportedPlatform: function() {
                    return a
                },
                isLaunchable: function() {
                    return o
                }
            });
            var i = n("964889"),
                s = n("773336");

            function a() {
                return (0, s.isWindows)() || (0, s.isMac)()
            }

            function o(e) {
                let {
                    LibraryApplicationStore: t,
                    LaunchableGameStore: n,
                    DispatchApplicationStore: s,
                    ConnectedAppsStore: a,
                    applicationId: o,
                    branchId: r
                } = e;
                if (a.isConnected(o)) return !0;
                if (null == r && (r = o), s.isLaunchable(o, r)) return !0;
                let l = t.getLibraryApplication(o, r);
                return !(null != l && (0, i.isUserEntitledToLibraryApplication)(l)) && n.isLaunchable(o)
            }
        },
        13798: function(e, t, n) {
            "use strict";
            n.r(t), n.d(t, {
                getEnv: function() {
                    return m
                },
                codeToKey: function() {
                    return E
                },
                keyToCode: function() {
                    return g
                },
                toBrowserEvents: function() {
                    return T
                },
                toCombo: function() {
                    return I
                },
                toString: function() {
                    return A
                }
            }), n("222007"), n("781738"), n("70102"), n("808653"), n("424973");
            var i = n("499032"),
                s = n.n(i),
                a = n("917351"),
                o = n.n(a),
                r = n("449008"),
                l = n("773336"),
                u = n("49111");
            let d = (0, l.isLinux)() ? u.LinuxKeyToCode : (0, l.isMac)() ? u.MacosKeyToCode : (0, l.isWindows)() ? u.WindowsKeyToCode : void 0,
                c = o.invert(u.LinuxKeyToCode);
            c["223"] = "`", Object.freeze(c);
            let h = Object.freeze(o.invert(u.MacosKeyToCode)),
                p = o.invert(u.WindowsKeyToCode);
            p["223"] = "`", Object.freeze(p);
            let f = o.invert(null != d ? d : {});

            function m() {
                if ((0, l.isLinux)()) return u.KeyboardEnvs.LINUX;
                if ((0, l.isMac)()) return u.KeyboardEnvs.MACOS;
                if ((0, l.isWindows)()) return u.KeyboardEnvs.WINDOWS;
                else return u.KeyboardEnvs.BROWSER
            }

            function E(e) {
                let [, t, n] = e;
                switch (n) {
                    case u.KeyboardEnvs.LINUX:
                        return c["" + t];
                    case u.KeyboardEnvs.MACOS:
                        return h["" + t];
                    case u.KeyboardEnvs.WINDOWS:
                        return p["" + t];
                    case u.KeyboardEnvs.BROWSER:
                        return s(t);
                    default:
                        return f["" + t]
                }
            }

            function g(e) {
                let t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : m(),
                    n = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : u.KeyboardDeviceTypes.KEYBOARD_KEY;
                switch (n) {
                    case u.KeyboardDeviceTypes.KEYBOARD_KEY:
                    case u.KeyboardDeviceTypes.KEYBOARD_MODIFIER_KEY:
                        switch (t) {
                            case u.KeyboardEnvs.LINUX:
                                return u.LinuxKeyToCode[e];
                            case u.KeyboardEnvs.MACOS:
                                return u.MacosKeyToCode[e];
                            case u.KeyboardEnvs.WINDOWS:
                                return u.WindowsKeyToCode[e];
                            case u.KeyboardEnvs.BROWSER:
                                return s(e.replace(/^(right|left) (shift|meta|ctrl|alt)$/, "$2").replace("meta", "command"));
                            default:
                                return d[e]
                        }
                    case u.KeyboardDeviceTypes.MOUSE_BUTTON:
                        return parseInt(e.replace("MOUSE", ""), 10);
                    case u.KeyboardDeviceTypes.GAMEPAD_BUTTON:
                        return parseInt(e.replace("GAMEPAD", ""), 10);
                    default:
                        throw Error("Unrecognized DeviceType ".concat(n, "."))
                }
            }!(0, l.isMac)() && (f["223"] = "`"), Object.freeze(f);
            let S = [
                    ["META", "⌘"],
                    ["RIGHT META", "RIGHT ⌘"],
                    ["SHIFT", "⇧"],
                    ["RIGHT SHIFT", "RIGHT ⇧"],
                    ["ALT", "⌥"],
                    ["RIGHT ALT", "RIGHT ⌥"],
                    ["CTRL", "⌃"],
                    ["RIGHT CTRL", "RIGHT ⌃"],
                    ["ENTER", "↵"],
                    ["BACKSPACE", "⌫"],
                    ["DEL", "⌦"],
                    ["ESC", "⎋"],
                    ["PAGEUP", "⇞"],
                    ["PAGEDOWN", "⇟"],
                    ["UP", "↑"],
                    ["DOWN", "↓"],
                    ["LEFT", "←"],
                    ["RIGHT", "→"],
                    ["HOME", "↖"],
                    ["END", "↘"],
                    ["TAB", "⇥"],
                    ["SPACE", "␣"]
                ],
                _ = e => {
                    for (let [t, n] of S)
                        if (t === e.toUpperCase()) return n;
                    return e
                },
                v = e => {
                    for (let [t, n] of S)
                        if (n === e.toUpperCase()) return t.toLowerCase();
                    return e
                },
                C = /shift|meta|ctrl|alt$/;

            function T(e) {
                let t = {
                    keyCode: 0,
                    metaKey: !1,
                    shiftKey: !1,
                    altKey: !1,
                    ctrlKey: !1
                };
                return null == e ? [] : e.reduce((e, n) => {
                    let i = E(n),
                        s = {
                            ...t
                        };
                    if (null == i) return e.push({
                        ...s,
                        combo: n
                    }), e;
                    if (C.test(i)) return t[i + "Key"] = !0, e.map(e => (e[i + "Key"] = !0, e));
                    {
                        let t = g(i, u.KeyboardEnvs.BROWSER);
                        return null != t && (s.keyCode = t), e.push(s), e
                    }
                }, [])
            }

            function I(e) {
                let t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : m(),
                    n = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : u.KeyboardDeviceTypes.KEYBOARD_KEY,
                    i = e.replace(/numpad plus/i, "").replace(/NUMPAD \+/i, "numpad plus").split("+").map(e => e.trim().replace("plus", "+"));
                return i.reduce((e, i) => {
                    let s = v(i),
                        a = g(s, t, n);
                    return null != a && e.push([n, a, t]), e
                }, [])
            }

            function A(e) {
                let t = arguments.length > 1 && void 0 !== arguments[1] && arguments[1],
                    i = e.map(e => {
                        let [t, n, i] = e;
                        if (t === u.KeyboardDeviceTypes.KEYBOARD_KEY || t === u.KeyboardDeviceTypes.KEYBOARD_MODIFIER_KEY) {
                            var s;
                            return null !== (s = E(null != i ? [t, n, i] : [t, n])) && void 0 !== s ? s : "UNK".concat(n)
                        }
                        if (t === u.KeyboardDeviceTypes.MOUSE_BUTTON) return "mouse".concat(n);
                        if (t === u.KeyboardDeviceTypes.GAMEPAD_BUTTON) return "gamepad".concat(n);
                        else return "dev".concat(t, ",").concat(n)
                    }).filter(r.isNotNullish);
                if (!t) return i.join("+");
                {
                    let e = -1 !== n.g.navigator.appVersion.indexOf("Mac OS X") ? i.map(_) : i;
                    return e.join(" + ").toUpperCase()
                }
            }
        },
        771281: function(e, t, n) {
            "use strict";
            var i, s, a, o, r, l;
            n.r(t), n.d(t, {
                StoredCrashInformation: function() {
                    return i
                },
                JSExceptionLocation: function() {
                    return s
                },
                DesktopSources: function() {
                    return a
                }
            }), (o = i || (i = {}))[o.HasRTCConnection = 0] = "HasRTCConnection", o[o.IsSendingVideo = 1] = "IsSendingVideo", o[o.IsSendingStream = 2] = "IsSendingStream", o[o.IsReceivingVideo = 3] = "IsReceivingVideo", o[o.IsReceivingStream = 4] = "IsReceivingStream", o[o.VideoMediaSessionId = 5] = "VideoMediaSessionId", o[o.StreamMediaSessionId = 6] = "StreamMediaSessionId", (r = s || (s = {}))[r.RendererProcessDelayed = 0] = "RendererProcessDelayed", r[r.RendererProcess = 1] = "RendererProcess", r[r.MainProcess = 2] = "MainProcess", (l = a || (a = {})).WINDOW = "window", l.SCREEN = "screen", l.CAMERA = "camera"
        },
        947279: function(e, t, n) {
            "use strict";
            n.r(t), n.d(t, {
                BaseConnectionEvent: function() {
                    return r.BaseConnectionEvent
                },
                default: function() {
                    return i
                }
            }), n("222007");
            var i, s = n("773179"),
                a = n.n(s),
                o = n("595275"),
                r = n("614276"),
                l = n("685961"),
                u = n("353927");
            let d = 0;
            i = class extends o.default {
                destroy() {
                    this.destroyed = !0, this.framerateReducer.destroy(), this.setConnectionState(u.ConnectionStates.DISCONNECTED), this.emit(r.BaseConnectionEvent.Destroy, this), this.removeAllListeners()
                }
                getLocalMute(e) {
                    return this.localMutes[e] || !1
                }
                getLocalVideoDisabled(e) {
                    var t;
                    return null !== (t = this.disabledLocalVideos[e]) && void 0 !== t && t
                }
                setLocalVideoDisabled(e, t) {
                    this.disabledLocalVideos[e] = t, this.emit(r.BaseConnectionEvent.LocalVideoDisabled, e, t)
                }
                getHasActiveVideoOutputSink(e) {
                    var t;
                    return null !== (t = this.activeOutputSinks[e]) && void 0 !== t && t
                }
                setHasActiveVideoOutputSink(e, t) {
                    this.isActiveOutputSinksEnabled = !0, this.activeOutputSinks[e] = t, this.emit(r.BaseConnectionEvent.ActiveSinksChange, e, t)
                }
                getActiveOutputSinkTrackingEnabled() {
                    return this.isActiveOutputSinksEnabled
                }
                setUseElectronVideo(e) {
                    this.useElectronVideo = e
                }
                setClipRecordSsrc(e, t, n, i) {}
                getRemoteVideoSSRCsForUser(e) {
                    return []
                }
                getRemoteAudioSSRCForUser(e) {
                    return 0
                }
                getStreamParameters() {
                    return a.cloneDeep(this.videoStreamParameters)
                }
                setExperimentFlag(e, t) {
                    t ? this.experimentFlags.add(e) : this.experimentFlags.delete(e)
                }
                setConnectionState(e) {
                    this.logger.info("Connection state change: ".concat(this.connectionState, " => ").concat(e)), this.connectionState = e, this.emit(r.BaseConnectionEvent.ConnectionStateChange, this.connectionState)
                }
                updateVideoQuality(e) {
                    let {
                        quality: t,
                        constraints: n
                    } = this.applyQualityConstraints({}, this.videoStreamParameters[0].ssrc), i = a.cloneDeep(this.videoStreamParameters);
                    null != t && (i[0].maxBitrate = t.bitrateMax, null != t.encode && (i[0].maxPixelCount = t.encode.pixelCount, i[0].maxFrameRate = t.encode.framerate)), this.videoStreamParameters = i;
                    for (let e = 1; e < this.videoStreamParameters.length; e++) {
                        let {
                            quality: i,
                            constraints: s
                        } = this.applyQualityConstraints({}, this.videoStreamParameters[e].ssrc);
                        null != i && (this.videoStreamParameters[e].maxBitrate = i.bitrateMax, null != i.encode && (this.videoStreamParameters[e].maxPixelCount = i.encode.pixelCount, this.videoStreamParameters[e].maxFrameRate = i.encode.framerate)), 100 === this.videoStreamParameters[e].quality && (n = s, t = i)
                    }
                    n.streamParameters = a.cloneDeep(this.videoStreamParameters), n.remoteSinkWantsPixelCount = Math.max(...this.videoStreamParameters.map(e => {
                        var t;
                        return null !== (t = e.maxPixelCount) && void 0 !== t ? t : 0
                    }));
                    let s = this.pickProperties(n, e);
                    this.logger.info("updateVideoQuality: ".concat(JSON.stringify(s, void 0, 4))), this.updateVideoQualityCore(s, t)
                }
                applyVideoQualityMode(e) {
                    if (this.context !== u.MediaEngineContextTypes.DEFAULT) return;
                    let t = l.VIDEO_QUALITY_MODES_TO_OVERWRITES[e];
                    this.videoQualityManager.setQuality(t), this.updateVideoQuality()
                }
                overwriteQualityForTesting(e) {
                    this.videoQualityManager.setQuality(e), this.updateVideoQuality()
                }
                applyQualityConstraints() {
                    let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : {},
                        t = arguments.length > 1 ? arguments[1] : void 0;
                    return this.videoQualityManager.applyQualityConstraints(e, t)
                }
                pickProperties(e, t) {
                    if (null == t || null == e) return e;
                    let n = {};
                    for (let i of t) n[i] = e[i];
                    return n
                }
                initializeStreamParameters(e) {
                    let t = this.videoQualityManager.getQuality();
                    this.videoStreamParameters = e.filter(e => (e.type === u.MediaTypes.VIDEO || e.type === u.MediaTypes.SCREEN) && "string" == typeof e.rid).map(e => {
                        var n, i, s, a;
                        return {
                            type: e.type,
                            active: e.active,
                            rid: e.rid,
                            ssrc: e.ssrc,
                            rtxSsrc: e.rtxSsrc,
                            quality: e.quality,
                            maxBitrate: (null !== (a = e.quality) && void 0 !== a ? a : 100) < 100 ? t.bitrateMax / 4 : t.bitrateMax,
                            maxFrameRate: null === (n = t.capture) || void 0 === n ? void 0 : n.framerate,
                            maxResolution: {
                                type: u.ResolutionTypes.FIXED,
                                width: null === (i = t.capture) || void 0 === i ? void 0 : i.width,
                                height: null === (s = t.capture) || void 0 === s ? void 0 : s.height
                            },
                            profile: e.profile
                        }
                    })
                }
                getLocalWant(e) {
                    var t, n;
                    let i = this.remoteVideoSinkWants[null !== (n = null != e ? e : null === (t = this.videoStreamParameters[0]) || void 0 === t ? void 0 : t.ssrc) && void 0 !== n ? n : 0];
                    if (null != i && i > 0) return i;
                    let s = this.remoteVideoSinkWants.any;
                    return null != s && s > 0 ? s : 100
                }
                async emitStats() {
                    let e = await this.getStats();
                    return null != e && this.emit(r.BaseConnectionEvent.Stats, e), e
                }
                constructor(e, t) {
                    super(), this.mediaEngineConnectionId = "WebRTC-".concat(d++), this.destroyed = !1, this.audioSSRC = 0, this.selfDeaf = !1, this.localMutes = {}, this.disabledLocalVideos = {}, this.localVolumes = {}, this.isActiveOutputSinksEnabled = !1, this.activeOutputSinks = {}, this.videoSupported = !1, this.useElectronVideo = !1, this.voiceBitrate = u.DEFAULT_VOICE_BITRATE, this.remoteSinkWantsMaxFramerate = u.VIDEO_QUALITY_FRAMERATE, this.wantsPriority = new Set, this.localSpeakingFlags = {}, this.videoReady = !1, this.videoStreamParameters = [], this.remoteVideoSinkWants = {
                        any: 100
                    }, this.localVideoSinkWants = {
                        any: 100
                    }, this.connectionState = u.ConnectionStates.CONNECTING, this.experimentFlags = new Set, this.context = e, this.ids = t, this.videoQualityManager = new l.VideoQualityManager(e, this);
                    let i = n("920363").default;
                    this.framerateReducer = new i(this, this.videoQualityManager)
                }
            }
        },
        614276: function(e, t, n) {
            "use strict";
            var i, s;
            n.r(t), n.d(t, {
                BaseConnectionEvent: function() {
                    return i
                }
            }), (s = i || (i = {})).Destroy = "destroy", s.LocalVideoDisabled = "local-video-disabled", s.ActiveSinksChange = "active-sinks-change", s.ExperimentFlag = "experiment-flag", s.ConnectionStateChange = "connectionstatechange", s.Error = "error", s.Connected = "connected", s.VideoHookStart = "videohook-start", s.VideoHookStop = "videohook-stop", s.VideoHookInitialize = "videohook-initialize", s.ScreenshareFinish = "screenshare-finish", s.VideoState = "video-state", s.SoundshareTrace = "soundsharetrace", s.SoundshareSpeaking = "soundsharespeaking", s.SoundshareAttached = "soundshareattached", s.SoundshareFailed = "soundsharefailed", s.Speaking = "speaking", s.SpeakingWhileMuted = "speakingwhilemuted", s.Mute = "mute", s.LocalMute = "local-mute", s.NoiseLevel = "noiselevel", s.Video = "video", s.Ping = "ping", s.PingTimeout = "pingtimeout", s.Silence = "silence", s.DesktopSourceEnd = "desktopsourceend", s.OutboundLossRate = "outboundlossrate", s.NoiseCancellationError = "noisecancellererror", s.VoiceActivityDetectorError = "voiceactivitydetectorerror", s.InteractionRequired = "interactionrequired", s.AudioPermission = "audio-permission", s.VideoPermission = "video-permission", s.Stats = "stats", s.FirstFrame = "first-frame", s.VideoEncoderFallback = "video-encoder-fallback", s.RemoteStreamsReady = "remote-streams-ready"
        },
        571877: function(e, t, n) {
            "use strict";
            n.r(t), n.d(t, {
                BaseSpeedTesterEvent: function() {
                    return a.BaseSpeedTesterEvent
                },
                default: function() {
                    return i
                }
            });
            var i, s = n("595275"),
                a = n("372534"),
                o = n("353927");
            let r = 0;
            i = class extends s.default {
                destroy() {
                    this.destroyed = !0, this.setConnectionState(o.ConnectionStates.DISCONNECTED), this.emit(a.BaseSpeedTesterEvent.Destroy, this), this.removeAllListeners()
                }
                setConnectionState(e) {
                    this.connectionState = e, this.emit(a.BaseSpeedTesterEvent.ConnectionStateChange, this.connectionState)
                }
                initializeStreamParameters(e) {
                    this.videoStreamParameters = e.filter(e => e.type === o.MediaTypes.TEST).map(e => {
                        var t;
                        return {
                            type: e.type,
                            active: e.active,
                            rid: null !== (t = e.rid) && void 0 !== t ? t : "",
                            ssrc: e.ssrc
                        }
                    })
                }
                constructor(e) {
                    super(), this.mediaEngineConnectionId = "WebRTC-".concat(r++), this.destroyed = !1, this.audioSSRC = 0, this.videoStreamParameters = [], this.connectionState = o.ConnectionStates.CONNECTING, this.ids = e
                }
            }
        },
        372534: function(e, t, n) {
            "use strict";
            var i, s;
            n.r(t), n.d(t, {
                BaseSpeedTesterEvent: function() {
                    return i
                }
            }), (s = i || (i = {})).Destroy = "destroy", s.ConnectionStateChange = "connectionstatechange", s.Error = "error", s.Connected = "connected", s.Ping = "ping", s.PingTimeout = "pingtimeout"
        },
        920363: function(e, t, n) {
            "use strict";
            n.r(t), n.d(t, {
                default: function() {
                    return i
                }
            });
            var i, s = n("811022"),
                a = n("773364"),
                o = n("353927");
            let r = new s.default("ConnectionEventFramerateReducer");
            i = class {
                initialize() {
                    this.userSpeakingChange(!0)
                }
                userSpeakingChange(e) {
                    if (!this.connection.hasDesktopSource()) {
                        if (this.destroyFramerateScaleFactorTimers(), !e) {
                            this.sinkWants.isMuted && (this.sinkWants.isMuted = !1, this.updateRemoteWantsFramerate());
                            return
                        }
                        this.framerateReductionTimeout = setTimeout(() => {
                            !this.connection.destroyed && (r.info("BaseConnection.userSpeakingChange: Reduced framerate after ".concat(o.VIDEO_QUALITY_FRAMRATE_NOT_SPEAKING_TIMEOUT, " ms.")), this.framerateReductionTimeout = void 0, this.sinkWants.isMuted = !0, this.updateRemoteWantsFramerate())
                        }, o.VIDEO_QUALITY_FRAMRATE_NOT_SPEAKING_TIMEOUT)
                    }
                }
                destroyFramerateScaleFactorTimers() {
                    "number" == typeof this.framerateReductionTimeout && (clearTimeout(this.framerateReductionTimeout), this.framerateReductionTimeout = void 0)
                }
                updateRemoteWantsFramerate() {
                    this.connection.updateVideoQuality(["remoteSinkWantsMaxFramerate"])
                }
                destroy() {
                    this.destroyFramerateScaleFactorTimers()
                }
                constructor(e, t) {
                    this.connection = e, this.sinkWants = t, this.handleSpeaking = (e, t) => {
                        e === this.connection.ids.userId && this.userSpeakingChange(t === o.SpeakingFlags.NONE)
                    }, this.handleSelfMute = e => {
                        !this.connection.hasDesktopSource() && (this.destroyFramerateScaleFactorTimers(), this.sinkWants.isMuted = e, this.updateRemoteWantsFramerate())
                    }, e.on(a.BaseConnectionEvent.Speaking, this.handleSpeaking), e.on(a.BaseConnectionEvent.Mute, this.handleSelfMute), this.initialize()
                }
            }
        },
        353927: function(e, t, n) {
            "use strict";
            n.r(t), n.d(t, {
                DesktopSources: function() {
                    return U.DesktopSources
                },
                MediaEngineContextTypes: function() {
                    return v
                },
                DeviceTypes: function() {
                    return C
                },
                InputModes: function() {
                    return T
                },
                ConnectionStates: function() {
                    return I
                },
                StatsFilter: function() {
                    return A
                },
                VideoToggleReason: function() {
                    return N
                },
                DEFAULT_VOLUME: function() {
                    return x
                },
                DEFAULT_STREAM_VOLUME: function() {
                    return F
                },
                DEFAULT_VOICE_BITRATE: function() {
                    return B
                },
                DEFAULT_SOUNDSHARE_VOICE_BITRATE: function() {
                    return G
                },
                DEFAULT_DEVICE_ID: function() {
                    return H
                },
                DISABLED_DEVICE_ID: function() {
                    return W
                },
                DEFAULT_PRIORITY_SPEAKER_DUCKING: function() {
                    return K
                },
                DEFAULT_CALL_BITRATE: function() {
                    return Y
                },
                DEFAULT_CALL_MIN_BITRATE: function() {
                    return Q
                },
                DEFAULT_CALL_MAX_BITRATE: function() {
                    return q
                },
                PING_INTERVAL: function() {
                    return j
                },
                VIDEO_QUALITY_FRAMRATE_NOT_SPEAKING_TIMEOUT: function() {
                    return z
                },
                VIDEO_QUALITY_FRAMERATE: function() {
                    return X
                },
                VIDEO_QUALITY_FRAMERATE_MUTED: function() {
                    return J
                },
                VIDEO_QUALITY_FRAMERATE_MUTED_2: function() {
                    return Z
                },
                DESKTOP_BITRATE: function() {
                    return $
                },
                DESKTOP_BITRATE_ENHANCED: function() {
                    return ee
                },
                MEDIA_SINK_WANTS_PROPERTIES: function() {
                    return et
                },
                defaultVideoQualityOptions: function() {
                    return en
                },
                VideoHealthManagerConfig: function() {
                    return ei
                },
                Features: function() {
                    return D
                },
                MediaEngineImplementations: function() {
                    return O
                },
                AudioSubsystems: function() {
                    return R
                },
                Codecs: function() {
                    return b
                },
                SpeakingFlags: function() {
                    return y
                },
                MediaTypes: function() {
                    return P
                },
                ResolutionTypes: function() {
                    return k
                },
                ExperimentFlags: function() {
                    return w
                },
                VideoQualityMode: function() {
                    return V
                },
                NoiseCancellerError: function() {
                    return M
                }
            });
            var i, s, a, o, r, l, u, d, c, h, p, f, m, E, g, S, _, v, C, T, I, A, N, D, O, R, b, y, P, L, k, w, V, M, U = n("771281");
            (i = v || (v = {})).DEFAULT = "default", i.STREAM = "stream", (s = C || (C = {})).AUDIO_INPUT = "audioinput", s.AUDIO_OUTPUT = "audiooutput", s.VIDEO_INPUT = "videoinput", (a = T || (T = {})).PUSH_TO_TALK = "PUSH_TO_TALK", a.VOICE_ACTIVITY = "VOICE_ACTIVITY", (o = I || (I = {})).DISCONNECTED = "DISCONNECTED", o.CONNECTING = "CONNECTING", o.CONNECTED = "CONNECTED", o.NO_ROUTE = "NO_ROUTE", o.ICE_CHECKING = "ICE_CHECKING", o.DTLS_CONNECTING = "DTLS_CONNECTING", (r = A || (A = {}))[r.TRANSPORT = 1] = "TRANSPORT", r[r.OUTBOUND = 2] = "OUTBOUND", r[r.INBOUND = 4] = "INBOUND", r[r.ALL = 7] = "ALL", (l = N || (N = {})).MANUAL_DISABLE = "video_manual_disable", l.MANUAL_ENABLE = "video_manual_enable", l.MANUAL_REENABLE = "video_manual_reenable", l.AUTO_DISABLE = "video_auto_disable", l.AUTO_ENABLE = "video_auto_enable", l.AUTO_DOWNGRADE = "video_auto_downgrade", l.AUTO_UPGRADE = "video_auto_upgrade,";
            let x = 100,
                F = 18,
                B = 64e3,
                G = 128e3,
                H = "default",
                W = "disabled",
                K = .1,
                Y = 6e5,
                Q = 15e4,
                q = 1e7,
                j = 5e3,
                z = 15e3,
                X = 30,
                J = 20,
                Z = 12,
                $ = 4e6,
                ee = 8e6,
                et = ["remoteSinkWantsPixelCount", "remoteSinkWantsMaxFramerate", "encodingVideoMinBitRate", "encodingVideoMaxBitRate", "encodingVideoBitRate", "streamParameters"],
                en = {
                    videoBudget: {
                        width: 1280,
                        height: 720,
                        framerate: X
                    },
                    videoCapture: {
                        width: 1280,
                        height: 720,
                        framerate: X
                    },
                    videoBitrate: {
                        min: 15e4,
                        max: 25e5
                    },
                    desktopBitrate: {
                        min: 5e5,
                        max: $,
                        target: 6e5
                    },
                    videoBitrateFloor: 15e4
                },
                ei = {
                    featureEnabled: !0,
                    windowLength: 5,
                    allowedPoorFpsRatio: 1,
                    fpsThreshold: 5,
                    backoffTimeSec: 15
                };
            (u = D || (D = {})).AUTO_ENABLE = "AUTO_ENABLE", u.ATTENUATION = "ATTENUATION", u.AUDIO_INPUT_DEVICE = "AUDIO_INPUT_DEVICE", u.AUDIO_OUTPUT_DEVICE = "AUDIO_OUTPUT_DEVICE", u.VOICE_PROCESSING = "VOICE_PROCESSING", u.QOS = "QOS", u.NATIVE_PING = "NATIVE_PING", u.LEGACY_AUDIO_SUBSYSTEM = "LEGACY_AUDIO_SUBSYSTEM", u.EXPERIMENTAL_AUDIO_SUBSYSTEM = "EXPERIMENTAL_AUDIO_SUBSYSTEM", u.DEBUG_LOGGING = "DEBUG_LOGGING", u.AUTOMATIC_VAD = "AUTOMATIC_VAD", u.VOICE_PANNING = "VOICE_PANNING", u.DIAGNOSTICS = "DIAGNOSTICS", u.VIDEO = "VIDEO", u.DESKTOP_CAPTURE = "DESKTOP_CAPTURE", u.DESKTOP_CAPTURE_FORMAT = "DESKTOP_CAPTURE_FORMAT", u.DESKTOP_CAPTURE_APPLICATIONS = "DESKTOP_CAPTURE_APPLICATIONS", u.SOUNDSHARE = "SOUNDSHARE", u.LOOPBACK = "LOOPBACK", u.VIDEO_HOOK = "VIDEO_HOOK", u.EXPERIMENTAL_SOUNDSHARE = "EXPERIMENTAL_SOUNDSHARE", u.WUMPUS_VIDEO = "WUMPUS_VIDEO", u.ELEVATED_HOOK = "ELEVATED_HOOK", u.HYBRID_VIDEO = "HYBRID_VIDEO", u.OPEN_H264 = "OPEN_H264", u.EXPERIMENTAL_ENCODERS = "EXPERIMENTAL_ENCODERS", u.REMOTE_LOCUS_NETWORK_CONTROL = "REMOTE_LOCUS_NETWORK_CONTROL", u.SCREEN_PREVIEWS = "SCREEN_PREVIEWS", u.WINDOW_PREVIEWS = "WINDOW_PREVIEWS", u.AUDIO_DEBUG_STATE = "AUDIO_DEBUG_STATE", u.AEC_DUMP = "AEC_DUMP", u.DISABLE_VIDEO = "DISABLE_VIDEO", u.CONNECTION_REPLAY = "CONNECTION_REPLAY", u.SIMULCAST = "SIMULCAST", u.RTC_REGION_RANKING = "RTC_REGION_RANKING", u.DIRECT_VIDEO = "DIRECT_VIDEO", u.ELECTRON_VIDEO = "ELECTRON_VIDEO", u.MEDIAPIPE = "MEDIAPIPE", u.FIXED_KEYFRAME_INTERVAL = "FIXED_KEYFRAME_INTERVAL", u.SAMPLE_PLAYBACK = "SAMPLE_PLAYBACK", u.FIRST_FRAME_CALLBACK = "FIRST_FRAME_CALLBACK", u.REMOTE_USER_MULTI_STREAM = "REMOTE_USER_MULTI_STREAM", u.NOISE_SUPPRESSION = "NOISE_SUPPRESSION", u.NOISE_CANCELLATION = "NOISE_CANCELLATION", u.AUTOMATIC_GAIN_CONTROL = "AUTOMATIC_GAIN_CONTROL", u.CLIPS = "CLIPS", u.SPEED_TEST = "SPEED_TEST", u.IMAGE_QUALITY_MEASUREMENT = "IMAGE_QUALITY_MEASUREMENT", u.AMD_EXPERIMENTAL_RATE_CONTROL = "AMD_EXPERIMENTAL_RATE_CONTROL", u.GO_LIVE_HARDWARE = "GO_LIVE_HARDWARE", u.SCREEN_CAPTURE_KIT = "SCREEN_CAPTURE_KIT", u.CAPTURE_TIMEOUT_EXPERIMENTS = "CAPTURE_TIMEOUT_EXPERIMENTS", (d = O || (O = {})).NATIVE = "NATIVE", d.WEBRTC = "WEBRTC", d.DUMMY = "DUMMY", (c = R || (R = {})).LEGACY = "legacy", c.STANDARD = "standard", c.EXPERIMENTAL = "experimental", (h = b || (b = {})).OPUS = "opus", h.VP8 = "VP8", h.VP9 = "VP9", h.H264 = "H264", h.RTX = "rtx", h.TEST = "TEST", (p = y || (y = {}))[p.NONE = 0] = "NONE", p[p.VOICE = 1] = "VOICE", p[p.SOUNDSHARE = 2] = "SOUNDSHARE", p[p.PRIORITY = 4] = "PRIORITY", (f = P || (P = {})).AUDIO = "audio", f.VIDEO = "video", f.SCREEN = "screen", f.TEST = "test", (m = L || (L = {})).PLAYING = "playing", m.PAUSED = "paused", (E = k || (k = {})).FIXED = "fixed", E.SOURCE = "source", (g = w || (w = {})).VIDEOTOOLBOX_RATE_CONTROL = "videotoolbox_rate_control", g.SIGNAL_H265_SUPPORT = "signal_h265_support", g.SIGNAL_AV1_SUPPORT = "signal_av1_support", g.STREAMER_CLIP = "streamer_clip", g.VIEWER_CLIP = "viewer_clip", (S = V || (V = {}))[S.AUTO = 1] = "AUTO", S[S.FULL = 2] = "FULL", (_ = M || (M = {}))[_.CPU_OVERUSE = 1] = "CPU_OVERUSE", _[_.FAILED = 2] = "FAILED", _[_.VAD_CPU_OVERUSE = 3] = "VAD_CPU_OVERUSE", _[_.INITIALIZED = 4] = "INITIALIZED"
        },
        870630: function(e, t, n) {
            "use strict";
            n.r(t), n.d(t, {
                default: function() {
                    return i
                }
            }), n("70102"), n("222007");
            var i, s = n("595275"),
                a = n("773364"),
                o = n("353927");

            function r(e) {
                return null
            }

            function l(e) {
                return null
            }
            i = class extends s.default {
                destroy() {
                    this.emit(a.MediaEngineEvent.Destroy), this.removeAllListeners()
                }
                interact() {}
                supported() {
                    return __OVERLAY__
                }
                supports(e) {
                    if (e === o.Features.AUTO_ENABLE) return __OVERLAY__;
                    return !1
                }
                connect(e, t, n) {
                    throw Error("NOT_IMPLEMENTED")
                }
                eachConnection() {}
                enable() {
                    return Promise.resolve()
                }
                setInputVolume(e) {}
                setOutputVolume(e) {}
                getAudioInputDevices() {
                    return Promise.resolve([])
                }
                setAudioInputDevice(e) {}
                getAudioOutputDevices() {
                    return Promise.resolve([])
                }
                setAudioOutputDevice(e) {}
                getVideoInputDevices() {
                    return Promise.resolve([])
                }
                setVideoInputDevice(e) {}
                getSupportedVideoCodecs(e) {
                    e([])
                }
                getCodecCapabilities(e) {
                    e("")
                }
                getCodecSurvey() {
                    return Promise.reject(Error("getCodecSurvey is not implemented for MediaEngineDummy"))
                }
                getAudioSubsystem() {
                    return o.AudioSubsystems.STANDARD
                }
                getAudioLayer() {
                    return ""
                }
                setGoLiveSource(e, t) {}
                setClipsSource(e) {}
                setDesktopSource(e) {
                    arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : o.MediaEngineContextTypes.DEFAULT
                }
                setSoundshareSource(e, t, n) {}
                getDesktopSource() {
                    return Promise.reject(Error("NO_STREAM"))
                }
                getDesktopSources() {
                    return Promise.reject(Error("NO_STREAM"))
                }
                getScreenPreviews(e, t) {
                    return Promise.reject(Error("UNSUPPORTED"))
                }
                getWindowPreviews(e, t) {
                    return Promise.reject(Error("UNSUPPORTED"))
                }
                setClipBufferLength(e) {}
                saveClip(e, t) {
                    return Promise.reject(Error("UNSUPPORTED"))
                }
                saveClipForSSRC(e, t, n, i) {
                    return Promise.reject(Error("UNSUPPORTED"))
                }
                updateClipMetadata(e, t) {
                    return Promise.reject(Error("UNSUPPORTED"))
                }
                exportClip(e, t) {
                    return Promise.reject(Error("UNSUPPORTED"))
                }
                setAudioSubsystem(e) {}
                getDebugLogging() {
                    return !1
                }
                setDebugLogging(e) {}
                writeAudioDebugState() {
                    return Promise.reject(Error("Audio debug state is not supported."))
                }
                setExperimentalAdm(e) {}
                setLoopback(e, t) {}
                getLoopback() {
                    return !1
                }
                setH264Enabled(e) {}
                setAv1Enabled(e) {}
                setH265Enabled(e) {}
                setExperimentFlag(e, t) {}
                startAecDump() {}
                stopAecDump() {}
                setAecDump(e) {}
                createReplayConnection(e, t) {
                    throw Error("Connection replay is not supported.")
                }
                setUseDirectVideo(e) {}
                setMaxSyncDelayOverride(e) {}
                rankRtcRegions(e) {
                    return Promise.reject(Error("RTC region latency test is not supported."))
                }
                getSoundshareStatus() {
                    return Promise.reject(Error("Soundshare is not supported."))
                }
                enableSoundshare() {
                    return Promise.reject(Error("Soundshare is not supported."))
                }
                applyMediaFilterSettings(e) {
                    return Promise.resolve()
                }
                startLocalAudioRecording() {
                    return Promise.reject(Error("startLocalAudioRecording is not supported."))
                }
                stopLocalAudioRecording(e) {}
                speedTester(e, t) {
                    throw Error("NOT_IMPLEMENTED")
                }
                setHasFullbandPerformance(e) {}
                getSupportedSecureFramesProtocolVersion() {
                    return 0
                }
                getSupportedBandwidthEstimationExperiments(e) {
                    e([])
                }
                constructor(...e) {
                    super(...e), this.Video = r, this.Camera = l
                }
            }
        },
        775766: function(e, t, n) {
            "use strict";
            var i, s;
            n.r(t), n.d(t, {
                MediaEngineEvent: function() {
                    return i
                }
            }), (s = i || (i = {})).Destroy = "destroy", s.Silence = "silence", s.Connection = "connection", s.DeviceChange = "devicechange", s.VolumeChange = "volumechange", s.VoiceActivity = "voiceactivity", s.WatchdogTimeout = "watchdogtimeout", s.AudioPermission = "audio-permission", s.VideoPermission = "video-permission", s.DesktopSourceEnd = "desktopsourceend", s.ConnectionStats = "connection-stats", s.VideoInputInitialized = "video-input-initialized", s.ClipsRecordingRestartNeeded = "clips-recording-restart-needed", s.ClipsInitFailure = "clips-init-failure", s.ClipsRecordingEnded = "clips-recording-ended"
        },
        582663: function(e, t, n) {
            "use strict";
            n.r(t), n.d(t, {
                MediaSinkWantsLadder: function() {
                    return s
                }
            }), n("70102"), n("222007"), n("424973");
            var i = n("353927");
            class s {
                getMaxSinkValue(e) {
                    if (e < 0) throw Error("getMaxSinkValue: Requested " + e);
                    let t = this.orderedLadder[0].wantValue;
                    for (let {
                            pixelCount: n,
                            wantValue: i
                        }
                        of this.orderedLadder) {
                        if (n * e > this.pixelBudget) break;
                        t = i
                    }
                    return t
                }
                getResolution(e) {
                    let t = null;
                    for (let n of this.orderedLadder)
                        if (e >= n.wantValue) t = n;
                        else break;
                    return {
                        width: (t = null != t ? t : this.orderedLadder[0]).width,
                        height: t.height,
                        budgetPortion: t.budgetPortion,
                        mutedFramerate: t.mutedFramerate,
                        framerate: t.framerate
                    }
                }
                static calculateLadder(e) {
                    let t = new Set([0, 4, 8, 10]),
                        n = [];
                    for (let i = 1; i < 4096; ++i) {
                        let s = 16 * i / 9;
                        if (t.has(s % 16) && t.has(i % 16)) {
                            let t = s * i;
                            n.push({
                                pixelCount: t,
                                width: s,
                                height: i,
                                budgetPortion: t / e,
                                wantValue: 0
                            })
                        }
                    }
                    let a = {},
                        o = 0,
                        r = 100;
                    for (let t = 1; t <= 25; ++t) {
                        let l = 0,
                            u = 0,
                            d = 0;
                        for (let i of n) {
                            if (i.pixelCount * t > e) break;
                            l = i.width, u = i.height, d = i.budgetPortion
                        }
                        if (o !== l) {
                            let e = s.getMutedFramerate(r);
                            a[r] = {
                                width: l,
                                height: u,
                                budgetPortion: d,
                                mutedFramerate: e,
                                framerate: i.VIDEO_QUALITY_FRAMERATE
                            }, r -= 10, o = l
                        }
                    }
                    return a
                }
                static getMutedFramerate(e) {
                    return e <= 20 ? i.VIDEO_QUALITY_FRAMERATE_MUTED_2 : i.VIDEO_QUALITY_FRAMERATE_MUTED
                }
                static calculateOrderedLadder(e) {
                    let t = [],
                        n = Object.keys(e).map(e => Number(e)).sort((e, t) => e - t);
                    for (let i of n) {
                        if (0 === i) continue;
                        let n = e[i];
                        t.push({
                            pixelCount: n.width * n.height,
                            wantValue: i,
                            ...n
                        })
                    }
                    return t
                }
                constructor(e = i.defaultVideoQualityOptions) {
                    let {
                        width: t,
                        height: n
                    } = e.videoBudget;
                    if (t <= 0 || n <= 0) throw Error("Invalid argument");
                    this.pixelBudget = t * n, this.ladder = s.calculateLadder(this.pixelBudget), this.orderedLadder = s.calculateOrderedLadder(this.ladder)
                }
            }
        },
        22546: function(e, t, n) {
            "use strict";
            n.r(t), n.d(t, {
                STATS_INTERVAL: function() {
                    return i
                }
            });
            let i = 1e3
        },
        685961: function(e, t, n) {
            "use strict";
            n.r(t), n.d(t, {
                VIDEO_QUALITY_MODES_TO_OVERWRITES: function() {
                    return a
                },
                VideoQuality: function() {
                    return r
                },
                VideoQualityManager: function() {
                    return l
                }
            }), n("70102");
            var i = n("582663"),
                s = n("353927");
            let a = Object.freeze({
                [s.VideoQualityMode.AUTO]: {},
                [s.VideoQualityMode.FULL]: {
                    encode: {
                        width: 1280,
                        height: 720
                    }
                }
            });
            class o {
                constructor(e) {
                    if (null == e.capture && null == e.encode) throw Error("Invalid arguments.");
                    this.capture = null == e.capture ? void 0 : new r(e.capture), this.encode = null == e.encode ? void 0 : new r(e.encode), this.bitrateMin = e.bitrateMin, this.bitrateMax = e.bitrateMax, this.bitrateTarget = e.bitrateTarget, this.localWant = e.localWant
                }
            }
            class r {
                static equals(e, t) {
                    return null == e && null == t || null != e && null != t && e.width === t.width && e.height === t.height && e.framerate === t.framerate
                }
                static extend(e, t) {
                    var n, i, s;
                    return null == e ? t : null == t ? e : {
                        width: null !== (n = null == t ? void 0 : t.width) && void 0 !== n ? n : null == e ? void 0 : e.width,
                        height: null !== (i = null == t ? void 0 : t.height) && void 0 !== i ? i : null == e ? void 0 : e.height,
                        framerate: null !== (s = null == t ? void 0 : t.framerate) && void 0 !== s ? s : null == e ? void 0 : e.framerate
                    }
                }
                constructor(e) {
                    this.width = e.width, this.height = e.height, this.framerate = e.framerate, this.pixelCount = e.width * e.height
                }
            }
            class l {
                getQuality(e) {
                    var t, n, i;
                    let s = this.isStreamContext ? this.getDesktopQuality() : this.getVideoQuality(this.connection.getLocalWant(e));
                    return new o({
                        encode: r.extend(s.encode, this.qualityOverwrite.encode),
                        capture: r.extend(s.capture, this.qualityOverwrite.capture),
                        bitrateMin: null !== (t = this.qualityOverwrite.bitrateMin) && void 0 !== t ? t : s.bitrateMin,
                        bitrateMax: null !== (n = this.qualityOverwrite.bitrateMax) && void 0 !== n ? n : s.bitrateMax,
                        bitrateTarget: null !== (i = this.qualityOverwrite.bitrateTarget) && void 0 !== i ? i : s.bitrateTarget,
                        localWant: s.localWant
                    })
                }
                applyQualityConstraints(e, t) {
                    let n = this.getQuality(t);
                    return null != n.capture && (e.encodingVideoWidth = n.capture.width, e.encodingVideoHeight = n.capture.height, e.encodingVideoFrameRate = n.capture.framerate), null != n.encode && (e.remoteSinkWantsMaxFramerate = n.encode.framerate, e.remoteSinkWantsPixelCount = n.encode.pixelCount), null != n.bitrateTarget ? e.encodingVideoBitRate = n.bitrateTarget : e.encodingVideoBitRate = n.bitrateMax, e.encodingVideoMinBitRate = n.bitrateMin, e.encodingVideoMaxBitRate = n.bitrateMax, null != e.encodingVideoBitRate && null != e.encodingVideoMaxBitRate && (e.encodingVideoBitRate = Math.min(e.encodingVideoBitRate, e.encodingVideoMaxBitRate)), {
                        quality: n,
                        constraints: e
                    }
                }
                setQuality(e) {
                    this.qualityOverwrite.capture = e.capture, this.qualityOverwrite.encode = e.encode, this.qualityOverwrite.bitrateMin = e.bitrateMin, this.qualityOverwrite.bitrateMax = e.bitrateMax, this.qualityOverwrite.bitrateTarget = e.bitrateTarget
                }
                getVideoQuality(e) {
                    let t = this.ladder.getResolution(e),
                        n = this.options.videoBitrate.min * t.budgetPortion,
                        i = this.options.videoBitrate.max * t.budgetPortion,
                        s = this.isMuted ? t.mutedFramerate : t.framerate;
                    return new o({
                        encode: {
                            ...t,
                            framerate: s
                        },
                        capture: {
                            width: this.options.videoCapture.width,
                            height: this.options.videoCapture.height,
                            framerate: this.options.videoCapture.framerate
                        },
                        bitrateMin: n,
                        bitrateMax: Math.max(i, this.options.videoBitrateFloor),
                        localWant: e
                    })
                }
                getDesktopQuality() {
                    return new o({
                        capture: {
                            width: 1280,
                            height: 720,
                            framerate: s.VIDEO_QUALITY_FRAMERATE
                        },
                        bitrateMin: this.options.desktopBitrate.min,
                        bitrateMax: this.options.desktopBitrate.max,
                        bitrateTarget: this.options.desktopBitrate.target
                    })
                }
                constructor(e, t, n = s.defaultVideoQualityOptions) {
                    this.contextType = e, this.connection = t, this.options = n, this.isMuted = !1, this.qualityOverwrite = {}, this.isStreamContext = this.contextType === s.MediaEngineContextTypes.STREAM, this.ladder = new i.MediaSinkWantsLadder(n)
                }
            }
        },
        773364: function(e, t, n) {
            "use strict";
            n.r(t), n.d(t, {
                BaseConnectionEvent: function() {
                    return u.BaseConnectionEvent
                },
                BaseSpeedTesterEvent: function() {
                    return d.BaseSpeedTesterEvent
                },
                MediaEngineEvent: function() {
                    return c.MediaEngineEvent
                },
                MediaEngineContextTypes: function() {
                    return h.MediaEngineContextTypes
                },
                FilterTargetType: function() {
                    return o
                },
                FilterSettingsGraph: function() {
                    return r
                },
                FilterSettingsKey: function() {
                    return l
                },
                determineMediaEngine: function() {
                    return f
                },
                initializeMediaEngine: function() {
                    return m
                }
            });
            var i, s, a, o, r, l, u = n("947279"),
                d = n("571877"),
                c = n("775766"),
                h = n("353927");

            function p(e) {
                switch (e) {
                    case h.MediaEngineImplementations.NATIVE:
                        return n("741397").default;
                    case h.MediaEngineImplementations.WEBRTC:
                        return n("551079").default;
                    case h.MediaEngineImplementations.DUMMY:
                    default:
                        return n("870630").default
                }
            }

            function f() {
                var e;
                return null !== (e = [h.MediaEngineImplementations.NATIVE, h.MediaEngineImplementations.WEBRTC].find(e => p(e).supported())) && void 0 !== e ? e : h.MediaEngineImplementations.DUMMY
            }

            function m(e) {
                let t = p(e);
                return new t
            }(i = o || (o = {})).INPUT_DEVICE = "input_device", i.STREAM = "stream", (s = r || (r = {})).NONE = "", s.BACKGROUND_BLUR = "background_blur", s.BACKGROUND_REPLACEMENT = "background_replacement", (a = l || (l = {})).CAMERA_BACKGROUND_PREVIEW = "cameraBackgroundPreview", a.CAMERA_BACKGROUND_LIVE = "cameraBackgroundLive"
        },
        784343: function(e, t, n) {
            "use strict";
            n.r(t), n.d(t, {
                default: function() {
                    return i
                }
            }), n("854508"), n("222007"), n("70102"), n("424973"), n("808653");
            var i, s = n("773179"),
                a = n.n(s),
                o = n("53379"),
                r = n("811022"),
                l = n("947279"),
                u = n("22546"),
                d = n("685961"),
                c = n("773364"),
                h = n("668906"),
                p = n("573015"),
                f = n("784063"),
                m = n("539578"),
                E = n("595432"),
                g = n("353927"),
                S = n("149416");
            let _ = 0;

            function v(e) {
                return null != e && 0 !== e ? e + 1 : 0
            }
            i = class e extends l.default {
                static create(t, n, i) {
                    let s = new e(t, n, !0);
                    return s.initialize(i), s
                }
                static createReplay(t, n) {
                    let i = new e(t, {
                            userId: "0",
                            channelId: "0",
                            guildId: "0"
                        }, !0),
                        s = (0, f.getVoiceEngine)();
                    i.initializeStreamParameters([{
                        type: g.MediaTypes.VIDEO,
                        rid: "100",
                        ssrc: 0,
                        rtxSsrc: 0,
                        quality: 100,
                        active: !1
                    }]);
                    let a = s.createReplayConnection("default", (e, n) => {
                        let a = null != s.getCodecCapabilities ? s.getCodecCapabilities : s.getSupportedVideoCodecs;
                        i.on(c.BaseConnectionEvent.Stats, i.handleStats), i.conn.setOnVideoCallback(i.handleVideo), a(e => {
                            let n = (0, h.getExperimentCodecs)(i.experimentFlags);
                            i.codecs = [{
                                type: "audio",
                                name: S.Codecs.OPUS,
                                priority: 1,
                                payloadType: 120
                            }, ...(0, h.filterVideoCodecs)(e, n).map((e, t) => {
                                let n = 101 + 2 * t,
                                    [i, [s, a]] = e;
                                return {
                                    type: "video",
                                    name: i,
                                    priority: t + 1,
                                    payloadType: n,
                                    rtxPayloadType: n + 1,
                                    encode: s,
                                    decode: a
                                }
                            })], i.setCodecs(S.Codecs.OPUS, S.Codecs.H264, t), i.conn.startReplay()
                        })
                    }, n);
                    return null == a ? null : (i.conn = a, i)
                }
                initialize(e) {
                    let t;
                    this.logger.info("Creating connection to ".concat(e.address, ":").concat(e.port, " with audio ssrc: ").concat(e.ssrc)), this.audioSSRC = e.ssrc, this.streamUserId = e.streamUserId, this.initializeStreamParameters(e.streamParameters), e.streamParameters = this.videoStreamParameters;
                    let n = (0, f.getVoiceEngine)(),
                        i = null != n.getCodecCapabilities ? n.getCodecCapabilities : n.getSupportedVideoCodecs;
                    if (null != n.createOwnStreamConnectionWithOptions) {
                        let e = this.context === S.MediaEngineContextTypes.STREAM && this.streamUserId === this.ids.userId;
                        a = e ? n.createOwnStreamConnectionWithOptions : n.createVoiceConnectionWithOptions
                    } else if (null != n.createOwnStreamConnection) {
                        let e = this.context === S.MediaEngineContextTypes.STREAM && this.streamUserId === this.ids.userId;
                        var s, a, o = e ? n.createOwnStreamConnection : n.createVoiceConnection;
                        a = (e, t, n) => o(t.ssrc, this.ids.userId, t.address, t.port, n, t.experiments, t.streamParameters)
                    } else a = (e, t, i) => new n.VoiceConnection(t.ssrc, e, t.address, t.port, i, t.experiments, t.streamParameters);
                    null === (s = (t = this.conn = a(this.ids.userId, e, (s, a) => {
                        if (this.destroyed) return;
                        if (null != s && "" !== s) {
                            this.setConnectionState(S.ConnectionStates.NO_ROUTE), this.emit(c.BaseConnectionEvent.Error, s);
                            return
                        }
                        if (null == a) throw Error("Invalid transport info");
                        let {
                            protocol: o,
                            address: r,
                            port: l
                        } = a;
                        this.logger.info("Connected with local address ".concat(r, ":").concat(l, " and protocol: ").concat(o)), this.experimentFlags.has(g.ExperimentFlags.STREAMER_CLIP) && this.setClipRecordSsrc(this.audioSSRC, "audio", "outbound", !0), this.context === S.MediaEngineContextTypes.STREAM && this.experimentFlags.has(g.ExperimentFlags.VIEWER_CLIP) && n.applyClipsSettings({
                            enableViewerClipping: !0,
                            useEndEncoder: !0
                        }), i(i => {
                            let s = (0, h.getExperimentCodecs)(this.experimentFlags);
                            this.codecs = [{
                                type: "audio",
                                name: S.Codecs.OPUS,
                                priority: 1,
                                payloadType: 120
                            }, ...(0, h.filterVideoCodecs)(i, s).map((e, t) => {
                                let n = 101 + 2 * t,
                                    [i, [s, a]] = e;
                                return {
                                    type: "video",
                                    name: i,
                                    priority: t + 1,
                                    payloadType: n,
                                    rtxPayloadType: n + 1,
                                    encode: s,
                                    decode: a
                                }
                            })], this.logger.info("Video codecs: ".concat(this.codecs.map(e => e.name))), t.getEncryptionModes(i => {
                                var s, a, u, d, h, p, f, m, E;
                                this.logger.info("Encryption modes: ".concat(i)), t.setTransportOptions(this.getConnectionTransportOptions()), t.setSelfMute(this.selfMute || this.context === S.MediaEngineContextTypes.STREAM), t.setSelfDeafen(this.selfDeaf), t.setOnSpeakingCallback(this.handleSpeakingNative), null === (s = t.setOnSpeakingWhileMutedCallback) || void 0 === s || s.call(t, this.handleSpeakingWhileMuted), null === (a = t.setPingInterval) || void 0 === a || a.call(t, S.PING_INTERVAL), t.setPingCallback(this.handlePing), null === (u = t.setPingTimeoutCallback) || void 0 === u || u.call(t, this.handlePingTimeout), null === (d = t.setOnVideoEncoderFallbackCallback) || void 0 === d || d.call(t, this.handleVideoEncoderFallback), n.setTransportOptions({
                                    builtInEchoCancellation: !0,
                                    echoCancellation: this.echoCancellation,
                                    noiseSuppression: this.noiseSuppression,
                                    automaticGainControl: this.automaticGainControl,
                                    noiseCancellation: this.noiseCancellation
                                }), n.setNoInputThreshold(-100), n.setNoInputCallback(this.handleNoInput), this.videoSupported && (t.setOnVideoCallback(this.handleVideo), null === (h = t.setOnFirstFrameCallback) || void 0 === h || h.call(t, this.handleFirstFrame), null === (p = t.setOnDesktopSourceEnded) || void 0 === p || p.call(t, this.handleDesktopSourceEnded), null === (f = t.setOnSoundshare) || void 0 === f || f.call(t, this.handleSoundshare), null === (m = t.setOnSoundshareEnded) || void 0 === m || m.call(t, this.handleSoundshareEnded), null === (E = t.setOnSoundshareFailed) || void 0 === E || E.call(t, this.handleSoundshareFailed)), this.setConnectionState(S.ConnectionStates.CONNECTED), this.emit(c.BaseConnectionEvent.Connected, o, {
                                    address: r,
                                    port: l,
                                    mode: this.chooseEncryptionMode(e.modes, i),
                                    codecs: this.codecs
                                }), this.on(c.BaseConnectionEvent.Stats, this.handleStats);
                                let g = this.getUserOptions();
                                for (let e of (g.forEach(e => {
                                        var t, n;
                                        return this.logger.info("Creating user: ".concat(e.id, " with audio SSRC: ").concat(e.ssrc, " and video SSRCs: ").concat(null !== (n = null === (t = e.videoSsrcs) || void 0 === t ? void 0 : t.join(",")) && void 0 !== n ? n : 0))
                                    }), t.mergeUsers(g), this.emit(c.BaseConnectionEvent.RemoteStreamsReady, g.length), Object.keys(this.localSpeakingFlags))) e !== this.ids.userId && this.setSpeakingFlags(e, this.localSpeakingFlags[e])
                            })
                        })
                    })).setDesktopSourceStatusCallback) || void 0 === s || s.call(t, e => {
                        if ("videohook_start" === e.type) this.emit(c.BaseConnectionEvent.VideoHookStart);
                        else if ("videohook_stop" === e.type) this.emit(c.BaseConnectionEvent.VideoHookStop);
                        else if ("videohook_initialize" === e.type) this.emit(c.BaseConnectionEvent.VideoHookInitialize, e.backend, e.format, e.framebufferFormat, e.sampleCount, e.success, e.reinitialization);
                        else if ("screenshare_finish" === e.type) {
                            var t;
                            this.emit(c.BaseConnectionEvent.ScreenshareFinish, e.screenshareFrames, e.videohookFrames, e.hybridDxgiFrames, e.hybridGdiFrames, e.hybridVideohookFrames, e.hybridGraphicsCaptureFrames, e.hybridCaptureMethodSwitches, e.quartzFrames, null !== (t = e.desktopCapturerType) && void 0 !== t ? t : e.desktop_capturer_type, e.screens, e.windows, e.activity, e.goLiveCameraFrames, e.screenCaptureKitFrames)
                        } else "video_state" === e.type ? this.emit(c.BaseConnectionEvent.VideoState, e.state) : e.type.startsWith("soundshare_") && this.emit(c.BaseConnectionEvent.SoundshareTrace, e)
                    }), this.on("newListener", this.handleNewListenerNative)
                }
                destroy() {
                    this.conn.destroy(), a(this.localSpeakingFlags).keys().reject(e => e === this.ids.userId).forEach(e => this.emit(c.BaseConnectionEvent.Speaking, e, S.SpeakingFlags.NONE, this.remoteAudioSSRCs[e])), this.setConnectionState(S.ConnectionStates.DISCONNECTED), super.destroy()
                }
                setCodecs(e, t, n) {
                    this.conn.setTransportOptions(this.getCodecOptions(e, t, n)), this.videoEncoderFallbackPending && (this.videoEncoderFallbackPending = !1)
                }
                getStats() {
                    return this.connectionState === S.ConnectionStates.DISCONNECTED ? Promise.resolve(null) : (0, o.timeout)(new Promise(e => {
                        if (null != this.conn.getFilteredStats) this.conn.getFilteredStats(g.StatsFilter.ALL, t => e((0, m.default)(this.mediaEngineConnectionId, t, this.remoteVideoSinkWants, this.localVideoSinkWants)));
                        else if (null != this.conn.getStats) this.conn.getStats(t => e((0, m.default)(this.mediaEngineConnectionId, t, this.remoteVideoSinkWants, this.localVideoSinkWants)));
                        else {
                            let t = (0, f.getVoiceEngine)();
                            t.getStats(t => e((0, m.default)(this.mediaEngineConnectionId, t, this.remoteVideoSinkWants, this.localVideoSinkWants)))
                        }
                    }), u.STATS_INTERVAL).catch(e => {
                        if (!(e instanceof o.TimeoutError)) throw e
                    })
                }
                createUser(e, t, n) {
                    if (0 === t) {
                        this.logger.warn("Attempting to create user ".concat(e, " with 0 audio SSRC"));
                        return
                    }
                    let i = this.remoteAudioSSRCs[e],
                        s = this.remoteVideoSSRCs[e];
                    s = void 0 !== s ? [...s].sort() : [], n = void 0 === n ? null != s ? s : [] : [...n].sort();
                    let o = i !== t,
                        r = !a.isEqual(s, n);
                    if (this.remoteAudioSSRCs[e] = t, this.remoteVideoSSRCs[e] = null != n ? n : [], this.ids.userId !== e && (o || r)) {
                        let i = void 0 !== n && n.length > 0 ? n[0] : 0,
                            s = {
                                id: e,
                                ssrc: t,
                                videoSsrc: i,
                                videoSsrcs: n,
                                rtxSsrc: v(i),
                                mute: this.getLocalMute(e),
                                volume: this.getLocalVolume(e)
                            };
                        if (this.connectionState === S.ConnectionStates.CONNECTED) {
                            var l;
                            this.logger.info("Creating user: ".concat(e, " with audio SSRC: ").concat(t, " and video SSRCs: ").concat(null !== (l = null == n ? void 0 : n.join(",")) && void 0 !== l ? l : 0)), this.conn.mergeUsers([s])
                        }
                        let a = this.localPans[e];
                        null != a && this.setLocalPan(e, a.left, a.right);
                        let o = this.localSpeakingFlags[e];
                        null != o && o !== S.SpeakingFlags.NONE && this.setSpeakingFlags(e, o)
                    }
                }
                destroyUser(e) {
                    null != this.remoteAudioSSRCs[e] && (this.conn.destroyUser(e), delete this.remoteAudioSSRCs[e], delete this.remoteVideoSSRCs[e])
                }
                setSelfMute(e) {
                    this.selfMute = e, this.conn.setSelfMute(e), this.emit(c.BaseConnectionEvent.Mute, e)
                }
                setSelfDeaf(e) {
                    this.selfDeaf = e, this.conn.setSelfDeafen(e)
                }
                setSoundshareSource(e, t) {
                    if (this.soundshareId === e && this.soundshareSentSpeakingEvent || this.context !== S.MediaEngineContextTypes.STREAM) return;
                    this.soundshareId = e, this.soundshareSentSpeakingEvent = !1;
                    let n = e;
                    null === n && (n = 0), this.conn.setTransportOptions({
                        soundsharePid: n,
                        soundshareEventDriven: !0,
                        soundshareLoopback: t
                    })
                }
                setLocalMute(e, t) {
                    this.localMutes[e] = t, this.conn.setLocalMute(e, t), this.emit(c.BaseConnectionEvent.LocalMute, e, t)
                }
                fastUdpReconnect() {
                    null != this.conn.fastUdpReconnect && (this.numFastUdpReconnects += 1, this.conn.fastUdpReconnect())
                }
                getNumFastUdpReconnects() {
                    return null != this.conn.fastUdpReconnect ? this.numFastUdpReconnects : null
                }
                setLocalVideoDisabled(e, t) {
                    this.disabledLocalVideos[e] = t, this.emit(c.BaseConnectionEvent.LocalVideoDisabled, e, t)
                }
                setMinimumJitterBufferLevel(e) {
                    this.minimumJitterBufferLevel = e
                }
                setPostponeDecodeLevel(e) {
                    this.postponeDecodeLevel = e
                }
                getRemoteVideoSSRCsForUser(e) {
                    return this.remoteVideoSSRCs[e]
                }
                getRemoteAudioSSRCForUser(e) {
                    return this.remoteAudioSSRCs[e]
                }
                setClipRecordSsrc(e, t, n, i) {
                    if (!this.destroyed) {
                        var s, a, o, r;
                        null != this.conn.setClipRecordSsrc2 ? null === (s = (a = this.conn).setClipRecordSsrc2) || void 0 === s || s.call(a, e, this.context === S.MediaEngineContextTypes.STREAM ? "application" : "user", i) : null != this.conn.setClipRecordSsrc && (null === (o = (r = this.conn).setClipRecordSsrc) || void 0 === o || o.call(r, e, t, n, i))
                    }
                }
                getLocalVolume(e) {
                    var t;
                    let n = this.localVolumes[e];
                    return null == n && (n = this.context === S.MediaEngineContextTypes.DEFAULT ? S.DEFAULT_VOLUME : S.DEFAULT_STREAM_VOLUME), (null != (t = n) ? t : S.DEFAULT_VOLUME) / S.DEFAULT_VOLUME
                }
                setLocalVolume(e, t) {
                    this.localVolumes[e] = t;
                    try {
                        this.conn.setLocalVolume(e, this.getLocalVolume(e))
                    } catch {
                        this.logger.warn("Failed to set volume for user: ".concat(e, ": ").concat(t))
                    }
                }
                setLocalPan(e, t, n) {
                    this.localPans[e] = {
                        left: t,
                        right: n
                    }, this.conn.setLocalPan(e, t, n)
                }
                isAttenuating() {
                    return this.attenuationFactor < 1
                }
                setAttenuation(e, t, n) {
                    this.attenuationFactor = (100 - e) / 100, this.attenuateWhileSpeakingSelf = t, this.attenuateWhileSpeakingOthers = n, this.conn.setTransportOptions(this.getAttenuationOptions())
                }
                setCanHavePriority(e, t) {
                    var n, i;
                    null === (n = (i = this.conn).setRemoteUserCanHavePriority) || void 0 === n || n.call(i, e, t)
                }
                setBitRate(e) {
                    this.setVoiceBitRate(e)
                }
                setVoiceBitRate(e) {
                    if (this.voiceBitrate === e) return;
                    this.voiceBitrate = e;
                    let t = this.voiceBitrate;
                    this.soundshareActive && (t = Math.max(S.DEFAULT_SOUNDSHARE_VOICE_BITRATE, t)), this.conn.setTransportOptions({
                        encodingVoiceBitRate: t
                    })
                }
                setCameraBitRate(e, t, n) {
                    null != n || null != t ? this.videoQualityManager.setQuality({
                        bitrateMin: null != n && n > 0 ? n : t,
                        bitrateMax: t
                    }) : this.videoQualityManager.setQuality({}), !this.hasDesktopSource() && this.conn.setTransportOptions({
                        encodingVideoBitRate: e,
                        encodingVideoMinBitRate: n,
                        encodingVideoMaxBitRate: t
                    })
                }
                setEchoCancellation(e) {
                    this.echoCancellation = e, (0, f.getVoiceEngine)().setTransportOptions({
                        echoCancellation: this.echoCancellation
                    })
                }
                setNoiseSuppression(e) {
                    this.noiseSuppression = e, (0, f.getVoiceEngine)().setTransportOptions({
                        noiseSuppression: this.noiseSuppression
                    })
                }
                setAutomaticGainControl(e) {
                    this.automaticGainControl = e, (0, f.getVoiceEngine)().setTransportOptions({
                        automaticGainControl: this.automaticGainControl
                    })
                }
                setNoiseCancellation(e) {
                    this.noiseCancellation = e, (0, f.getVoiceEngine)().setTransportOptions({
                        noiseCancellation: this.noiseCancellation
                    })
                }
                setExperimentalEncoders(e) {
                    this.experimentalEncoders = e, this.conn.setTransportOptions({
                        experimentalEncoders: this.experimentalEncoders
                    })
                }
                setHardwareH264(e) {
                    this.hardwareH264 = e, this.conn.setTransportOptions({
                        hardwareH264: this.hardwareH264
                    })
                }
                setQoS(e) {
                    this.qos = e, this.conn.setTransportOptions({
                        qos: this.qos
                    })
                }
                setInputMode(e, t) {
                    switch (this.inputMode = e, e) {
                        case S.InputModes.PUSH_TO_TALK:
                            this.pttReleaseDelay = t.pttReleaseDelay;
                            break;
                        case S.InputModes.VOICE_ACTIVITY:
                            this.vadThreshold = t.vadThreshold, this.vadAutoThreshold = t.vadAutoThreshold, this.vadUseKrisp = t.vadUseKrisp, this.vadLeading = t.vadLeading, this.vadTrailing = t.vadTrailing;
                            break;
                        default:
                            throw Error("Unknown Input Mode: ".concat(e))
                    }
                    this.conn.setTransportOptions({
                        inputMode: S.NATIVE_MODE_VALUES[this.inputMode],
                        inputModeOptions: this.createInputModeOptions()
                    })
                }
                setSilenceThreshold(e) {
                    (0, f.getVoiceEngine)().setNoInputThreshold(e)
                }
                setForceAudioInput(e) {
                    let t = arguments.length > 1 && void 0 !== arguments[1] && arguments[1];
                    t ? this.forceAudioPriority = e : this.forceAudioNormal = e, this.conn.setPTTActive(this.forceAudioPriority || this.forceAudioNormal, this.forceAudioPriority)
                }
                setSpeakingFlags(e, t) {
                    null != this.conn.setRemoteUserSpeakingStatus ? this.conn.setRemoteUserSpeakingStatus(e, t) : null != this.conn.setRemoteUserSpeaking && this.conn.setRemoteUserSpeaking(e, (t & S.SpeakingFlags.VOICE) === S.SpeakingFlags.VOICE), this.handleSpeakingFlags(e, t)
                }
                clearAllSpeaking() {}
                setEncryption(e, t) {
                    this.logger.info("Selected encryption mode: ".concat(e)), this.conn.setTransportOptions({
                        encryptionSettings: {
                            mode: e,
                            secretKey: t
                        }
                    })
                }
                setReconnectInterval(e) {
                    this.reconnectInterval = e, this.conn.setTransportOptions({
                        reconnectInterval: this.reconnectInterval
                    })
                }
                setKeyframeInterval(e) {
                    this.keyframeInterval = e, this.conn.setTransportOptions({
                        keyframeInterval: this.keyframeInterval
                    })
                }
                setVideoQualityMeasurement(e) {
                    this.videoQualityMeasurement = e, this.conn.setTransportOptions({
                        videoQualityMeasurement: this.videoQualityMeasurement
                    })
                }
                setVideoEncoderExperiments(e) {
                    this.videoEncoderExperiments = e, this.conn.setTransportOptions({
                        videoEncoderExperiments: this.videoEncoderExperiments
                    })
                }
                setVideoBroadcast(e) {
                    this.selfVideo !== e && (this.selfVideo = e, this.applyVideoTransportOptions())
                }
                setGoLiveSource(e) {
                    let {
                        resolution: t,
                        frameRate: n
                    } = e.quality, i = t <= 480 ? t / 3 * 4 : t / 9 * 16, s = null;
                    if (null != e.desktopDescription ? s = e.desktopDescription.id : null != e.cameraDescription && (s = "".concat(e.cameraDescription.videoDeviceGuid, ":").concat(e.cameraDescription.audioDeviceGuid)), this.goLiveSourceIdentifier === s) {
                        this.setDesktopEncodingOptions(i, t, n);
                        return
                    }
                    if (this.goLiveSourceIdentifier = s, null != this.conn.setDesktopSource) {
                        if (null != e.desktopDescription) {
                            let {
                                id: t,
                                soundshareId: n,
                                useLoopback: i,
                                useVideoHook: s,
                                useGraphicsCapture: a,
                                useQuartzCapturer: o,
                                allowScreenCaptureKit: r,
                                videoHookStaleFrameTimeoutMs: l,
                                graphicsCaptureStaleFrameTimeoutMs: u,
                                hdrCaptureMode: d
                            } = e.desktopDescription;
                            this.setSoundshareSource(n, i);
                            let [c, h] = null != t ? t.split(":") : ["", ""];
                            null != t ? this.logger.info("capturing desktop (type: ".concat(c, ", handle: ").concat(h, ", use-video-hook: ").concat(s.toString(), ", use-graphics-capture: ").concat(null == a ? void 0 : a.toString(), ").")) : this.logger.info("capturing desktop (type: <stop>)."), null != this.conn.setDesktopSourceWithOptions ? null != t ? this.conn.setDesktopSourceWithOptions({
                                type: c,
                                sourceId: h,
                                useVideoHook: s,
                                useGraphicsCapture: a,
                                useQuartzCapturer: o,
                                allowScreenCaptureKit: r,
                                videoHookStaleFrameTimeoutMs: l,
                                graphicsCaptureStaleFrameTimeoutMs: u,
                                hdrCaptureMode: d
                            }) : this.conn.clearDesktopSource() : this.conn.setDesktopSource("wumpus-".concat(h), s, c)
                        } else if (null != e.cameraDescription) {
                            let {
                                videoDeviceGuid: t,
                                audioDeviceGuid: n
                            } = e.cameraDescription;
                            this.conn.setGoLiveDevices({
                                videoInputDeviceId: t,
                                audioInputDeviceId: n
                            })
                        }
                        this.setDesktopEncodingOptions(i, t, n)
                    }
                }
                clearGoLiveDevices() {
                    null != this.goLiveSourceIdentifier && this.setDesktopEncodingOptions(1280, 720, 30), null != this.conn.clearGoLiveDevices && this.conn.clearGoLiveDevices()
                }
                clearDesktopSource() {
                    null != this.goLiveSourceIdentifier && this.setDesktopEncodingOptions(1280, 720, 30), this.goLiveSourceIdentifier = null, null != this.conn.clearDesktopSource ? this.conn.clearDesktopSource() : this.conn.setDesktopSource("", !1, "")
                }
                setDesktopSourceStatusCallback(e) {
                    var t, n;
                    null === (t = (n = this.conn).setDesktopSourceStatusCallback) || void 0 === t || t.call(n, e)
                }
                hasDesktopSource() {
                    return null != this.goLiveSourceIdentifier
                }
                setDesktopEncodingOptions(e, t, n) {
                    if (this.destroyed) return;
                    let i = 0 === t || t > 720 || n > 30 ? g.DESKTOP_BITRATE_ENHANCED : g.DESKTOP_BITRATE,
                        s = {
                            width: e,
                            height: t,
                            framerate: n
                        },
                        a = this.videoQualityManager.getQuality();
                    (!d.VideoQuality.equals(s, a.capture) || a.bitrateMax !== i) && (this.videoQualityManager.setQuality({
                        capture: s,
                        bitrateMax: i
                    }), this.videoStreamParameters.length > 0 && (this.videoStreamParameters[0].maxResolution = {
                        type: 0 === e && 0 === t ? S.ResolutionTypes.SOURCE : S.ResolutionTypes.FIXED,
                        width: e,
                        height: t
                    }, this.videoStreamParameters[0].maxFrameRate = n, this.videoStreamParameters[0].maxBitrate = i), this.emit(c.BaseConnectionEvent.Video, this.ids.userId, null, this.audioSSRC, this.videoStreamParameters[0].ssrc, v(this.videoStreamParameters[0].ssrc), this.videoStreamParameters), this.conn.setTransportOptions(this.applyQualityConstraints().constraints))
                }
                setSDP(e) {}
                setRemoteVideoSinkWants(e) {
                    this.remoteVideoSinkWants = e, this.updateVideoQuality(g.MEDIA_SINK_WANTS_PROPERTIES)
                }
                setLocalVideoSinkWants(e) {
                    let t = this.localVideoSinkWants;
                    for (let [o, r] of Object.entries(this.remoteVideoSSRCs)) {
                        var n, i, s, a;
                        let l = 0,
                            u = 0;
                        for (let n of r) l += null == t ? void 0 : t[n], u += null == e ? void 0 : e[n];
                        0 === l && 0 !== u && (null === (n = (i = this.conn).setDisableLocalVideo) || void 0 === n || n.call(i, o, !1)), 0 !== l && 0 === u && (null === (s = (a = this.conn).setDisableLocalVideo) || void 0 === s || s.call(a, o, !0))
                    }
                    this.localVideoSinkWants = e
                }
                startSamplesPlayback(e, t, n) {
                    if (e.numberOfChannels > 2) {
                        n(1, "Too many channels");
                        return
                    }
                    for (var i = [], s = 0; s < e.numberOfChannels; s++) {
                        var a = e.getChannelData(s);
                        i.push(a)
                    }
                    try {
                        this.conn.startSamplesPlayback({
                            sampleRate: e.sampleRate,
                            volume: t
                        }, i, n)
                    } catch (t) {
                        this.conn.startSamplesPlayback(e.sampleRate, i, n)
                    }
                }
                stopSamplesPlayback() {
                    this.conn.stopSamplesPlayback()
                }
                startSamplesLocalPlayback(e, t, n, i) {
                    if (t.numberOfChannels > 2) {
                        i(1, "Too many channels");
                        return
                    }
                    for (var s = [], a = 0; a < t.numberOfChannels; a++) {
                        var o = t.getChannelData(a);
                        s.push(o)
                    }
                    this.conn.startSamplesLocalPlayback(e, {
                        sampleRate: t.sampleRate,
                        volume: n
                    }, s, i)
                }
                stopAllSamplesLocalPlayback() {
                    this.conn.stopAllSamplesLocalPlayback()
                }
                stopSamplesLocalPlayback(e) {
                    this.conn.stopSamplesLocalPlayback(e)
                }
                setBandwidthEstimationExperiments(e) {
                    this.conn.setTransportOptions({
                        bandwidthEstimationExperiments: e
                    })
                }
                updateVideoQualityCore(e, t) {
                    this.videoSupported && !this.destroyed && this.conn.setTransportOptions(e)
                }
                setStreamParameters(e) {
                    return new Promise((t, n) => {
                        for (let t of this.videoStreamParameters) {
                            let i = e.findIndex(e => e.rid === t.rid);
                            if (-1 === i) {
                                n(Error("Invalid rid"));
                                return
                            }
                            let s = [];
                            !a.isEqual(this.videoStreamParameters[i], e[i]) && (this.videoStreamParameters[i] = {
                                ...e[i]
                            }, s.push({
                                ...e[i]
                            })), this.conn.setTransportOptions({
                                streamParameters: s
                            })
                        }
                        t()
                    })
                }
                applyVideoTransportOptions() {
                    if (!this.videoSupported) return;
                    let e = !1;
                    if (this.hasDesktopSource() && this.videoStreamParameters.length > 0) {
                        var t;
                        e = (null === (t = this.videoStreamParameters[0].maxResolution) || void 0 === t ? void 0 : t.type) === S.ResolutionTypes.SOURCE
                    }
                    this.conn.setTransportOptions(this.applyQualityConstraints({
                        encodingVideoDegradationPreference: this.hasDesktopSource() ? e ? this.sourceDesktopDegradationPreference : this.desktopDegradationPreference : this.videoDegradationPreference
                    }).constraints), this.conn.setVideoBroadcast(this.selfVideo)
                }
                chooseEncryptionMode(e, t) {
                    for (let n of t)
                        for (let t of e)
                            if (n === t) return n;
                    return "xsalsa20_poly1305"
                }
                getUserOptions() {
                    return Object.keys(this.remoteAudioSSRCs).map(e => {
                        let t = void 0 !== this.remoteVideoSSRCs[e] && this.remoteVideoSSRCs[e].length > 0 ? this.remoteVideoSSRCs[e][0] : 0;
                        return {
                            id: e,
                            ssrc: this.remoteAudioSSRCs[e],
                            videoSsrc: t,
                            videoSsrcs: this.remoteVideoSSRCs[e],
                            rtxSsrc: v(t),
                            mute: this.getLocalMute(e),
                            volume: this.getLocalVolume(e)
                        }
                    })
                }
                createInputModeOptions() {
                    switch (this.inputMode) {
                        case S.InputModes.VOICE_ACTIVITY:
                            return {
                                vadThreshold: this.vadThreshold, vadAutoThreshold: this.vadAutoThreshold ? p.VADAggressiveness.VERY_AGGRESSIVE : p.VADAggressiveness.DISABLED, vadUseKrisp: this.vadUseKrisp, vadLeading: this.vadLeading, vadTrailing: this.vadTrailing
                            };
                        case S.InputModes.PUSH_TO_TALK:
                            return {
                                pttReleaseDelay: this.pttReleaseDelay
                            };
                        default:
                            throw Error("Unknown Input Mode: ".concat(this.inputMode))
                    }
                }
                getAttenuationOptions() {
                    return {
                        attenuation: this.isAttenuating(),
                        attenuationFactor: this.attenuationFactor,
                        attenuateWhileSpeakingSelf: this.attenuateWhileSpeakingSelf,
                        attenuateWhileSpeakingOthers: this.attenuateWhileSpeakingOthers
                    }
                }
                getCodecParams(e, t) {
                    if (e !== S.Codecs.H264) return {};
                    if (t) return {
                        "level-asymmetry-allowed": "1",
                        "packetization-mode": "1",
                        "profile-level-id": "42e034",
                        "hardware-h264": this.hardwareH264 && this.useElectronVideo && E.default.useDirectVideo ? "1" : "0"
                    };
                    {
                        let e = "android" === (0, f.getVoiceEngine)().platform ? "42e01f" : "4d0033";
                        return {
                            "level-asymmetry-allowed": "1",
                            "packetization-mode": "1",
                            "profile-level-id": e,
                            "hardware-h264": this.hardwareH264 && this.useElectronVideo && E.default.useDirectVideo ? "1" : "0"
                        }
                    }
                }
                getCodecOptions(e, t, n) {
                    var i, s, a, o;
                    let r;
                    r = this.codecs.find(t => t.name === e);
                    let l = {
                            type: null !== (i = null == r ? void 0 : r.payloadType) && void 0 !== i ? i : 0,
                            name: e,
                            freq: 48e3,
                            pacsize: 960,
                            channels: 1,
                            rate: 64e3
                        },
                        u = [{
                            type: null !== (s = null == r ? void 0 : r.payloadType) && void 0 !== s ? s : 0,
                            name: e,
                            freq: 48e3,
                            channels: 2,
                            params: {
                                stereo: "1"
                            }
                        }];
                    n === S.MediaEngineContextTypes.STREAM && (l.channels = 2);
                    let d = [],
                        c = {
                            name: "",
                            type: 0,
                            rtxType: 0,
                            params: {}
                        };
                    for (r of this.codecs) {
                        if (r.name === e) continue;
                        let n = {
                            name: (0, h.codecNameToPayloadName)(r.name),
                            type: null !== (a = null == r ? void 0 : r.payloadType) && void 0 !== a ? a : 0,
                            rtxType: null !== (o = null == r ? void 0 : r.rtxPayloadType) && void 0 !== o ? o : 0,
                            params: this.getCodecParams(r.name, !0)
                        };
                        d.push(n), r.name === t && (c = {
                            ...n,
                            params: this.getCodecParams(r.name, !1)
                        }, this.experimentFlags.has(g.ExperimentFlags.VIDEOTOOLBOX_RATE_CONTROL) && (c.params["fixed-rate-presentation-timestamps"] = "1"))
                    }
                    return {
                        videoEncoder: c,
                        videoDecoders: d,
                        audioEncoder: l,
                        audioDecoders: u
                    }
                }
                getConnectionTransportOptions() {
                    let e = {
                        selfMute: this.selfMute,
                        inputMode: S.NATIVE_MODE_VALUES[this.inputMode],
                        inputModeOptions: this.createInputModeOptions(),
                        minimumJitterBufferLevel: this.minimumJitterBufferLevel,
                        postponeDecodeLevel: this.postponeDecodeLevel,
                        ...this.getAttenuationOptions(),
                        fec: !0,
                        packetLossRate: .3,
                        qos: this.qos,
                        prioritySpeakerDucking: S.DEFAULT_PRIORITY_SPEAKER_DUCKING,
                        encodingVoiceBitRate: this.voiceBitrate,
                        callBitRate: S.DEFAULT_CALL_BITRATE,
                        callMinBitRate: S.DEFAULT_CALL_MIN_BITRATE,
                        callMaxBitRate: S.DEFAULT_CALL_MAX_BITRATE,
                        encodingVideoDegradationPreference: this.videoDegradationPreference,
                        experimentalEncoders: this.experimentalEncoders,
                        hardwareH264: this.hardwareH264,
                        reconnectInterval: this.reconnectInterval,
                        userChannelIds: this.ids
                    };
                    return (0, f.supportsFeature)(S.NativeFeatures.VIDEO_EFFECTS) && this.context === S.MediaEngineContextTypes.STREAM && (e.enableVideoEffects = !0), e
                }
                setStream(e) {
                    throw Error("Method not implemented.")
                }
                getUserIdBySsrc(e) {}
                setRtcLogEphemeralKey(e) {
                    this.conn.setTransportOptions({
                        userChannelIds: this.ids,
                        rtcLogEphemeralKey: e
                    })
                }
                setRtcLogMarker(e) {
                    null != this.conn.setRtcLogMarker && this.conn.setRtcLogMarker(e)
                }
                prepareSecureFramesTransition(e, t, n) {
                    var i, s;
                    null === (i = (s = this.conn).prepareSecureFramesTransition) || void 0 === i || i.call(s, e, t, n)
                }
                executeSecureFramesTransition(e) {
                    var t, n;
                    null === (t = (n = this.conn).executeSecureFramesTransition) || void 0 === t || t.call(n, e)
                }
                constructor(e, t, n) {
                    super(e, t), this.mediaEngineConnectionId = "Native-".concat(_++), this.selfMute = !1, this.selfVideo = !1, this.forceAudioNormal = !1, this.forceAudioPriority = !1, this.codecs = [], this.videoEncoderFallbackPending = !1, this.desktopDegradationPreference = (0, f.getVoiceEngine)().DegradationPreference.MAINTAIN_FRAMERATE, this.sourceDesktopDegradationPreference = (0, f.getVoiceEngine)().DegradationPreference.DISABLED, this.videoDegradationPreference = (0, f.getVoiceEngine)().DegradationPreference.BALANCED, this.localPans = {}, this.remoteAudioSSRCs = {}, this.remoteVideoSSRCs = {}, this.inputMode = S.InputModes.VOICE_ACTIVITY, this.vadThreshold = -40, this.vadAutoThreshold = !0, this.vadUseKrisp = !0, this.vadLeading = 5, this.vadTrailing = 25, this.pttReleaseDelay = 20, this.soundshareActive = !1, this.soundshareId = null, this.soundshareSentSpeakingEvent = !1, this.echoCancellation = !0, this.noiseSuppression = !0, this.automaticGainControl = !0, this.noiseCancellation = !1, this.experimentalEncoders = !1, this.hardwareH264 = !0, this.attenuationFactor = .5, this.attenuateWhileSpeakingSelf = !1, this.attenuateWhileSpeakingOthers = !0, this.qos = !0, this.minimumJitterBufferLevel = 0, this.postponeDecodeLevel = 100, this.reconnectInterval = 6e4, this.keyframeInterval = 0, this.videoQualityMeasurement = "", this.videoEncoderExperiments = "", this.numFastUdpReconnects = 0, this.handleSpeakingNative = (e, t) => {
                        let n = S.SpeakingFlags.NONE;
                        n = "boolean" == typeof t ? t ? S.SpeakingFlags.VOICE : S.SpeakingFlags.NONE : t, this.handleSpeakingFlags(e, n)
                    }, this.handleSpeakingFlags = (e, t) => {
                        this.localSpeakingFlags[e] = t;
                        let n = e === this.ids.userId ? this.audioSSRC : this.remoteAudioSSRCs[e];
                        this.emit(c.BaseConnectionEvent.Speaking, e, t, n), (t & S.SpeakingFlags.SOUNDSHARE) != 0 && !1 === this.soundshareSentSpeakingEvent && (this.emit(c.BaseConnectionEvent.SoundshareSpeaking), this.soundshareSentSpeakingEvent = !0)
                    }, this.handleSpeakingWhileMuted = () => {
                        this.emit(c.BaseConnectionEvent.SpeakingWhileMuted)
                    }, this.handlePing = (e, t, n) => {
                        this.emit(c.BaseConnectionEvent.Ping, e)
                    }, this.handlePingTimeout = (e, t, n, i) => {
                        this.emit(c.BaseConnectionEvent.PingTimeout, n, i > 0 ? i : 4e3)
                    }, this.handleVideoEncoderFallback = e => {
                        !this.videoEncoderFallbackPending && (this.logger.info("Falling back from current video encoder:" + e), this.codecs = this.codecs.map(t => ((e === t.name || "AV1" === t.name && "AV1X" === e) && (t.encode = !1), t)).filter(e => !("video" === e.type && !1 === e.encode && !1 === e.decode)), this.emit(c.BaseConnectionEvent.VideoEncoderFallback, this.codecs), this.videoEncoderFallbackPending = !0)
                    }, this.handleVideo = (e, t, n, i) => {
                        let s = a.cloneDeep(this.videoStreamParameters);
                        e === this.ids.userId ? (this.experimentFlags.has(g.ExperimentFlags.STREAMER_CLIP) && this.context === S.MediaEngineContextTypes.STREAM && this.streamUserId === this.ids.userId && t > 0 && this.setClipRecordSsrc(t, "video", "outbound", !0), null != i && Array.isArray(i) && i.length > 0 ? i.forEach(e => {
                            s.forEach((t, n) => {
                                t.rid === e.rid && (s[n] = {
                                    ...t,
                                    ssrc: e.ssrc,
                                    rtxSsrc: e.rtxSsrc,
                                    active: e.active
                                })
                            })
                        }) : t > 0 ? (s[0].active = !0, s[0].ssrc = t, s[0].rtxSsrc = v(t)) : s[0].active = !1) : t > 0 && (void 0 !== this.remoteVideoSSRCs[e] ? !this.remoteVideoSSRCs[e].includes(t) && (this.remoteVideoSSRCs[e] = [...this.remoteVideoSSRCs[e], t]) : this.remoteVideoSSRCs[e] = [t]), this.videoStreamParameters = s, this.emit(c.BaseConnectionEvent.Video, e, null != n && "" !== n ? n : null, e === this.ids.userId ? this.audioSSRC : this.remoteAudioSSRCs[e], t, v(t), this.videoStreamParameters)
                    }, this.handleFirstFrame = (e, t, n) => {
                        this.emit(c.BaseConnectionEvent.FirstFrame, e, t, n)
                    }, this.handleNoInput = e => {
                        this.emit(c.BaseConnectionEvent.Silence, !e)
                    }, this.handleDesktopSourceEnded = () => {
                        this.emit(c.BaseConnectionEvent.DesktopSourceEnd)
                    }, this.handleSoundshare = e => {
                        e && (this.soundshareActive = !0, this.conn.setTransportOptions({
                            encodingVoiceBitRate: Math.max(S.DEFAULT_SOUNDSHARE_VOICE_BITRATE, this.voiceBitrate)
                        }), this.emit(c.BaseConnectionEvent.SoundshareAttached))
                    }, this.handleSoundshareFailed = (e, t, n) => {
                        this.emit(c.BaseConnectionEvent.SoundshareFailed, {
                            failureCode: e,
                            failureReason: t,
                            willRetry: n
                        })
                    }, this.handleSoundshareEnded = () => {
                        this.soundshareActive = !1, !this.destroyed && this.conn.setTransportOptions({
                            encodingVoiceBitRate: this.voiceBitrate
                        })
                    }, this.handleNewListenerNative = e => {
                        if (e === c.BaseConnectionEvent.ConnectionStateChange) this.emit(e, this.connectionState)
                    }, this.handleStats = e => {
                        if (this.connectionState === S.ConnectionStates.DISCONNECTED) {
                            this.off(c.BaseConnectionEvent.Stats, this.handleStats);
                            return
                        }
                        if (null != e) {
                            if (null != this.stats) {
                                let t = a.reduce(e.rtp.outbound, (e, t) => {
                                        var n, i;
                                        return e.lost += null !== (n = t.packetsLost) && void 0 !== n ? n : 0, e.sent += null !== (i = t.packetsSent) && void 0 !== i ? i : 0, e
                                    }, {
                                        lost: 0,
                                        sent: 0
                                    }),
                                    n = a.reduce(this.stats.rtp.outbound, (e, t) => {
                                        var n, i;
                                        return e.lost += null !== (n = t.packetsLost) && void 0 !== n ? n : 0, e.sent += null !== (i = t.packetsSent) && void 0 !== i ? i : 0, e
                                    }, {
                                        lost: 0,
                                        sent: 0
                                    }),
                                    i = t.sent - n.sent,
                                    s = t.lost - n.lost;
                                if (0 === i) this.emit(c.BaseConnectionEvent.OutboundLossRate, 0);
                                else if (i > 0 && s >= 0) {
                                    let e = a.clamp(s / (i + s), 0, 1);
                                    this.emit(c.BaseConnectionEvent.OutboundLossRate, 100 * e)
                                }
                                let o = e.rtp.outbound.filter(e => "audio" === e.type)[0],
                                    r = this.stats.rtp.outbound.filter(e => "audio" === e.type)[0];
                                if (null != o && null != r && null != o.framesCaptured && null != r.framesCaptured) {
                                    let e = o.framesCaptured - r.framesCaptured;
                                    if (this.noiseCancellation && e > 50 && null != o.noiseCancellerProcessTime && null != r.noiseCancellerProcessTime) {
                                        let t = o.noiseCancellerProcessTime - r.noiseCancellerProcessTime;
                                        t / e > 8 ? this.emit(c.BaseConnectionEvent.NoiseCancellationError, S.NoiseCancellerError.CPU_OVERUSE) : 0 === t && this.emit(c.BaseConnectionEvent.NoiseCancellationError, S.NoiseCancellerError.FAILED)
                                    }
                                    if (this.inputMode === S.InputModes.VOICE_ACTIVITY && this.vadAutoThreshold && this.vadUseKrisp && e > 50 && null != o.voiceActivityDetectorProcessTime && null != r.voiceActivityDetectorProcessTime) {
                                        let t = o.voiceActivityDetectorProcessTime - r.voiceActivityDetectorProcessTime;
                                        t / e > 4 && this.emit(c.BaseConnectionEvent.VoiceActivityDetectorError, S.NoiseCancellerError.VAD_CPU_OVERUSE)
                                    }
                                }
                            }
                            this.stats = e
                        }
                    }, this.logger = new r.default("Connection(".concat(e, ")")), this.videoSupported = n
                }
            }
        },
        149416: function(e, t, n) {
            "use strict";
            n.r(t), n.d(t, {
                AudioSubsystems: function() {
                    return u.AudioSubsystems
                },
                DeviceTypes: function() {
                    return u.DeviceTypes
                },
                InputModes: function() {
                    return u.InputModes
                },
                ConnectionStates: function() {
                    return u.ConnectionStates
                },
                SpeakingFlags: function() {
                    return u.SpeakingFlags
                },
                DEFAULT_VOLUME: function() {
                    return u.DEFAULT_VOLUME
                },
                DEFAULT_STREAM_VOLUME: function() {
                    return u.DEFAULT_STREAM_VOLUME
                },
                DEFAULT_SOUNDSHARE_VOICE_BITRATE: function() {
                    return u.DEFAULT_SOUNDSHARE_VOICE_BITRATE
                },
                DEFAULT_CALL_BITRATE: function() {
                    return u.DEFAULT_CALL_BITRATE
                },
                DEFAULT_CALL_MIN_BITRATE: function() {
                    return u.DEFAULT_CALL_MIN_BITRATE
                },
                DEFAULT_CALL_MAX_BITRATE: function() {
                    return u.DEFAULT_CALL_MAX_BITRATE
                },
                DEFAULT_DEVICE_ID: function() {
                    return u.DEFAULT_DEVICE_ID
                },
                DISABLED_DEVICE_ID: function() {
                    return u.DISABLED_DEVICE_ID
                },
                DEFAULT_PRIORITY_SPEAKER_DUCKING: function() {
                    return u.DEFAULT_PRIORITY_SPEAKER_DUCKING
                },
                MediaEngineContextTypes: function() {
                    return u.MediaEngineContextTypes
                },
                Codecs: function() {
                    return u.Codecs
                },
                Features: function() {
                    return u.Features
                },
                NoiseCancellerError: function() {
                    return u.NoiseCancellerError
                },
                ResolutionTypes: function() {
                    return u.ResolutionTypes
                },
                PING_INTERVAL: function() {
                    return u.PING_INTERVAL
                },
                WATCHDOG_TIMEOUT_MS: function() {
                    return d
                },
                NATIVE_MODE_VALUES: function() {
                    return c
                },
                NativeFeatures: function() {
                    return o
                },
                ProcessPriority: function() {
                    return r
                },
                ClipsRecordingEvent: function() {
                    return l
                }
            });
            var i, s, a, o, r, l, u = n("353927");
            let d = 3e4,
                c = {
                    [u.InputModes.VOICE_ACTIVITY]: 1,
                    [u.InputModes.PUSH_TO_TALK]: 2
                };
            (i = o || (o = {})).VOICE_SOUND_STOP_LOOP = "voice_sound_stop_loop", i.VOICE_RELATIVE_SOUNDS = "voice_relative_sounds", i.VOICE_LEGACY_SUBSYSTEM = "voice_legacy_subsystem", i.VOICE_EXPERIMENTAL_SUBSYSTEM = "voice_experimental_subsystem", i.ELEVATED_HOOK = "elevated_hook", i.DEBUG_LOGGING = "debug_logging", i.SOUNDSHARE = "soundshare", i.SOUNDSHARE_LOOPBACK = "soundshare_loopback", i.SET_AUDIO_DEVICE_BY_ID = "set_audio_device_by_id", i.SET_VIDEO_DEVICE_BY_ID = "set_video_device_by_id", i.LOOPBACK = "loopback", i.WUMPUS_VIDEO = "wumpus_video", i.HYBRID_VIDEO = "hybrid_video", i.EXPERIMENTAL_ENCODERS = "experimental_encoders", i.EXPERIMENT_CONFIG = "experiment_config", i.REMOTE_LOCUS_NETWORK_CONTROL = "remote_locus_network_control", i.SCREEN_PREVIEWS = "screen_previews", i.WINDOW_PREVIEWS = "window_previews", i.AUDIO_DEBUG_STATE = "audio_debug_state", i.CONNECTION_REPLAY = "connection_replay", i.SIMULCAST = "simulcast", i.SIMULCAST_BUGFIX = "simulcast_bugfix", i.RTC_REGION_RANKING = "RTC_REGION_RANKING", i.VIDEO_EFFECTS = "video_effects", i.DIRECT_VIDEO = "direct_video", i.ELECTRON_VIDEO = "electron_video", i.MEDIAPIPE = "mediapipe", i.FIXED_KEYFRAME_INTERVAL = "fixed_keyframe_interval", i.FIRST_FRAME_CALLBACK = "first_frame_callback", i.REMOTE_USER_MULTI_STREAM = "remote_user_multi_stream", i.CLIPS = "clips", i.SPEED_TEST = "speed_test", i.GO_LIVE_HARDWARE = "go_live_hardware", i.IMAGE_QUALITY_MEASUREMENT = "image_quality_measurement", i.AMD_EXPERIMENTAL_RATE_CONTROL = "amd_experimental_rate_control", i.SCREEN_CAPTURE_KIT = "screen_capture_kit", i.CAPTURE_TIMEOUT_EXPERIMENTS = "capture_timeout_experiments", (s = r || (r = {}))[s.LOW = 2] = "LOW", s[s.BELOW_NORMAL = 1] = "BELOW_NORMAL", s[s.NORMAL = 0] = "NORMAL", s[s.ABOVE_NORMAL = -1] = "ABOVE_NORMAL", s[s.HIGH = -2] = "HIGH", (a = l || (l = {}))[a.Started = 0] = "Started", a[a.Ended = 1] = "Ended", a[a.Error = 2] = "Error", a[a.TransferredToVoiceCall = 3] = "TransferredToVoiceCall", a[a.TransferredToGoLive = 4] = "TransferredToGoLive", a[a.StoppedByGoLive = 5] = "StoppedByGoLive", a[a.BlockedByGoLive = 6] = "BlockedByGoLive", a[a.GoLiveEnded = 7] = "GoLiveEnded"
        },
        446497: function(e, t, n) {
            "use strict";
            n.r(t), n.d(t, {
                sanitizeDevices: function() {
                    return r
                },
                getAudioInputDevices: function() {
                    return l
                },
                getAudioOutputDevices: function() {
                    return u
                },
                getVideoInputDevices: function() {
                    return d
                }
            }), n("781738"), n("843762");
            var i = n("383536"),
                s = n.n(i),
                a = n("784063"),
                o = n("149416");

            function r(e, t) {
                var n;
                let i = !1,
                    a = t.map((t, n) => {
                        let {
                            guid: s,
                            guid: a,
                            name: r,
                            name: l,
                            index: u
                        } = t;
                        return /^default/.test(r) ? (i = !0, s = o.DEFAULT_DEVICE_ID, r = r.replace("default", "Default")) : s = null != s && "" !== s ? s : r, null != u && (n = u), {
                            id: s,
                            type: e,
                            index: n,
                            name: r,
                            originalName: l,
                            originalId: a
                        }
                    });
                return e !== o.DeviceTypes.VIDEO_INPUT && !i && (null == s ? void 0 : null === (n = s.os) || void 0 === n ? void 0 : n.family) != null && /^win/i.test(s.os.family) && a.unshift({
                    id: o.DEFAULT_DEVICE_ID,
                    type: e,
                    index: -1,
                    name: "Default"
                }), a
            }

            function l() {
                return new Promise(e => {
                    (0, a.getVoiceEngine)().getInputDevices(t => e(r(o.DeviceTypes.AUDIO_INPUT, t)))
                })
            }

            function u() {
                return new Promise(e => {
                    (0, a.getVoiceEngine)().getOutputDevices(t => e(r(o.DeviceTypes.AUDIO_OUTPUT, t)))
                })
            }

            function d() {
                return new Promise(e => {
                    (0, a.getVoiceEngine)().getVideoInputDevices(t => e(r(o.DeviceTypes.VIDEO_INPUT, t)))
                })
            }
        },
        785347: function(e, t, n) {
            "use strict";
            n.r(t), n.d(t, {
                default: function() {
                    return i
                }
            }), n("854508"), n("70102"), n("222007");
            var i, s = n("811022"),
                a = n("571877"),
                o = n("773364"),
                r = n("784063"),
                l = n("149416");
            let u = new s.default("SpeedTester"),
                d = 0;
            i = class e extends a.default {
                static create(t, n) {
                    let i = new e(t);
                    return u.info("Creating connection to ".concat(n.address, ":").concat(n.port, " with audio ssrc: ").concat(n.ssrc)), i.initialize(n), i
                }
                initialize(e) {
                    let t;
                    this.audioSSRC = e.ssrc, this.streamUserId = e.streamUserId, this.pingInterval = l.PING_INTERVAL, this.initializeStreamParameters(e.streamParameters), e.streamParameters = this.videoStreamParameters;
                    let n = (0, r.getVoiceEngine)();
                    t = this.conn = n.createSpeedTestConnectionWithOptions(this.ids.userId, e, (n, i) => {
                        if (this.destroyed) return;
                        if (null != n && "" !== n) {
                            this.setConnectionState(l.ConnectionStates.NO_ROUTE), this.emit(o.BaseSpeedTesterEvent.Error, n);
                            return
                        }
                        if (null == i) throw Error("Invalid transport info");
                        let {
                            protocol: s,
                            address: a,
                            port: r
                        } = i;
                        u.info("Connected with local address ".concat(a, ":").concat(r, " and protocol: ").concat(s)), this.codecs = [{
                            type: "audio",
                            name: l.Codecs.OPUS,
                            priority: 1,
                            payloadType: 120
                        }, {
                            type: "test",
                            name: l.Codecs.TEST,
                            priority: 1,
                            payloadType: 127
                        }], t.getEncryptionModes(n => {
                            var i, d;
                            u.info("Encryption modes: ".concat(n)), t.setTransportOptions(this.getConnectionTransportOptions()), null === (i = t.setPingInterval) || void 0 === i || i.call(t, this.pingInterval), t.setPingCallback(this.handlePing), null === (d = t.setPingTimeoutCallback) || void 0 === d || d.call(t, this.handlePingTimeout), this.setConnectionState(l.ConnectionStates.CONNECTED), this.emit(o.BaseSpeedTesterEvent.Connected, s, {
                                address: a,
                                port: r,
                                mode: this.chooseEncryptionMode(e.modes, n),
                                codecs: this.codecs
                            })
                        })
                    }), this.on("newListener", this.handleNewListenerNative)
                }
                destroy() {
                    this.conn.destroy(), this.setConnectionState(l.ConnectionStates.DISCONNECTED), super.destroy()
                }
                setCodecs(e, t) {
                    this.conn.setTransportOptions(this.getCodecOptions(e, t))
                }
                setEncryption(e, t) {
                    this.conn.setTransportOptions({
                        encryptionSettings: {
                            mode: e,
                            secretKey: t
                        }
                    })
                }
                setSDP(e) {}
                getNetworkOverhead(e) {
                    this.conn.getNetworkOverhead(e)
                }
                setPingInterval(e) {
                    var t, n;
                    this.pingInterval = e, null === (t = (n = this.conn).setPingInterval) || void 0 === t || t.call(n, this.pingInterval)
                }
                startSpeedTestSender(e, t, n, i) {
                    null != this.conn.startSpeedTestSender ? this.conn.startSpeedTestSender({
                        clusterSize: t,
                        clusterIntervalMs: n,
                        numClusters: i
                    }, e) : this.conn.startClientToServerSpeedTest({
                        doneCb: e,
                        clusterSize: t,
                        clusterIntervalMs: n,
                        numClusters: i
                    })
                }
                stopSpeedTestSender() {
                    null != this.conn.stopSpeedTestSender ? this.conn.stopSpeedTestSender() : this.conn.endClientToServerSpeedTest({})
                }
                startSpeedTestReceiver(e, t) {
                    null != this.conn.startSpeedTestReceiver ? this.conn.startSpeedTestReceiver({
                        packetLimit: t
                    }, e) : this.conn.startServerToClientSpeedTest({
                        readyCb: e,
                        packetLimit: t
                    })
                }
                stopSpeedTestReceiver(e) {
                    null != this.conn.stopSpeedTestReceiver ? this.conn.stopSpeedTestReceiver(e) : this.conn.endServerToClientSpeedTest({
                        doneCb: e
                    })
                }
                chooseEncryptionMode(e, t) {
                    for (let n of t)
                        for (let t of e)
                            if (n === t) return n;
                    return "xsalsa20_poly1305"
                }
                getConnectionTransportOptions() {
                    let e = {
                        qos: this.qos,
                        reconnectInterval: this.reconnectInterval,
                        userChannelIds: this.ids
                    };
                    return e
                }
                getCodecOptions(e, t) {
                    var n, i, s, a;
                    let o;
                    o = this.codecs.find(t => t.name === e);
                    let r = {
                            type: null !== (n = null == o ? void 0 : o.payloadType) && void 0 !== n ? n : 0,
                            name: e,
                            freq: 48e3,
                            pacsize: 960,
                            channels: 1,
                            rate: 64e3
                        },
                        l = [{
                            type: null !== (i = null == o ? void 0 : o.payloadType) && void 0 !== i ? i : 0,
                            name: e,
                            freq: 48e3,
                            channels: 2,
                            params: {
                                stereo: "1"
                            }
                        }];
                    o = this.codecs.find(e => e.name === t);
                    let u = {
                            type: null !== (s = null == o ? void 0 : o.payloadType) && void 0 !== s ? s : 0
                        },
                        d = {
                            type: null !== (a = null == o ? void 0 : o.payloadType) && void 0 !== a ? a : 0
                        };
                    return {
                        audioEncoder: r,
                        audioDecoders: l,
                        testEncoder: u,
                        testDecoder: d
                    }
                }
                getUserIdBySsrc(e) {}
                constructor(e) {
                    super(e), this.mediaEngineConnectionId = "Native-".concat(d++), this.codecs = [], this.qos = !0, this.reconnectInterval = 6e4, this.pingInterval = l.PING_INTERVAL, this.handlePing = (e, t, n) => {
                        this.emit(o.BaseSpeedTesterEvent.Ping, e)
                    }, this.handlePingTimeout = (e, t, n, i) => {
                        this.emit(o.BaseSpeedTesterEvent.PingTimeout, n, i > 0 ? i : 4e3)
                    }, this.handleNewListenerNative = e => {
                        if (e === o.BaseSpeedTesterEvent.ConnectionStateChange) this.emit(e, this.connectionState)
                    }
                }
            }
        },
        573015: function(e, t, n) {
            "use strict";
            var i, s, a, o;
            n.r(t), n.d(t, {
                VADAggressiveness: function() {
                    return i
                }
            }), (a = i || (i = {}))[a.DISABLED = -1] = "DISABLED", a[a.NORMAL = 0] = "NORMAL", a[a.LOW_BIRTATE = 1] = "LOW_BIRTATE", a[a.AGGRESSIVE = 2] = "AGGRESSIVE", a[a.VERY_AGGRESSIVE = 3] = "VERY_AGGRESSIVE", (o = s || (s = {}))[o.NONE = 0] = "NONE", o[o.TIMEOUT = 1] = "TIMEOUT"
        },
        741397: function(e, t, n) {
            "use strict";
            n.r(t), n.d(t, {
                default: function() {
                    return s
                }
            }), n("222007"), n("70102");
            var i, s, a = n("383536"),
                o = n.n(a),
                r = n("811022"),
                l = n("595275"),
                u = n("773364"),
                d = n("953161"),
                c = n("784343"),
                h = n("446497"),
                p = n("785347"),
                f = n("784063"),
                m = n("710584"),
                E = n("595432"),
                g = n("149416");

            function S(e) {
                return (null != e ? e : g.DEFAULT_VOLUME) / g.DEFAULT_VOLUME
            }(i = class e extends l.default {
                destroy() {
                    this.eachConnection(e => e.destroy()), this.emit(u.MediaEngineEvent.Destroy), this.removeAllListeners()
                }
                interact() {}
                static supported() {
                    return (0, f.supported)()
                }
                supported() {
                    return !0
                }
                supports(e) {
                    var t, n;
                    switch (e) {
                        case g.Features.LEGACY_AUDIO_SUBSYSTEM:
                            return (0, f.supportsFeature)(g.NativeFeatures.VOICE_LEGACY_SUBSYSTEM);
                        case g.Features.EXPERIMENTAL_AUDIO_SUBSYSTEM:
                            return (0, f.supportsFeature)(g.NativeFeatures.VOICE_EXPERIMENTAL_SUBSYSTEM);
                        case g.Features.DEBUG_LOGGING:
                            return (0, f.supportsFeature)(g.NativeFeatures.DEBUG_LOGGING);
                        case g.Features.SOUNDSHARE:
                            return (0, f.supportsFeature)(g.NativeFeatures.SOUNDSHARE);
                        case g.Features.ELEVATED_HOOK:
                            return (0, f.supportsFeature)(g.NativeFeatures.ELEVATED_HOOK);
                        case g.Features.LOOPBACK:
                            return (0, f.supportsFeature)(g.NativeFeatures.LOOPBACK);
                        case g.Features.WUMPUS_VIDEO:
                            return (0, f.supportsFeature)(g.NativeFeatures.WUMPUS_VIDEO);
                        case g.Features.HYBRID_VIDEO:
                            return (0, f.supportsFeature)(g.NativeFeatures.HYBRID_VIDEO);
                        case g.Features.ATTENUATION:
                        case g.Features.VIDEO_HOOK:
                            return (null == o ? void 0 : null === (t = o.os) || void 0 === t ? void 0 : t.family) != null && /^win/i.test(o.os.family);
                        case g.Features.EXPERIMENTAL_SOUNDSHARE:
                            return (0, f.supportsFeature)(g.NativeFeatures.SOUNDSHARE_LOOPBACK);
                        case g.Features.OPEN_H264:
                            return (null == o ? void 0 : null === (n = o.os) || void 0 === n ? void 0 : n.family) != null && /^win|linux|OS X/i.test(o.os.family);
                        case g.Features.EXPERIMENTAL_ENCODERS:
                            return (0, f.supportsFeature)(g.NativeFeatures.EXPERIMENTAL_ENCODERS);
                        case g.Features.REMOTE_LOCUS_NETWORK_CONTROL:
                            return (0, f.supportsFeature)(g.NativeFeatures.REMOTE_LOCUS_NETWORK_CONTROL);
                        case g.Features.SCREEN_PREVIEWS:
                            return (0, f.supportsFeature)(g.NativeFeatures.SCREEN_PREVIEWS);
                        case g.Features.CLIPS:
                            return (0, f.supportsFeature)(g.NativeFeatures.CLIPS);
                        case g.Features.WINDOW_PREVIEWS:
                            return (0, f.supportsFeature)(g.NativeFeatures.WINDOW_PREVIEWS);
                        case g.Features.AUDIO_DEBUG_STATE:
                            return (0, f.supportsFeature)(g.NativeFeatures.AUDIO_DEBUG_STATE);
                        case g.Features.CONNECTION_REPLAY:
                            return (0, f.supportsFeature)(g.NativeFeatures.CONNECTION_REPLAY);
                        case g.Features.SIMULCAST:
                            return (0, f.supportsFeature)(g.NativeFeatures.SIMULCAST) && (0, f.supportsFeature)(g.NativeFeatures.SIMULCAST_BUGFIX);
                        case g.Features.RTC_REGION_RANKING:
                            return (0, f.supportsFeature)(g.NativeFeatures.RTC_REGION_RANKING);
                        case g.Features.DIRECT_VIDEO:
                            return (0, f.supportsFeature)(g.NativeFeatures.DIRECT_VIDEO) && null != window.createDiscordStream;
                        case g.Features.ELECTRON_VIDEO:
                            return (0, f.supportsFeature)(g.NativeFeatures.ELECTRON_VIDEO);
                        case g.Features.MEDIAPIPE:
                            return (0, f.supportsFeature)(g.NativeFeatures.MEDIAPIPE);
                        case g.Features.FIXED_KEYFRAME_INTERVAL:
                            return (0, f.supportsFeature)(g.NativeFeatures.FIXED_KEYFRAME_INTERVAL);
                        case g.Features.FIRST_FRAME_CALLBACK:
                            return (0, f.supportsFeature)(g.NativeFeatures.FIRST_FRAME_CALLBACK);
                        case g.Features.REMOTE_USER_MULTI_STREAM:
                            return (0, f.supportsFeature)(g.NativeFeatures.REMOTE_USER_MULTI_STREAM);
                        case g.Features.SPEED_TEST:
                            return (0, f.supportsFeature)(g.NativeFeatures.SPEED_TEST);
                        case g.Features.IMAGE_QUALITY_MEASUREMENT:
                            return (0, f.supportsFeature)(g.NativeFeatures.IMAGE_QUALITY_MEASUREMENT);
                        case g.Features.AMD_EXPERIMENTAL_RATE_CONTROL:
                            return (0, f.supportsFeature)(g.NativeFeatures.AMD_EXPERIMENTAL_RATE_CONTROL);
                        case g.Features.GO_LIVE_HARDWARE:
                            return (0, f.supportsFeature)(g.NativeFeatures.GO_LIVE_HARDWARE);
                        case g.Features.SCREEN_CAPTURE_KIT:
                            return (0, f.supportsFeature)(g.NativeFeatures.SCREEN_CAPTURE_KIT);
                        case g.Features.CAPTURE_TIMEOUT_EXPERIMENTS:
                            return (0, f.supportsFeature)(g.NativeFeatures.CAPTURE_TIMEOUT_EXPERIMENTS);
                        case g.Features.DIAGNOSTICS:
                        case g.Features.NATIVE_PING:
                        case g.Features.AUTOMATIC_VAD:
                        case g.Features.AUDIO_INPUT_DEVICE:
                        case g.Features.AUDIO_OUTPUT_DEVICE:
                        case g.Features.QOS:
                        case g.Features.VOICE_PROCESSING:
                        case g.Features.AUTO_ENABLE:
                        case g.Features.VIDEO:
                        case g.Features.DESKTOP_CAPTURE:
                        case g.Features.DESKTOP_CAPTURE_FORMAT:
                        case g.Features.DESKTOP_CAPTURE_APPLICATIONS:
                        case g.Features.VOICE_PANNING:
                        case g.Features.AEC_DUMP:
                        case g.Features.DISABLE_VIDEO:
                        case g.Features.SAMPLE_PLAYBACK:
                        case g.Features.NOISE_SUPPRESSION:
                        case g.Features.AUTOMATIC_GAIN_CONTROL:
                            return !0;
                        default:
                            return !1
                    }
                }
                connect(e, t, n) {
                    let i = (0, f.supportsFeature)(g.NativeFeatures.EXPERIMENT_CONFIG);
                    !i && (n.experiments = void 0);
                    let s = c.default.create(e, t, n);
                    return s.on(u.BaseConnectionEvent.Destroy, e => {
                        this.connections.delete(e), this.connectionsEmpty() && (0, f.setProcessPriority)(g.ProcessPriority.NORMAL)
                    }), s.on(u.BaseConnectionEvent.Connected, () => {
                        s.setVideoBroadcast(this.shouldConnectionBroadcastVideo(s))
                    }), s.on(u.BaseConnectionEvent.Silence, e => {
                        this.emit(u.MediaEngineEvent.Silence, e)
                    }), this.connections.add(s), (0, f.setProcessPriority)(g.ProcessPriority.HIGH), this.emit(u.MediaEngineEvent.Connection, s), s
                }
                shouldConnectionBroadcastVideo(e) {
                    return e.context === g.MediaEngineContextTypes.DEFAULT && this.videoInputDeviceId !== g.DISABLED_DEVICE_ID || e.hasDesktopSource()
                }
                eachConnection(e, t) {
                    this.connections.forEach(n => {
                        (null == t || n.context === t) && e(n)
                    })
                }
                enable() {
                    return Promise.resolve()
                }
                setInputVolume(e) {
                    (0, f.getVoiceEngine)().setInputVolume(S(e))
                }
                setOutputVolume(e) {
                    (0, f.getVoiceEngine)().setOutputVolume(S(e))
                }
                getAudioInputDevices() {
                    return (0, h.getAudioInputDevices)()
                }
                setAudioInputDevice(e) {
                    (0, f.supportsFeature)(g.NativeFeatures.SET_AUDIO_DEVICE_BY_ID) ? (0, f.getVoiceEngine)().setInputDevice(e): (0, h.getAudioInputDevices)().then(t => {
                        var n;
                        let i = null !== (n = t.find(t => t.id === e)) && void 0 !== n ? n : t[0];
                        null != i && (0, f.getVoiceEngine)().setInputDevice(i.index)
                    })
                }
                getAudioOutputDevices() {
                    return (0, h.getAudioOutputDevices)()
                }
                setAudioOutputDevice(e) {
                    (0, f.supportsFeature)(g.NativeFeatures.SET_AUDIO_DEVICE_BY_ID) ? (0, f.getVoiceEngine)().setOutputDevice(e): (0, h.getAudioOutputDevices)().then(t => {
                        var n;
                        let i = null !== (n = t.find(t => t.id === e)) && void 0 !== n ? n : t[0];
                        null != i && (0, f.getVoiceEngine)().setOutputDevice(i.index)
                    })
                }
                getVideoInputDevices() {
                    return (0, h.getVideoInputDevices)()
                }
                async setVideoInputDevice(e) {
                    let t = await this.getVideoInputDevices(),
                        n = t.find(t => t.id === e),
                        i = null != n ? n.id : g.DISABLED_DEVICE_ID;
                    if (i !== this.videoInputDeviceId) {
                        if (this.videoInputDeviceId = i, (0, f.supportsFeature)(g.NativeFeatures.SET_VIDEO_DEVICE_BY_ID)) {
                            let e = null != n ? null != n.originalId && "" !== n.originalId ? n.originalId : n.id : g.DISABLED_DEVICE_ID;
                            (0, f.getVoiceEngine)().setVideoInputDevice(e)
                        } else(0, f.getVoiceEngine)().setVideoInputDevice(null != n ? n.index : -1);
                        this.connections.forEach(e => e.setVideoBroadcast(this.shouldConnectionBroadcastVideo(e)))
                    }
                }
                getSupportedVideoCodecs(e) {
                    (0, f.getVoiceEngine)().getSupportedVideoCodecs(e)
                }
                getCodecCapabilities(e) {
                    (0, f.getVoiceEngine)().getCodecCapabilities(e)
                }
                setGoLiveSource(e, t) {
                    if (null == e) {
                        this.eachConnection(e => {
                            e.clearDesktopSource(), e.clearGoLiveDevices(), e.setSoundshareSource(0, !1), e.setVideoBroadcast(this.shouldConnectionBroadcastVideo(e))
                        }, t);
                        return
                    }
                    this.eachConnection(n => {
                        (t !== g.MediaEngineContextTypes.STREAM || n.streamUserId === n.ids.userId) && (n.setGoLiveSource(e), n.setVideoBroadcast(this.shouldConnectionBroadcastVideo(n)))
                    }, t)
                }
                setClipsSource(e) {
                    if (null == (0, f.getVoiceEngine)().setClipsSource || null == (0, f.getVoiceEngine)().setOnClipsRecordingEvent || null == (0, f.getVoiceEngine)().applyClipsSettings) return;
                    if (null == e) {
                        (0, f.getVoiceEngine)().setClipsSource({
                            id: "",
                            soundshareId: 0
                        });
                        return
                    }
                    let {
                        frameRate: t,
                        resolution: n
                    } = e.quality, {
                        id: i,
                        soundshareId: s,
                        useLoopback: a,
                        useVideoHook: o,
                        useGraphicsCapture: r,
                        useQuartzCapturer: l,
                        allowScreenCaptureKit: d,
                        hdrCaptureMode: c
                    } = e.desktopDescription;
                    (0, f.getVoiceEngine)().setOnClipsRecordingEvent(t => {
                        this.logger.info("Clips recording event: ".concat(g.ClipsRecordingEvent[t], " received for stream ").concat(i, " and sound ").concat(s, ".")), t === g.ClipsRecordingEvent.GoLiveEnded ? this.emit(u.MediaEngineEvent.ClipsRecordingRestartNeeded) : t === g.ClipsRecordingEvent.Error ? this.emit(u.MediaEngineEvent.ClipsInitFailure, "Failed to set clips source in media engine", e.applicationName) : (t === g.ClipsRecordingEvent.Ended || t === g.ClipsRecordingEvent.StoppedByGoLive) && this.emit(u.MediaEngineEvent.ClipsRecordingEnded, i, s)
                    }), (0, f.getVoiceEngine)().applyClipsSettings({
                        useVideoHook: o,
                        useGraphicsCapture: r,
                        useQuartzCapturer: l,
                        allowScreenCaptureKit: d,
                        hdrCaptureMode: c,
                        soundshareLoopback: a,
                        frameRate: t,
                        width: n <= 480 ? n / 3 * 4 : n / 9 * 16,
                        height: n
                    });
                    let [h, p] = null != i ? i.split(":") : ["", ""];
                    (0, f.getVoiceEngine)().setClipsSource({
                        id: p,
                        soundshareId: null != s ? s : 0
                    })
                }
                setSoundshareSource(e, t, n) {
                    this.eachConnection(i => {
                        (n !== g.MediaEngineContextTypes.STREAM || i.streamUserId === i.ids.userId) && i.setSoundshareSource(e, t)
                    }, n)
                }
                getDesktopSource() {
                    return Promise.reject(Error("NO_STREAM"))
                }
                getDesktopSources() {
                    return new Promise(e => {
                        null != (0, f.getVoiceEngine)().getDesktopSources ? (0, f.getVoiceEngine)().getDesktopSources(t => e(t)) : e([])
                    })
                }
                getScreenPreviews(e, t) {
                    return new Promise(n => {
                        null != (0, f.getVoiceEngine)().getScreenPreviews ? (0, f.getVoiceEngine)().getScreenPreviews(e, t, e => {
                            n(e.map((e, t) => ({
                                ...e,
                                name: "Screen " + (t + 1)
                            })))
                        }) : n([])
                    })
                }
                setClipBufferLength(e) {
                    var t, n;
                    null === (t = (n = (0, f.getVoiceEngine)()).setClipBufferLength) || void 0 === t || t.call(n, e)
                }
                saveClip(e, t) {
                    let n = (0, f.getVoiceEngine)();
                    return null == n.setClipBufferLength ? Promise.reject("unsupported") : new Promise((i, s) => {
                        n.saveClip(e, t, (e, t, n) => {
                            let s = JSON.parse(n);
                            return i({
                                duration: e,
                                thumbnail: t,
                                clipStats: s
                            })
                        }, e => {
                            let t = JSON.parse(e);
                            return s(t)
                        })
                    })
                }
                saveClipForSSRC(e, t, n, i) {
                    let s = (0, f.getVoiceEngine)();
                    return null == s.saveClipForSSRC ? Promise.reject("unsupported") : new Promise((a, o) => {
                        s.saveClipForSSRC(e, t, n, i, (e, t, n) => {
                            let i = JSON.parse(n);
                            return a({
                                duration: e,
                                thumbnail: t,
                                clipStats: i
                            })
                        }, e => {
                            let t = JSON.parse(e);
                            return o(t)
                        })
                    })
                }
                updateClipMetadata(e, t) {
                    let n = (0, f.getVoiceEngine)();
                    return null == n.updateClipMetadata ? Promise.reject("unsupported") : new Promise((i, s) => {
                        n.updateClipMetadata(e, t, i, s)
                    })
                }
                exportClip(e, t) {
                    let n = (0, f.getVoiceEngine)();
                    return null == n.exportClip ? Promise.reject("unsupported") : new Promise((i, s) => {
                        n.exportClip(e, t, e => i(new Blob([e])), s)
                    })
                }
                getWindowPreviews(e, t) {
                    return new Promise(n => {
                        null != (0, f.getVoiceEngine)().getWindowPreviews ? (0, f.getVoiceEngine)().getWindowPreviews(e, t, e => {
                            n(e)
                        }) : n([])
                    })
                }
                setAudioSubsystem(e) {
                    null != (0, f.getVoiceEngine)().setAudioSubsystem ? (0, f.getVoiceEngine)().setAudioSubsystem(e) : (0, f.getVoiceEngine)().setUseLegacyAudioDevice(e === g.AudioSubsystems.LEGACY)
                }
                getAudioSubsystem() {
                    return this.audioSubsystem
                }
                getAudioLayer() {
                    return this.audioLayer
                }
                getDebugLogging() {
                    return !!this.supports(g.Features.DEBUG_LOGGING) && (0, f.getVoiceEngine)().getDebugLogging()
                }
                setDebugLogging(e) {
                    this.supports(g.Features.DEBUG_LOGGING) && (0, f.getVoiceEngine)().setDebugLogging(e)
                }
                setExperimentalAdm(e) {
                    let {
                        setExperimentalAdm: t,
                        getAudioSubsystem: n
                    } = (0, f.getVoiceEngine)();
                    null == t || t(e), null == n || n(e => {
                        this.audioSubsystem = e
                    })
                }
                setLoopback(e, t) {
                    null != (0, f.getVoiceEngine)().setLoopback && (0, f.getVoiceEngine)().setLoopback(e, {
                        echoCancellation: t.echoCancellation,
                        noiseSuppression: t.noiseSuppression,
                        automaticGainControl: t.automaticGainControl,
                        noiseCancellation: t.noiseCancellation
                    }), null != (0, f.getVoiceEngine)().setEmitVADLevel2 ? (0, f.getVoiceEngine)().setEmitVADLevel2(e || this.listenerCount(u.MediaEngineEvent.VoiceActivity) > 0) : (0, f.getVoiceEngine)().setEmitVADLevel(e || this.listenerCount(u.MediaEngineEvent.VoiceActivity) > 0, e, {
                        echoCancellation: t.echoCancellation,
                        noiseSuppression: t.noiseSuppression,
                        automaticGainControl: t.automaticGainControl,
                        noiseCancellation: t.noiseCancellation
                    })
                }
                getLoopback() {
                    return !1
                }
                setH264Enabled(e) {
                    let t = (0, f.getVoiceEngine)();
                    t.setTransportOptions({
                        h264Enabled: e
                    })
                }
                setAv1Enabled(e) {
                    let t = (0, f.getVoiceEngine)();
                    t.setTransportOptions({
                        av1Enabled: e
                    })
                }
                setH265Enabled(e) {
                    let t = (0, f.getVoiceEngine)();
                    t.setTransportOptions({
                        h265Enabled: e
                    })
                }
                getCodecSurvey() {
                    return null != this.codecSurvey ? Promise.resolve(this.codecSurvey) : new Promise((e, t) => {
                        let n = (0, f.getVoiceEngine)();
                        null != n.getCodecSurvey ? n.getCodecSurvey(t => {
                            this.codecSurvey = t, e(t)
                        }) : t(Error("getCodecSurvey is not implemented."))
                    })
                }
                writeAudioDebugState() {
                    return new Promise((e, t) => {
                        let {
                            writeAudioDebugState: n
                        } = (0, f.getVoiceEngine)();
                        null != n ? (n(), e()) : t(Error("Audio debug state is not supported."))
                    })
                }
                startAecDump() {}
                stopAecDump() {}
                setAecDump(e) {
                    var t, n;
                    null === (t = (n = (0, f.getVoiceEngine)()).setAecDump) || void 0 === t || t.call(n, e)
                }
                rankRtcRegions(e) {
                    return new Promise((t, n) => {
                        let {
                            rankRtcRegions: i
                        } = (0, f.getVoiceEngine)();
                        null != i ? i(e, e => t(e)) : n(Error("RTC region latency test is not supported."))
                    })
                }
                getSoundshareStatus() {
                    return new Promise((e, t) => {
                        let {
                            getSoundshareStatus: n
                        } = (0, f.getVoiceEngine)();
                        null != n ? n(t => e(t)) : t(Error("getSoundshareStatus is not supported."))
                    })
                }
                enableSoundshare() {
                    return new Promise((e, t) => {
                        let {
                            enableSoundshare: n
                        } = (0, f.getVoiceEngine)();
                        null != n ? n((t, n) => e({
                            code: t,
                            message: n,
                            willRetry: !1
                        })) : t(Error("enableSoundshare is not supported."))
                    })
                }
                createReplayConnection(e, t) {
                    let n = c.default.createReplay(e, t);
                    return null == n ? null : (n.on(u.BaseConnectionEvent.Destroy, e => {
                        this.connections.delete(e), this.connectionsEmpty() && (0, f.setProcessPriority)(g.ProcessPriority.NORMAL)
                    }), this.connections.add(n), (0, f.setProcessPriority)(g.ProcessPriority.HIGH), this.emit(u.MediaEngineEvent.Connection, n), n)
                }
                setUseDirectVideo(e) {
                    E.default.useDirectVideo = e
                }
                setMaxSyncDelayOverride(e) {
                    let {
                        setMaxSyncDelayOverride: t
                    } = (0, f.getVoiceEngine)();
                    null != t && t(e)
                }
                applyMediaFilterSettings(e) {
                    let {
                        applyMediaFilterSettings: t,
                        applyMediaFilterSettingsWithCallback: n
                    } = (0, f.getVoiceEngine)();
                    return null != n ? new Promise((t, i) => {
                        n(e, t)
                    }) : (null != t && t(e), Promise.resolve())
                }
                startLocalAudioRecording(e) {
                    return new Promise((t, n) => {
                        let {
                            startLocalAudioRecording: i
                        } = (0, f.getVoiceEngine)();
                        null != i ? i(e, e => {
                            e ? t() : n(Error("Failed to start local audio recording."))
                        }) : n(Error("startLocalAudioRecording is not supported."))
                    })
                }
                stopLocalAudioRecording(e) {
                    var t, n;
                    null === (t = (n = (0, f.getVoiceEngine)()).stopLocalAudioRecording) || void 0 === t || t.call(n, (t, n) => {
                        e(t, n)
                    }), this.listenerCount(u.MediaEngineEvent.VoiceActivity) > 0 && null != (0, f.getVoiceEngine)().setEmitVADLevel2 && (0, f.getVoiceEngine)().setEmitVADLevel2(!0)
                }
                speedTester(e, t) {
                    if (!this.supports(g.Features.SPEED_TEST)) throw Error("speedTester is not supported.");
                    let n = p.default.create(e, t);
                    return n.on(u.BaseSpeedTesterEvent.Destroy, e => {
                        this.speedTesters.delete(e), this.connectionsEmpty() && (0, f.setProcessPriority)(g.ProcessPriority.NORMAL)
                    }), this.speedTesters.add(n), (0, f.setProcessPriority)(g.ProcessPriority.HIGH), n
                }
                setHasFullbandPerformance(e) {
                    null != (0, f.getVoiceEngine)().setHasFullbandPerformance && (0, f.getVoiceEngine)().setHasFullbandPerformance(e)
                }
                getSupportedSecureFramesProtocolVersion() {
                    var e;
                    return null !== (e = (0, f.getVoiceEngine)().SupportedSecureFramesProtocolVersion) && void 0 !== e ? e : 0
                }
                getSupportedBandwidthEstimationExperiments(e) {
                    null != (0, f.getVoiceEngine)().getSupportedBandwidthEstimationExperiments && (0, f.getVoiceEngine)().getSupportedBandwidthEstimationExperiments(e)
                }
                watchdogTick() {
                    let e = !1;
                    (0, f.getVoiceEngine)().pingVoiceThread(() => {
                        e = !0, this.consecutiveWatchdogFailures = 0
                    }), setTimeout(() => {
                        !e && ++this.consecutiveWatchdogFailures > 1 ? this.emit(u.MediaEngineEvent.WatchdogTimeout) : this.watchdogTick()
                    }, g.WATCHDOG_TIMEOUT_MS)
                }
                connectionsEmpty() {
                    return 0 === this.connections.size && 0 === this.speedTesters.size
                }
                constructor() {
                    var t, n;
                    super(), t = this, this.Video = E.default, this.Camera = m.default, this.videoInputDeviceId = g.DISABLED_DEVICE_ID, this.connections = new Set, this.speedTesters = new Set, this.lastVoiceActivity = -1, this.audioSubsystem = "standard", this.audioLayer = "", this.deviceChangeGeneration = 0, this.consecutiveWatchdogFailures = 0, this.codecSurvey = null, this.logger = new r.default("MediaEngineNative"), this.handleDeviceChange = function() {
                        let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : [],
                            n = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : [],
                            i = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : [];
                        t.deviceChangeGeneration++, t.emit(u.MediaEngineEvent.DeviceChange, (0, h.sanitizeDevices)(g.DeviceTypes.AUDIO_INPUT, e), (0, h.sanitizeDevices)(g.DeviceTypes.AUDIO_OUTPUT, n), (0, h.sanitizeDevices)(g.DeviceTypes.VIDEO_INPUT, i))
                    }, this.handleVolumeChange = (e, t) => {
                        this.emit(u.MediaEngineEvent.VolumeChange, e * g.DEFAULT_VOLUME, t * g.DEFAULT_VOLUME)
                    }, this.handleVoiceActivity = (e, t) => {
                        let n = Date.now();
                        this.listenerCount(u.MediaEngineEvent.VoiceActivity) > 0 && (-1 === this.lastVoiceActivity || Date.now() - this.lastVoiceActivity > 20) && (this.lastVoiceActivity = n, this.emit(u.MediaEngineEvent.VoiceActivity, e, t))
                    }, this.handleActiveSinksChange = (e, t) => {
                        this.connections.forEach(n => n.setHasActiveVideoOutputSink(e, t))
                    }, this.handleNewListener = e => {
                        switch (e) {
                            case u.MediaEngineEvent.VoiceActivity:
                                null != (0, f.getVoiceEngine)().setEmitVADLevel2 ? (0, f.getVoiceEngine)().setEmitVADLevel2(!0) : (0, f.getVoiceEngine)().setEmitVADLevel(!0, !1, {});
                                break;
                            case u.MediaEngineEvent.DeviceChange:
                                let t = this.deviceChangeGeneration;
                                Promise.all([this.getAudioInputDevices(), this.getAudioOutputDevices(), this.getVideoInputDevices()]).then(e => {
                                    let [n, i, s] = e;
                                    t === this.deviceChangeGeneration && this.emit(u.MediaEngineEvent.DeviceChange, n, i, s)
                                })
                        }
                    }, this.handleRemoveListener = e => {
                        e === u.MediaEngineEvent.VoiceActivity && (null != (0, f.getVoiceEngine)().setEmitVADLevel2 ? (0, f.getVoiceEngine)().setEmitVADLevel2(this.listenerCount(u.MediaEngineEvent.VoiceActivity) > 0) : (0, f.getVoiceEngine)().setEmitVADLevel(this.listenerCount(u.MediaEngineEvent.VoiceActivity) > 0, !1, {}))
                    }, this.handleVideoInputInitialization = e => {
                        this.emit(u.MediaEngineEvent.VideoInputInitialized, e)
                    };
                    let i = (0, f.getVoiceEngine)();
                    if (i.setDeviceChangeCallback(this.handleDeviceChange), i.setVolumeChangeCallback(this.handleVolumeChange), i.setOnVoiceCallback(this.handleVoiceActivity), null === (n = i.setVideoInputInitializationCallback) || void 0 === n || n.call(i, this.handleVideoInputInitialization), i.setTransportOptions({
                            idleJitterBufferFlush: !0,
                            ducking: !1
                        }), this.on("removeListener", this.handleRemoveListener), this.on("newListener", this.handleNewListener), null != (0, f.getVoiceEngine)().getAudioSubsystem ? (0, f.getVoiceEngine)().getAudioSubsystem((e, t) => {
                            this.audioSubsystem = e, this.audioLayer = t
                        }) : null != (0, f.getVoiceEngine)().getUseLegacyAudioDevice && (this.audioSubsystem = (0, f.getVoiceEngine)().getUseLegacyAudioDevice() ? g.AudioSubsystems.LEGACY : g.AudioSubsystems.STANDARD), null != i.pingVoiceThread && "undefined" != typeof window && "canary" === window.GLOBAL_ENV.RELEASE_CHANNEL && this.watchdogTick(), this.getDebugLogging() && !e.installedLogHooks)
                        for (let t of (e.installedLogHooks = !0, ["trace", "debug", "info", "warn", "error", "log"])) {
                            let e = console,
                                n = e[t];
                            null != n && (e[t] = function() {
                                n.apply(this, arguments);
                                try {
                                    let e = Array.from(arguments).map(e => null != e ? e.toString() : e).filter(e => "string" != typeof e || "\nfont-weight: bold;\ncolor: purple;\n" !== e);
                                    (0, f.getVoiceEngine)().consoleLog(t, JSON.stringify(e))
                                } catch (e) {}
                            })
                        }
                    null != i.setActiveSinksChangeCallback && i.setActiveSinksChangeCallback(this.handleActiveSinksChange), (0, d.default)(this)
                }
            }).installedLogHooks = !1, s = i
        },
        784063: function(e, t, n) {
            "use strict";
            let i, s;

            function a() {
                if (null == i) throw Error("Native dependencies have not been injected.")
            }

            function o(e) {
                i = e
            }

            function r() {
                return a(), i.supported()
            }

            function l(e) {
                return a(), i.supportsFeature(e)
            }

            function u(e) {
                a(), i.setProcessPriority(e)
            }

            function d() {
                return a(), null != s ? s : s = i.getVoiceEngine()
            }
            n.r(t), n.d(t, {
                inject: function() {
                    return o
                },
                supported: function() {
                    return r
                },
                supportsFeature: function() {
                    return l
                },
                setProcessPriority: function() {
                    return u
                },
                getVoiceEngine: function() {
                    return d
                }
            }), n("70102")
        },
        104240: function(e, t, n) {
            "use strict";

            function i(e) {
                let t = e.getContext("2d");
                return null == t ? null : {
                    render: e => {
                        t.putImageData(e, 0, 0)
                    }
                }
            }
            n.r(t), n.d(t, {
                initRenderingContext2D: function() {
                    return i
                }
            })
        },
        340346: function(e, t, n) {
            "use strict";
            n.r(t), n.d(t, {
                initRenderingContextWebGL: function() {
                    return o
                }
            }), n("370692"), n("477657"), n("811875"), n("90301"), n("652153"), n("28797"), n("817884"), n("597349"), n("667536"), n("690341");
            var i = n("811022");
            let s = new i.default("RenderingContextWebGL");
            class a {
                static create(e) {
                    if (null == e) return null;
                    let t = this.createShader(e, e.VERTEX_SHADER, "\nattribute vec4 position;\nattribute vec2 texcoord;\nuniform mat4 transform;\nvarying vec2 out_texcoord;\n\nvoid main() {\n   gl_Position = transform * position;\n   out_texcoord = texcoord;\n}\n"),
                        n = this.createShader(e, e.FRAGMENT_SHADER, "\nprecision mediump float;\n\nvarying vec2 out_texcoord;\nuniform sampler2D texture;\n\nvoid main() {\n   gl_FragColor = texture2D(texture, out_texcoord);\n}\n");
                    if (null == t || null == n) return null;
                    let i = this.createProgram(e, t, n);
                    if (null == i) return null;
                    let s = e.getAttribLocation(i, "position"),
                        o = e.getAttribLocation(i, "texcoord");
                    if (-1 === s || -1 === o) return null;
                    let r = e.getUniformLocation(i, "transform"),
                        l = e.getUniformLocation(i, "texture");
                    if (null == r || null == l) return null;
                    let u = e.createBuffer();
                    if (null == u) return null;
                    e.bindBuffer(e.ARRAY_BUFFER, u), e.bufferData(e.ARRAY_BUFFER, new Float32Array([0, 0, 0, 1, 1, 0, 1, 0, 0, 1, 1, 1]), e.STATIC_DRAW);
                    let d = e.createTexture();
                    return null == d ? null : new a({
                        gl: e,
                        program: i,
                        positionLoc: s,
                        texcoordLoc: o,
                        transformLoc: r,
                        textureLoc: l,
                        vertexBuffer: u,
                        texture: d
                    })
                }
                static createShader(e, t, n) {
                    let i = e.createShader(t);
                    if (null == i) return null;
                    if (e.shaderSource(i, n), e.compileShader(i), !e.getShaderParameter(i, e.COMPILE_STATUS)) {
                        s.warn("Failed to compile shader!");
                        let t = e.getShaderInfoLog(i);
                        return null != t && s.log(t), e.deleteShader(i), null
                    }
                    return i
                }
                static createProgram(e, t, n) {
                    if (null == t || null == n) return null;
                    let i = e.createProgram();
                    if (null == i) return null;
                    if (e.attachShader(i, t), e.attachShader(i, n), e.linkProgram(i), !e.getProgramParameter(i, e.LINK_STATUS)) {
                        s.warn("Failed to link program!");
                        let t = e.getProgramInfoLog(i);
                        return null != t && s.log(t), e.deleteProgram(i), null
                    }
                    return i
                }
                render(e) {
                    if (null == e) return;
                    let t = e.width,
                        n = e.height,
                        i = this.gl;
                    i.bindTexture(i.TEXTURE_2D, this.texture), i.texImage2D(i.TEXTURE_2D, 0, i.RGBA, t, n, 0, i.RGBA, i.UNSIGNED_BYTE, e.data), i.texParameteri(i.TEXTURE_2D, i.TEXTURE_WRAP_S, i.CLAMP_TO_EDGE), i.texParameteri(i.TEXTURE_2D, i.TEXTURE_WRAP_T, i.CLAMP_TO_EDGE), i.texParameteri(i.TEXTURE_2D, i.TEXTURE_MIN_FILTER, i.LINEAR), i.viewport(0, 0, t, n), i.clearColor(0, 0, 0, 1), i.clear(i.COLOR_BUFFER_BIT), i.useProgram(this.program), i.bindBuffer(i.ARRAY_BUFFER, this.vertexBuffer), i.enableVertexAttribArray(this.positionLoc), i.vertexAttribPointer(this.positionLoc, 2, i.FLOAT, !1, 0, 0), i.enableVertexAttribArray(this.texcoordLoc), i.vertexAttribPointer(this.texcoordLoc, 2, i.FLOAT, !1, 0, 0), i.uniformMatrix4fv(this.transformLoc, !1, this.transform), i.uniform1i(this.textureLoc, 0), i.drawArrays(i.TRIANGLES, 0, 6)
                }
                constructor({
                    gl: e,
                    program: t,
                    positionLoc: n,
                    texcoordLoc: i,
                    transformLoc: s,
                    textureLoc: a,
                    vertexBuffer: o,
                    texture: r
                }) {
                    this.transform = new Float32Array([2, 0, 0, 0, 0, -2, 0, 0, 0, 0, 1, 0, -1, 1, 0, 1]), this.gl = e, this.program = t, this.positionLoc = n, this.texcoordLoc = i, this.transformLoc = s, this.textureLoc = a, this.vertexBuffer = o, this.texture = r
                }
            }

            function o(e) {
                let t = e.getContext("webgl2");
                return null == t ? null : a.create(t)
            }
        },
        539578: function(e, t, n) {
            "use strict";
            n.r(t), n.d(t, {
                default: function() {
                    return d
                }
            }), n("808653"), n("424973");
            var i = n("823302");

            function s(e) {
                return e / 32768
            }

            function a(e) {
                var t, n, i, s, a, o, r, l, u, d, c, h, p, f, m, E, g, S, _, v, C;
                let T = (null !== (d = null == e ? void 0 : e.headerBytes) && void 0 !== d ? d : 0) + (null !== (c = null == e ? void 0 : e.payloadBytes) && void 0 !== c ? c : 0) + (null !== (h = null == e ? void 0 : e.paddingBytes) && void 0 !== h ? h : 0),
                    I = (null !== (p = null == e ? void 0 : null === (t = e.fec) || void 0 === t ? void 0 : t.headerBytes) && void 0 !== p ? p : 0) + (null !== (f = null == e ? void 0 : null === (n = e.fec) || void 0 === n ? void 0 : n.payloadBytes) && void 0 !== f ? f : 0) + (null !== (m = null == e ? void 0 : null === (i = e.fec) || void 0 === i ? void 0 : i.paddingBytes) && void 0 !== m ? m : 0) + (null !== (E = null == e ? void 0 : null === (s = e.retransmitted) || void 0 === s ? void 0 : s.headerBytes) && void 0 !== E ? E : 0) + (null !== (g = null == e ? void 0 : null === (a = e.retransmitted) || void 0 === a ? void 0 : a.payloadBytes) && void 0 !== g ? g : 0) + (null !== (S = null == e ? void 0 : null === (o = e.retransmitted) || void 0 === o ? void 0 : o.paddingBytes) && void 0 !== S ? S : 0) + (null !== (_ = null == e ? void 0 : null === (r = e.transmitted) || void 0 === r ? void 0 : r.headerBytes) && void 0 !== _ ? _ : 0) + (null !== (v = null == e ? void 0 : null === (l = e.transmitted) || void 0 === l ? void 0 : l.payloadBytes) && void 0 !== v ? v : 0) + (null !== (C = null == e ? void 0 : null === (u = e.transmitted) || void 0 === u ? void 0 : u.paddingBytes) && void 0 !== C ? C : 0);
                return I + T
            }

            function o(e) {
                var t, n, i, s, a, o, r;
                let l = null !== (s = null == e ? void 0 : e.packets) && void 0 !== s ? s : 0,
                    u = (null !== (a = null == e ? void 0 : null === (t = e.fec) || void 0 === t ? void 0 : t.packets) && void 0 !== a ? a : 0) + (null !== (o = null == e ? void 0 : null === (n = e.retransmitted) || void 0 === n ? void 0 : n.packets) && void 0 !== o ? o : 0) + (null !== (r = null == e ? void 0 : null === (i = e.transmitted) || void 0 === i ? void 0 : i.packets) && void 0 !== r ? r : 0);
                return u + l
            }

            function r(e) {
                let t = {};
                for (let i in e) {
                    var n;
                    t[i] = null != (n = e[i]) ? {
                        last: Math.round(1e3 * n.last),
                        mean: Math.round(1e3 * n.mean),
                        p75: Math.round(1e3 * n.p75),
                        p95: Math.round(1e3 * n.p95),
                        p99: Math.round(1e3 * n.p99),
                        max: Math.round(1e3 * n.max)
                    } : null
                }
                return t
            }

            function l(e, t) {
                var n, s, r, l, u, d, c, h, p, f, m, E, g, S;
                let _ = e.substreams.find(e => !e.isRTX && !e.isFlexFEC);
                if (null == _) return;
                let v = e.substreams.reduce((e, t) => e + a(t.rtpStats), 0),
                    C = e.substreams.reduce((e, t) => e + o(t.rtpStats), 0);
                return {
                    type: "video",
                    ssrc: _.ssrc,
                    sinkWant: (0, i.formatSinkWantStat)(t, _.ssrc, !0),
                    sinkWantAsInt: (0, i.formatSinkWantAsInt)(t, _.ssrc),
                    codec: {
                        id: e.codecPayloadType,
                        name: e.codecName
                    },
                    keyFrameInterval: e.keyFrameInterval,
                    bytesSent: v,
                    packetsSent: C,
                    packetsLost: null !== (h = null === (n = _.rtcpStats) || void 0 === n ? void 0 : n.packetsLost) && void 0 !== h ? h : 0,
                    fractionLost: null !== (p = null === (s = _.rtcpStats) || void 0 === s ? void 0 : s.fractionLost) && void 0 !== p ? p : 0,
                    bitrate: e.mediaBitrate,
                    bitrateTarget: e.targetMediaBitrate,
                    encoderImplementationName: e.encoderImplementationName,
                    encodeUsage: e.encodeUsage,
                    averageEncodeTime: e.avgEncodeTime,
                    resolution: {
                        height: _.height,
                        width: _.width
                    },
                    framesSent: _.frameCounts.keyFrames + _.frameCounts.deltaFrames,
                    keyFramesEncoded: _.frameCounts.keyFrames,
                    framesEncoded: e.framesEncoded,
                    frameRateInput: e.inputFrameRate,
                    frameRateEncode: e.encodeFrameRate,
                    firCount: null !== (f = null === (r = _.rtcpStats) || void 0 === r ? void 0 : r.firPackets) && void 0 !== f ? f : 0,
                    nackCount: null !== (m = null === (l = _.rtcpStats) || void 0 === l ? void 0 : l.nackPackets) && void 0 !== m ? m : 0,
                    pliCount: null !== (E = null === (u = _.rtcpStats) || void 0 === u ? void 0 : u.pliPackets) && void 0 !== E ? E : 0,
                    qpSum: e.qpSum,
                    bandwidthLimitedResolution: e.bwLimitedResolution,
                    framesDroppedRateLimiter: e.framesDroppedRateLimiter,
                    framesDroppedEncoderQueue: e.framesDroppedEncoderQueue,
                    framesDroppedCongestionWindow: e.framesDroppedCongestionWindow,
                    cpuLimitedResolution: e.cpuLimitedResolution,
                    encoderQualityVmaf: null !== (g = null === (d = _.encoderQualityStats) || void 0 === d ? void 0 : d.imageQualityVmaf_v061) && void 0 !== g ? g : void 0,
                    encoderQualityPsnr: null !== (S = null === (c = _.encoderQualityStats) || void 0 === c ? void 0 : c.imageQualityWebrtcPsnrDb) && void 0 !== S ? S : void 0,
                    filter: e.filter
                }
            }

            function u(e, t, n, s) {
                var l, u;
                let d = a(e.rtpStats),
                    c = o(e.rtpStats);
                return {
                    type: "video",
                    ssrc: e.ssrc,
                    sinkWant: (0, i.formatSinkWantStat)(t, e.ssrc, !0),
                    sinkWantAsInt: (0, i.formatSinkWantAsInt)(t, e.ssrc),
                    sinkWantLocal: (0, i.formatSinkWantStat)(n, e.ssrc, !0),
                    codec: {
                        id: e.codecPayloadType,
                        name: e.codecName
                    },
                    bytesReceived: d,
                    packetsReceived: c,
                    packetsLost: null !== (l = e.rtpStats.packetsLost) && void 0 !== l ? l : e.rtcpStats.packetsLost,
                    fractionLost: e.rtcpStats.fractionLost,
                    bitrate: e.totalBitrate,
                    jitterBuffer: e.jitterBuffer,
                    currentDelay: e.currentDelay,
                    targetDelay: e.targetDelay,
                    minPlayoutDelay: e.minPlayoutDelay,
                    renderDelay: e.renderDelay,
                    averageDecodeTime: e.decode,
                    resolution: {
                        height: e.height,
                        width: e.width
                    },
                    decoderImplementationName: e.decoderImplementationName,
                    framesDecoded: e.framesDecoded,
                    framesDropped: e.framesDropped,
                    framesDecodeErrors: e.framesDecodeErrors,
                    framesReceived: e.frameCounts.keyFrames + e.frameCounts.deltaFrames,
                    networkFramesDropped: null !== (u = e.networkFramesDropped) && void 0 !== u ? u : 0,
                    keyFramesDecoded: e.frameCounts.keyFrames,
                    frameRateDecode: e.decodeFrameRate,
                    frameRateNetwork: e.networkFrameRate,
                    frameRateRender: e.renderFrameRate,
                    firCount: e.rtcpStats.firPackets,
                    nackCount: e.rtcpStats.nackPackets,
                    pliCount: e.rtcpStats.pliPackets,
                    qpSum: e.qpSum,
                    freezeCount: e.freezeCount,
                    pauseCount: e.pauseCount,
                    totalFreezesDuration: e.totalFreezesDuration,
                    totalPausesDuration: e.totalPausesDuration,
                    totalFramesDuration: e.totalFramesDuration,
                    sumOfSquaredFramesDurations: e.sumOfSquaredFramesDurations,
                    ...null != s ? r({
                        videoJitterBuffer: s.videoJitterBuffer,
                        videoJitterDelay: s.videoJitterDelay,
                        videoJitterTarget: s.videoJitterTarget
                    }) : {}
                }
            }

            function d(e, t, n, s) {
                var o, d, c, h, p;
                let f = null,
                    m = null,
                    E = "string" == typeof t ? JSON.parse(t) : t,
                    g = [];
                if (null != E.outbound) {
                    let {
                        audio: e,
                        video: t,
                        videos: s
                    } = E.outbound;
                    if (null != e) m = (null != m ? m : 0) + e.bytesSent, g.push({
                        type: "audio",
                        ssrc: e.ssrc,
                        sinkWant: (0, i.formatSinkWantStat)(n, e.ssrc, !1),
                        sinkWantAsInt: (0, i.formatSinkWantAsInt)(n, e.ssrc),
                        codec: {
                            id: e.codecPayloadType,
                            name: e.codecName
                        },
                        bytesSent: e.bytesSent,
                        packetsSent: e.packetsSent,
                        packetsLost: Math.max(0, e.packetsLost),
                        fractionLost: 100 * e.fractionLost,
                        audioLevel: e.audioLevel / 32768,
                        audioDetected: e.speaking,
                        framesCaptured: e.framesCaptured,
                        framesRendered: e.framesRendered,
                        noiseCancellerProcessTime: e.noiseCancellerProcessTime,
                        voiceActivityDetectorProcessTime: e.voiceActivityDetectorProcessTime
                    });
                    if (null != s) s.forEach(e => {
                        let t = l(e, n);
                        null != t && (m = (null != m ? m : 0) + t.bytesSent, g.push(t))
                    });
                    else if (null != t) {
                        let e = l(t, n);
                        null != e && (m = (null != m ? m : 0) + e.bytesSent, g.push(e))
                    }
                }
                let S = {};
                null != E.inbound && E.inbound.forEach(e => {
                    let {
                        id: t,
                        audio: o,
                        video: l,
                        videos: d,
                        playout: c
                    } = e;
                    if (S[t] = [], null != o) f = (null != f ? f : 0) + o.bytesReceived, S[t].push({
                        type: "audio",
                        ssrc: o.ssrc,
                        sinkWant: (0, i.formatSinkWantStat)(n, o.ssrc, !1),
                        sinkWantAsInt: (0, i.formatSinkWantAsInt)(n, o.ssrc),
                        codec: {
                            id: o.codecPayloadType,
                            name: o.codecName
                        },
                        bytesReceived: o.bytesReceived,
                        packetsReceived: o.packetsReceived,
                        packetsLost: o.packetsLost,
                        fractionLost: 100 * o.fractionLost,
                        fecPacketsReceived: o.fecPacketsReceived,
                        fecPacketsDiscarded: o.fecPacketsDiscarded,
                        audioLevel: o.audioLevel / 32768,
                        audioDetected: o.speaking,
                        jitter: o.jitter,
                        jitterBuffer: o.jitterBuffer,
                        jitterBufferPreferred: o.jitterBufferPreferred,
                        decodingCNG: o.decodingCNG,
                        decodingMutedOutput: o.decodingMutedOutput,
                        decodingNormal: o.decodingNormal,
                        decodingPLC: o.decodingPLC,
                        decodingPLCCNG: o.decodingPLCCNG,
                        accelerateRate: 100 * o.accelerateRate,
                        expandRate: 100 * o.expandRate,
                        preemptiveExpandRate: 100 * o.preemptiveExpandRate,
                        speechExpandRate: 100 * o.speechExpandRate,
                        secondaryDecodedRate: 100 * o.secondaryDecodedRate,
                        opSilence: o.opSilence,
                        opNormal: o.opNormal,
                        opMerge: o.opMerge,
                        opExpand: o.opExpand,
                        opAccelerate: o.opAccelerate,
                        opPreemptiveExpand: o.opPreemptiveExpand,
                        opCNG: o.opCNG,
                        delayEstimate: o.delayEstimate,
                        ...null != c ? r({
                            audioJitterBuffer: c.audioJitterBuffer,
                            audioJitterDelay: c.audioJitterDelay,
                            audioJitterTarget: c.audioJitterTarget,
                            audioPlayoutUnderruns: c.audioPlayoutUnderruns,
                            relativeReceptionDelay: c.relativeReceptionDelay,
                            relativePlayoutDelay: c.relativePlayoutDelay
                        }) : {}
                    });
                    if (null != d) d.forEach(e => {
                        let i = u(e, n, s, c);
                        if (null != i) {
                            let n = a(e.rtpStats);
                            f = (null != f ? f : 0) + n, S[t].push(i)
                        }
                    });
                    else if (null != l) {
                        let e = u(l, n, s, c);
                        if (null != e) {
                            let n = a(l.rtpStats);
                            f = (null != f ? f : 0) + n, S[t].push(e)
                        }
                    }
                });
                let {
                    transport: _,
                    clips: v
                } = E, C = {};
                null != _ && (C.availableOutgoingBitrate = _.sendBandwidth, C.ping = _.rtt, C.decryptionFailures = _.decryptionFailures, null != _.routingFailures && (C.routingFailures = _.routingFailures), C.localAddress = _.localAddress, C.pacerDelay = _.pacerDelay, null != _.receiverReports && (C.receiverReports = _.receiverReports), C.receiverBitrateEstimate = _.receiverBitrateEstimate, C.outboundBitrateEstimate = _.outboundBitrateEstimate, C.inboundBitrateEstimate = null !== (o = _.inboundBitrateEstimate) && void 0 !== o ? o : 0, C.packetsReceived = _.packetsReceived, C.packetsSent = _.packetsSent, null != _.secureFramesProtocolVersion && (C.secureFramesProtocolVersion = _.secureFramesProtocolVersion)), ((null == _ ? void 0 : _.bytesReceived) != null || null != f && !Number.isNaN(f)) && (C.bytesReceived = null !== (c = null !== (d = null == _ ? void 0 : _.bytesReceived) && void 0 !== d ? d : f) && void 0 !== c ? c : void 0), ((null == _ ? void 0 : _.bytesSent) != null || null != m && !Number.isNaN(m)) && (C.bytesSent = null !== (p = null !== (h = null == _ ? void 0 : _.bytesSent) && void 0 !== h ? h : m) && void 0 !== p ? p : void 0);
                let {
                    screenshare: T,
                    camera: I
                } = E, A = null != I ? {
                    capturedFramesDropped: I.capturedFramesDropped,
                    capturedFramesCount: I.capturedFramesCount,
                    capturedFramesMean: I.capturedFramesMean,
                    capturedFramesStdev: I.capturedFramesStdev
                } : null;
                return {
                    mediaEngineConnectionId: e,
                    transport: C,
                    screenshare: T,
                    camera: A,
                    clips: v,
                    rtp: {
                        inbound: S,
                        outbound: g
                    }
                }
            }
        },
        710584: function(e, t, n) {
            "use strict";
            n.r(t), n.d(t, {
                default: function() {
                    return a
                }
            });
            var i = n("37983");
            n("884691");
            var s = n("595432");

            function a(e) {
                let {
                    disabled: t,
                    deviceId: n,
                    width: a,
                    height: o
                } = e;
                return t ? (0, i.jsx)("div", {
                    className: "media-engine-video",
                    style: {
                        width: a,
                        height: o
                    }
                }) : (0, i.jsx)(s.default, {
                    streamId: n,
                    style: {
                        width: a,
                        height: o
                    }
                })
            }
            a.defaultProps = {
                disabled: !1,
                width: 320,
                height: 180
            }
        },
        40217: function(e, t, n) {
            "use strict";
            n.r(t), n.d(t, {
                default: function() {
                    return p
                }
            });
            var i = n("37983"),
                s = n("884691"),
                a = n("677935"),
                o = n.n(a),
                r = n("773179"),
                l = n.n(r),
                u = n("784063"),
                d = n("104240"),
                c = n("340346"),
                h = n("625454");

            function p(e) {
                let {
                    streamId: t,
                    paused: n,
                    onReady: a,
                    onResize: r,
                    className: p,
                    ...f
                } = e, m = s.useRef(null), {
                    current: E
                } = s.useRef(l.uniqueId("media-engine-video-"));
                return s.useEffect(() => {
                    let e = m.current;
                    if (!n && null != e) {
                        let n = !1,
                            i = (t, i) => {
                                !n && (null == a || a(), n = !0), (e.width !== t || e.height !== i) && (e.width = t, e.height = i, null == r || r({
                                    width: t,
                                    height: i
                                }))
                            },
                            s = (0, u.getVoiceEngine)();
                        if (null != s.addVideoOutputSink) return s.addVideoOutputSink(E, t, i), () => {
                            s.removeVideoOutputSink(E, t)
                        };
                        {
                            let n = function(e) {
                                var t, n, i, s;
                                let a = null === (s = window) || void 0 === s ? void 0 : null === (i = s.DiscordNative) || void 0 === i ? void 0 : null === (n = i.app) || void 0 === n ? void 0 : null === (t = n.getReleaseChannel) || void 0 === t ? void 0 : t.call(n);
                                return "canary" === a || "development" === a ? (0, c.initRenderingContextWebGL)(e) : (0, d.initRenderingContext2D)(e)
                            }(e);
                            if (null == n) return;
                            return h.default.addSink(t, m, e => {
                                i(e.width, e.height), n.render(e)
                            }), () => {
                                h.default.removeSink(t, m)
                            }
                        }
                    }
                }, [t, n, r, a, E]), (0, i.jsx)("canvas", {
                    id: E,
                    className: o("media-engine-video", p),
                    ref: m,
                    ...f
                })
            }
            p.defaultProps = {
                paused: !1
            }
        },
        832359: function(e, t, n) {
            "use strict";
            n.r(t), n.d(t, {
                default: function() {
                    return p
                }
            }), n("222007");
            var i = n("37983"),
                s = n("884691"),
                a = n("677935"),
                o = n.n(a),
                r = n("811022"),
                l = n("784063");
            let u = new r.default("DirectVideo");
            class d {
                addref() {
                    this.refcount++
                }
                release() {
                    return this.refcount--, 0 === this.refcount
                }
                constructor(e) {
                    this.refcount = 1, this.stream = window.createDiscordStream(e)
                }
            }
            let c = new Map;

            function h(e) {
                let t = c.get(e);
                null != t && t.release() && ((0, l.getVoiceEngine)().removeDirectVideoOutputSink(e), c.delete(e))
            }

            function p(e) {
                let {
                    streamId: t,
                    paused: n,
                    onReady: a,
                    onResize: r,
                    className: p,
                    ...f
                } = e, m = s.useRef(null), E = s.useRef(null), g = s.useRef({
                    width: 0,
                    height: 0
                }), S = s.useRef({
                    streamId: t,
                    paused: n,
                    onReady: a,
                    onResize: r
                });
                return s.useLayoutEffect(() => {
                    let {
                        current: e
                    } = m;
                    if (null != e) {
                        let t = document.createElement("video");
                        t.style.display = "block", t.style.width = "100%", t.style.height = "100%", t.autoplay = !0, t.muted = !0, t.addEventListener("pause", function() {
                            if (!S.current.paused) {
                                var e;
                                null === (e = E.current) || void 0 === e || e.play()
                            }
                        }), t.addEventListener("resize", function() {
                            var e, t, n, i, s, a;
                            let {
                                width: o,
                                height: r
                            } = g.current, l = null !== (n = null === (e = E.current) || void 0 === e ? void 0 : e.videoWidth) && void 0 !== n ? n : 0, u = null !== (i = null === (t = E.current) || void 0 === t ? void 0 : t.videoHeight) && void 0 !== i ? i : 0;
                            if (o !== l || r !== u) {
                                let e = {
                                    width: l,
                                    height: u
                                };
                                null === (s = (a = S.current).onResize) || void 0 === s || s.call(a, e), g.current = e
                            }
                        }), t.addEventListener("canplaythrough", function() {
                            var e, t;
                            u.info("handleReady for ".concat(S.current.streamId, ", have onReady callback = ").concat(null != S.current.onReady)), null === (e = (t = S.current).onReady) || void 0 === e || e.call(t)
                        }), u.info("create video element for ".concat(S.current.streamId, ", readyState=").concat(t.readyState)), t.readyState > 3 && u.error("video element for ".concat(S.current.streamId, " was ready before attached")), e.appendChild(t), E.current = t
                    }
                }, []), s.useEffect(() => {
                    S.current.streamId = t, S.current.paused = n, S.current.onReady = a, S.current.onResize = r
                }), s.useEffect(() => {
                    let e = E.current;
                    if (null != e) {
                        if (n) null != e.srcObject && (e.srcObject = null, h(t));
                        else {
                            var i;
                            let n;
                            u.info("attaching srcObject for ".concat(t));
                            return e.srcObject = (i = t, null == (n = c.get(i)) ? (n = new d(i), (0, l.getVoiceEngine)().addDirectVideoOutputSink(i), c.set(i, n)) : n.addref(), n.stream), () => {
                                h(t), e.srcObject = null
                            }
                        }
                    }
                }, [n, t]), (0, i.jsx)("div", {
                    className: o("media-engine-video", p),
                    ref: m,
                    ...f
                })
            }
            p.defaultProps = {
                paused: !1
            }
        },
        595432: function(e, t, n) {
            "use strict";
            n.r(t), n.d(t, {
                default: function() {
                    return a
                }
            });
            var i = n("40217"),
                s = n("832359");

            function a(e) {
                return a.useDirectVideo ? (0, s.default)(e) : (0, i.default)(e)
            }
            a.defaultProps = i.default.defaultProps, a.useDirectVideo = !1
        },
        625454: function(e, t, n) {
            "use strict";
            n.r(t), n.d(t, {
                default: function() {
                    return s
                }
            }), n("222007");
            var i = n("784063"),
                s = new class e {
                    addSink(e, t, n) {
                        let s = this.streams,
                            a = s[e];
                        if (null == a && (a = s[e] = new Map), 0 === a.size) {
                            let t = (0, i.getVoiceEngine)();
                            t.setVideoOutputSink(e, this.handleImageData.bind(this, t.signalVideoOutputSinkReady.bind(t, e), a), !0)
                        }
                        a.set(t, n)
                    }
                    removeSink(e, t) {
                        let n = this.streams,
                            s = n[e];
                        if (null != s && (s.delete(t), 0 === s.size)) {
                            delete n[e];
                            let t = (0, i.getVoiceEngine)();
                            t.setVideoOutputSink(e)
                        }
                    }
                    handleImageData(e, t, n) {
                        for (let e of t.values()) e(n);
                        e()
                    }
                    constructor() {
                        this.streams = {}
                    }
                }
        },
        953161: function(e, t, n) {
            "use strict";
            n.r(t), n.d(t, {
                default: function() {
                    return a
                }
            }), n("424973"), n("222007");
            var i = n("773364"),
                s = n("22546");

            function a(e) {
                let t = !1;
                e.on(i.MediaEngineEvent.Destroy, () => t = !0);
                let n = async () => {
                    if (t) return;
                    let a = [];
                    e.eachConnection(e => a.push({
                        connection: e,
                        stats: e.emitStats()
                    }));
                    let o = [];
                    for (let e of a) {
                        let t = await e.stats;
                        null != t && o.push({
                            connection: e.connection,
                            stats: t
                        })
                    }
                    e.emit(i.MediaEngineEvent.ConnectionStats, o), setTimeout(n, s.STATS_INTERVAL)
                };
                setTimeout(n, s.STATS_INTERVAL)
            }
        },
        668906: function(e, t, n) {
            "use strict";
            n.r(t), n.d(t, {
                getExperimentCodecs: function() {
                    return a
                },
                filterVideoCodecs: function() {
                    return o
                },
                codecNameToPayloadName: function() {
                    return l
                }
            }), n("222007");
            var i = n("353927");
            let s = ["H264", "VP8", "VP9"];

            function a(e) {
                let t = [];
                return e.has(i.ExperimentFlags.SIGNAL_H265_SUPPORT) && (t = ["H265"].concat(t)), e.has(i.ExperimentFlags.SIGNAL_AV1_SUPPORT) && (t = ["AV1"].concat(t)), t.slice()
            }

            function o(e, t) {
                return "string" == typeof e ? function(e, t) {
                    let n = JSON.parse(e),
                        i = new Map(n.map(e => [r(e.codec), [e.encode, e.decode]])),
                        a = [...i.keys()],
                        o = t.concat(s);
                    return o.filter(e => a.includes(e)).map(e => [e, i.get(e)])
                }(e, t) : function(e, t) {
                    let n = new Map(e.map(e => [r(e), [!0, !0]])),
                        i = e.map(e => e.toUpperCase()),
                        a = t.concat(s);
                    return a.filter(e => i.includes(e)).map(e => [e, n.get(e)])
                }(e, t)
            }

            function r(e) {
                return "AV1X" === e ? "AV1" : e
            }

            function l(e) {
                return "AV1" === e ? "AV1X" : e
            }
        },
        67021: function(e, t, n) {
            "use strict";

            function i() {
                var e, t;
                return "undefined" == typeof platform ? 0 : parseInt(null !== (t = null === (e = platform) || void 0 === e ? void 0 : e.version) && void 0 !== t ? t : "0", 10)
            }
            n.r(t), n.d(t, {
                platformVersion: function() {
                    return i
                }
            })
        },
        823302: function(e, t, n) {
            "use strict";

            function i(e, t, n) {
                let i = e[t];
                return null == i ? n ? "".concat(e.any, " (any)") : "100" : i.toString()
            }

            function s(e, t) {
                let n = e[t];
                return null == n ? e.any : n
            }
            n.r(t), n.d(t, {
                formatSinkWantStat: function() {
                    return i
                },
                formatSinkWantAsInt: function() {
                    return s
                }
            })
        },
        793722: function(e, t, n) {
            "use strict";
            n.r(t), n.d(t, {
                registerActiveSink: function() {
                    return a
                },
                unregisterActiveSink: function() {
                    return o
                },
                setActiveSinksChangeCallback: function() {
                    return r
                }
            });
            let i = {},
                s = null;

            function a(e) {
                var t;
                let n = null !== (t = i[e]) && void 0 !== t ? t : 0;
                0 === n && (null == s || s(e, !0)), i[e] = n + 1
            }

            function o(e) {
                i[e]--, 0 === i[e] && (null == s || s(e, !1))
            }

            function r(e) {
                s = null != e ? e : null
            }
        },
        657869: function(e, t, n) {
            "use strict";
            n.r(t), n.d(t, {
                default: function() {
                    return i
                }
            }), n("70102");
            var i, s = n("44170"),
                a = n("811022"),
                o = n("861001"),
                r = n("201617"),
                l = n("581785"),
                u = n("111000"),
                d = n("353927"),
                c = n("843455");
            let h = new a.default("Output"),
                p = new r.default;
            i = class extends s.EventEmitter {
                destroy() {
                    var e, t;
                    this.removeAllListeners(), null === (e = this.cleanup) || void 0 === e || e.call(this), this.reset(), null != this.stream && (p.release(this.stream), this.stream = void 0), null === (t = this._audioFilter) || void 0 === t || t.dispose(), this._audioFilter = void 0, this.destroyed = !0
                }
                reset() {
                    this.setSpeaking(!1)
                }
                resume() {
                    this.context.resume()
                }
                get state() {
                    return this.context.state
                }
                getDelayedStream() {
                    let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : .2,
                        t = this.context;
                    if (null == this.stream) throw Error("AudioInput: No MediaStream");
                    let n = t.createDelay(e);
                    n.delayTime.value = e;
                    let i = t.createMediaStreamSource(this.stream);
                    i.connect(n);
                    let s = t.createMediaStreamDestination();
                    return n.connect(s), s.stream
                }
                get mute() {
                    return this._mute
                }
                set mute(e) {
                    this._mute = e, this.updateAudioTracks(), this.setSpeaking(!1)
                }
                get echoCancellation() {
                    return this._echoCancellation
                }
                set echoCancellation(e) {
                    this._echoCancellation !== e && (this._echoCancellation = e, null != this.stream && this.enable())
                }
                get noiseSuppression() {
                    return this._noiseSuppression
                }
                set noiseSuppression(e) {
                    this._noiseSuppression !== e && (this._noiseSuppression = e, null != this.stream && this.enable())
                }
                get noiseCancellation() {
                    return this._noiseCancellation
                }
                set noiseCancellation(e) {
                    this._noiseCancellation !== e && (this._noiseCancellation = e, null != this.stream && this.enable())
                }
                get automaticGainControl() {
                    return this._automaticGainControl
                }
                set automaticGainControl(e) {
                    this._automaticGainControl !== e && (this._automaticGainControl = e, null != this.stream && this.enable())
                }
                async enable() {
                    null != this.cleanup && (this.cleanup(), this.cleanup = void 0), null != this.stream && (p.release(this.stream), this.stream = void 0);
                    let e = await (0, o.getAudioInputDevices)(),
                        t = {
                            echoCancellation: this.echoCancellation,
                            noiseSuppression: this.noiseSuppression,
                            autoGainControl: this.automaticGainControl
                        };
                    e.some(e => e.id === this.sourceId) && (t.deviceId = this.sourceId);
                    try {
                        let e = await p.acquire({
                            audio: t
                        });
                        if (this.destroyed) throw p.release(e), Error("AudioInput: Already destroyed");
                        if (this._noiseCancellation) try {
                            let t = await (0, l.getKrispSDK)();
                            this._audioFilter = await t.createNoiseFilter(this.context), this._audioFilter.addEventListener("ready", e => {
                                var t;
                                null === (t = this._audioFilter) || void 0 === t || t.enable()
                            }), this._audioFilter.addEventListener("dispose", t => {
                                p.release(e)
                            });
                            let n = this.context.createMediaStreamSource(e),
                                i = this.context.createMediaStreamDestination();
                            n.connect(this._audioFilter), this._audioFilter.connect(i), this.stream = i.stream
                        } catch (t) {
                            h.error("failure creating krisp node"), h.error(t), this.stream = e
                        } else this.stream = e;
                        return this.updateMode(), this.updateAudioTracks(), this.emit("permission", !0), this.emit("stream", this.stream), e
                    } catch (e) {
                        if ("string" != typeof e) switch (e.name) {
                            case "PermissionDeniedError":
                            case "NotAllowedError":
                                throw this.emit("permission", !1), c.UserMediaErrors.PERMISSION_DENIED;
                            case "PermissionDismissedError":
                                throw this.emit("permission", !1), c.UserMediaErrors.PERMISSION_DISMISSED;
                            case "DevicesNotFoundError":
                            case "NotFoundError":
                                throw c.UserMediaErrors.NO_DEVICES_FOUND;
                            default:
                                throw e.name || "UNKNOWN"
                        }
                        throw e
                    }
                }
                setSource(e) {
                    this.sourceId !== e && (this.sourceId = e, null != this.stream && this.enable())
                }
                setPTTActive(e) {
                    if (!this.mute) this.speaking !== e && (null != this.pttReleaseDelayTimeout && (window.clearTimeout(this.pttReleaseDelayTimeout), this.pttReleaseDelayTimeout = void 0), e ? this.setSpeaking(e) : this.pttReleaseDelayTimeout = window.setTimeout(() => {
                        this.setSpeaking(!1), this.pttReleaseDelayTimeout = void 0
                    }, this.modeOptions.delay))
                }
                setMode(e, t) {
                    this.mode = e, this.modeOptions = t, null != this.stream && this.enable()
                }
                updateMode() {
                    null != this.cleanup && (this.cleanup(), this.cleanup = void 0), null != this.stream && this.mode === d.InputModes.VOICE_ACTIVITY && (this.cleanup = this.setupVoiceActivity(this.modeOptions))
                }
                setupVoiceActivity(e) {
                    let {
                        threshold: t
                    } = e;
                    if (null == this.stream) throw Error("stream cannot be null");
                    null == t && (t = -40);
                    let n = new u.default(this.context, this.stream, t);
                    return n.onProcess = (e, t) => {
                        !this.mute && this.setSpeaking(e), this.emit("voiceactivity", t)
                    }, () => {
                        null != n && (n.stop(), n = null, this.setSpeaking(!1))
                    }
                }
                setSpeaking(e) {
                    this.speaking !== e && (this.speaking = e, this.emit("speaking", e))
                }
                updateAudioTracks() {
                    if (null != this.stream) {
                        let e = this.stream.getAudioTracks();
                        for (let t = 0, n = e.length; t < n; t++) e[t].enabled = !this._mute
                    }
                }
                constructor(e) {
                    super(), this._mute = !1, this._echoCancellation = !0, this._noiseSuppression = !0, this._automaticGainControl = !0, this._noiseCancellation = !1, this._audioFilter = void 0, this.speaking = !1, this.mode = d.InputModes.VOICE_ACTIVITY, this.modeOptions = {
                        delay: 20,
                        threshold: -40
                    }, this.destroyed = !1, this.context = e
                }
            }
        },
        566106: function(e, t, n) {
            "use strict";
            n.r(t), n.d(t, {
                EncoderParameter: function() {
                    return i
                },
                default: function() {
                    return s
                }
            }), n("222007"), n("70102"), n("860677");
            var i, s, a, o = n("773179"),
                r = n.n(o),
                l = n("947279"),
                u = n("773364"),
                d = n("62684"),
                c = n("324304"),
                h = n("849074"),
                p = n("948961"),
                f = n("353927"),
                m = n("53452");
            (a = i || (i = {}))[a.AUDIO_BITRATE = 0] = "AUDIO_BITRATE", a[a.VIDEO_RESOLUTION_SCALE = 1] = "VIDEO_RESOLUTION_SCALE", a[a.VIDEO_BITRATE = 2] = "VIDEO_BITRATE", a[a.VIDEO_FRAMERATE = 3] = "VIDEO_FRAMERATE", s = class extends l.default {
                interact() {
                    for (let e of (this.interacted = !0, Object.keys(this.outputs))) this.outputs[e].play();
                    this.input.resumeAudio()
                }
                destroy() {
                    for (let e of (super.destroy(), Object.keys(this.outputs))) this.destroyOutput(e);
                    this.input.destroy()
                }
                async getStats() {
                    if (!m.BROWSER_SUPPORTS_DIAGNOSTICS) return null;
                    let e = await this.getRawStats();
                    return (0, p.default)(e, this.getUserIdBySsrc, this.remoteVideoSinkWants, this.localVideoSinkWants)
                }
                setInputMode(e, t) {
                    this.input.setAudioMode(e, {
                        delay: t.pttReleaseDelay,
                        threshold: t.vadThreshold
                    })
                }
                setSelfDeaf(e) {
                    for (let t of (this.selfDeaf = e, Object.keys(this.outputs))) this.outputs[t].mute = e || this.localMutes[t]
                }
                setLocalMute(e, t) {
                    this.localMutes[e] = t, null != this.outputs[e] && (this.outputs[e].mute = this.selfDeaf || t), this.emit(u.BaseConnectionEvent.LocalMute, e, t)
                }
                fastUdpReconnect() {}
                getNumFastUdpReconnects() {
                    return null
                }
                setRemoteVideoSinkWants(e) {
                    this.remoteVideoSinkWants = e, this.updateVideoQuality(f.MEDIA_SINK_WANTS_PROPERTIES)
                }
                setLocalVideoSinkWants(e) {
                    this.localVideoSinkWants = e
                }
                updateVideoQualityCore(e, t) {
                    let n;
                    if (!this.videoSupported) return;
                    let i = this.input.getVideoStream();
                    if (null == i) return;
                    if (null != t.capture && null != t.capture.width && null != t.capture.height && null != e.remoteSinkWantsPixelCount && 0 !== e.remoteSinkWantsPixelCount && 0 !== t.capture.height) {
                        let i = t.capture.width / t.capture.height,
                            s = Math.sqrt(e.remoteSinkWantsPixelCount * i),
                            a = t.capture.width / s;
                        n = a < 1 ? void 0 : a
                    }
                    this.logger.info("BaseWebRTCConnection.updateVideoQuality: resolutionScaleFactor: ".concat(n, ", ") + "encodingVideoWidth: ".concat(e.encodingVideoWidth, ", remoteSinkWantsMaxFramerate: ").concat(e.remoteSinkWantsMaxFramerate, ", ") + "encodingVideoMaxBitRate: ".concat(e.encodingVideoMaxBitRate, ", localWant: ").concat(this.getLocalWant())), this.setVideoEncoderParameters([{
                        parameter: 1,
                        value: n
                    }, {
                        parameter: 2,
                        value: e.encodingVideoMaxBitRate
                    }, {
                        parameter: 3,
                        value: e.remoteSinkWantsMaxFramerate
                    }]);
                    let s = e.encodingVideoWidth,
                        a = e.encodingVideoHeight;
                    for (let e of i.getTracks()) {
                        var o, r;
                        let t = e.getConstraints(),
                            n = null === (o = t.width) || void 0 === o ? void 0 : o.max,
                            i = null === (r = t.height) || void 0 === r ? void 0 : r.max;
                        (n !== s || i !== a) && (this.logger.info("BaseWebRTCConnection.updateVideoQuality: old: ".concat(n, " x ").concat(i, ", new: ").concat(s, " x ").concat(a)), t.width = {
                            max: s
                        }, t.height = {
                            max: a
                        }, e.applyConstraints(t))
                    }
                }
                setCanHavePriority(e, t) {
                    let n = this.canHavePriority.size;
                    t ? this.canHavePriority.add(e) : this.canHavePriority.delete(e), this.canHavePriority.size !== n && this.recalculatePrioritySpeakers()
                }
                setSpeakingFlags(e, t) {
                    null != t && t !== f.SpeakingFlags.NONE ? this.localSpeakingFlags[e] = t : delete this.localSpeakingFlags[e];
                    let n = this.outputs[e];
                    null != n && n.setSpeakingFlags(t);
                    let i = this.wantsPriority.size,
                        s = f.SpeakingFlags.VOICE | f.SpeakingFlags.PRIORITY;
                    (t & s) === s ? this.wantsPriority.add(e) : this.wantsPriority.delete(e), this.wantsPriority.size !== i && this.recalculatePrioritySpeakers()
                }
                clearAllSpeaking() {
                    for (let e in this.localSpeakingFlags) delete this.localSpeakingFlags[e], null != this.outputs[e] && this.outputs[e].setSpeakingFlags(f.SpeakingFlags.NONE)
                }
                setOutputVolume(e) {
                    for (let t of (this.outputVolume = e, Object.keys(this.outputs))) this.outputs[t].volume = this.computeLocalVolume(t)
                }
                setSinkId(e) {
                    for (let t of (this.sinkId = e, Object.keys(this.outputs))) this.outputs[t].setSinkId(e)
                }
                setStreamParameters(e) {
                    return new Promise((t, n) => {
                        for (let t of this.videoStreamParameters) {
                            let i = e.findIndex(e => e.rid === t.rid);
                            if (-1 === i) {
                                n(Error("Invalid rid"));
                                return
                            }!r.isEqual(this.videoStreamParameters[i], e[i]) && (this.videoStreamParameters[i] = {
                                ...e[i]
                            })
                        }
                        t()
                    })
                }
                recalculatePrioritySpeakers() {
                    this.prioritySpeakers = new Set(Array.from(this.wantsPriority).filter(e => this.canHavePriority.has(e))), r.forEach(this.outputs, (e, t) => {
                        e.volume = this.computeLocalVolume(t)
                    })
                }
                setBitRate(e) {
                    this.voiceBitrate = e
                }
                setLocalVolume(e, t) {
                    this.localVolumes[e] = t, null != this.outputs[e] && (this.outputs[e].volume = this.computeLocalVolume(e))
                }
                getLocalVolume(e) {
                    let t = this.localVolumes[e];
                    return null == t && (t = this.context === f.MediaEngineContextTypes.DEFAULT ? f.DEFAULT_VOLUME : f.DEFAULT_STREAM_VOLUME), null != t ? t : f.DEFAULT_VOLUME
                }
                computeLocalVolume(e) {
                    let t = this.outputVolume * this.getLocalVolume(e) / f.DEFAULT_VOLUME;
                    return this.prioritySpeakers.size > 0 && !this.prioritySpeakers.has(e) ? t * f.DEFAULT_PRIORITY_SPEAKER_DUCKING : t
                }
                hasDesktopSource() {
                    var e;
                    return null === (e = this.input) || void 0 === e ? void 0 : e.hasDesktopSource()
                }
                createOutput(e, t) {
                    if (t.discordIsTearingDown) {
                        this.logger.info("BaseWebRTCConnection.createOutput: ignoring track being torn down: ".concat(t.id));
                        return
                    }
                    let n = this.outputs[e];
                    if (null == n) {
                        var i;
                        (n = new c.default(e, this.audioContext)).mute = this.selfDeaf || this.localMutes[e], n.volume = this.computeLocalVolume(e), n.on(c.OutputEvent.Speaking, t => this.emit(u.BaseConnectionEvent.Speaking, e, t, this.audioSSRC)), n.on(c.OutputEvent.Video, t => {
                            var n;
                            return this.emitUnsafe(u.BaseConnectionEvent.Video, e, t, this.audioSSRC, this.videoStreamParameters[0].ssrc, null !== (n = this.videoStreamParameters[0].rtxSsrc) && void 0 !== n ? n : 0, this.videoStreamParameters)
                        }), n.on(c.OutputEvent.InteractionRequired, e => this.emit(u.BaseConnectionEvent.InteractionRequired, e)), n.setSpeakingFlags(null !== (i = this.localSpeakingFlags[e]) && void 0 !== i ? i : f.SpeakingFlags.NONE), n.setSinkId(this.sinkId), this.outputs[e] = n
                    }
                    n.addTrack(t)
                }
                destroyOutput(e, t) {
                    let n = this.outputs[e];
                    null != n && (null == t || 0 === n.removeTrack(t)) && (n.destroy(), delete this.outputs[e])
                }
                setSilenceThreshold(e) {
                    this.silenceThreshold = e
                }
                setLocalPan(e, t, n) {}
                setExperimentalEncoders(e) {}
                setHardwareH264(e) {}
                setQoS(e) {}
                isAttenuating() {
                    return !1
                }
                setAttenuation(e, t, n) {}
                setEncryption(e, t) {}
                setMinimumJitterBufferLevel(e) {}
                setPostponeDecodeLevel(e) {}
                setReconnectInterval(e) {}
                setKeyframeInterval(e) {}
                startSamplesPlayback(e, t, n) {}
                stopSamplesPlayback() {}
                startSamplesLocalPlayback(e, t, n, i) {}
                stopSamplesLocalPlayback(e) {}
                stopAllSamplesLocalPlayback() {}
                setRtcLogEphemeralKey(e) {}
                setRtcLogMarker(e) {}
                setVideoQualityMeasurement(e) {}
                setVideoEncoderExperiments(e) {}
                setBandwidthEstimationExperiments(e) {}
                prepareSecureFramesTransition(e, t, n) {}
                executeSecureFramesTransition(e) {}
                constructor(e, t, n, i) {
                    var s;
                    super(e, t), s = this, this.silenced = !1, this.interacted = !1, this.outputVolume = f.DEFAULT_VOLUME, this.sinkId = f.DEFAULT_DEVICE_ID, this.lastPingTime = 0, this.outputs = {}, this.webrtcStats = new h.WebRTCStatsCalculator, this.silenceThreshold = -100, this.canHavePriority = new Set, this.prioritySpeakers = new Set, this.setEchoCancellation = e => this.input.setEchoCancellation(e), this.setNoiseSuppression = e => this.input.setNoiseSuppression(e), this.setNoiseCancellation = e => this.input.setNoiseCancellation(e), this.setAutomaticGainControl = e => this.input.setAutomaticGainControl(e), this.setAudioSource = e => this.input.setAudioSource(e), this.setVideoSource = e => this.input.setVideoSource(e), this.setDesktopInput = e => this.input.setDesktop(e), this.setForceAudioInput = function(e) {
                        return arguments.length > 1 && void 0 !== arguments[1] && arguments[1], s.input.setPTTActive(e)
                    }, this.setSelfMute = e => {
                        this.input.setMute(e), this.emit(u.BaseConnectionEvent.Mute, e)
                    }, this.handleAddVideoTrack = () => {
                        this.updateVideoQuality()
                    }, this.handleAudioPermission = e => this.emit(u.BaseConnectionEvent.AudioPermission, e), this.handleVideoPermission = e => this.emit(u.BaseConnectionEvent.VideoPermission, e), this.handleVideo = e => {
                        var t;
                        return this.emit(u.BaseConnectionEvent.Video, this.ids.userId, e, this.audioSSRC, this.videoStreamParameters[0].ssrc, null !== (t = this.videoStreamParameters[0].rtxSsrc) && void 0 !== t ? t : 0, this.videoStreamParameters)
                    }, this.handleDesktopSourceEnd = () => this.emit(u.BaseConnectionEvent.DesktopSourceEnd), this.handleStream = e => this.setStream(e), this.handleVoiceActivity = e => {
                        let t = e <= this.silenceThreshold;
                        this.silenced !== t && !this.input.mute() && (this.silenced = t, this.emit(u.BaseConnectionEvent.Silence, t))
                    }, this.handleNewListener = e => {
                        switch (e) {
                            case u.BaseConnectionEvent.Video:
                                this.videoReady && setImmediate(() => this.handleVideo(this.input.getVideoStreamId()));
                                break;
                            case u.BaseConnectionEvent.ConnectionStateChange:
                                this.emit(e, this.connectionState);
                                break;
                            case u.BaseConnectionEvent.InteractionRequired:
                                !this.interacted && "suspended" === this.input.getAudioState() && setImmediate(() => this.emit(e, !0))
                        }
                    }, this.handleInputSpeaking = e => {
                        this.emit(u.BaseConnectionEvent.Speaking, this.ids.userId, e ? f.SpeakingFlags.VOICE : f.SpeakingFlags.NONE, this.audioSSRC)
                    }, this.handleAudioContextStateChange = () => {
                        !this.interacted && "running" === this.input.getAudioState() && (this.interact(), this.emit(u.BaseConnectionEvent.InteractionRequired, !1))
                    }, this.handleStats = e => {
                        if (this.connectionState === f.ConnectionStates.DISCONNECTED) {
                            this.off(u.BaseConnectionEvent.Stats, this.handleStats);
                            return
                        }
                        null != e && (this.webrtcStats.update(e), this.stats = e, Date.now() - this.lastPingTime >= f.PING_INTERVAL && (this.emit(u.BaseConnectionEvent.Ping, e.transport.ping), this.lastPingTime = Date.now()))
                    }, this.input = new d.default(n), n.addEventListener("statechange", this.handleAudioContextStateChange), this.audioContext = n, this.input.on(d.InputEvent.AudioPermission, this.handleAudioPermission), this.input.on(d.InputEvent.VideoPermission, this.handleVideoPermission), this.input.on(d.InputEvent.Video, this.handleVideo), this.input.on(d.InputEvent.Mute, e => this.emit(u.BaseConnectionEvent.Mute, e)), this.input.on(d.InputEvent.Stream, this.handleStream), this.input.on(d.InputEvent.DesktopSourceEnd, this.handleDesktopSourceEnd), this.input.on(d.InputEvent.Speaking, this.handleInputSpeaking), this.input.on(d.InputEvent.AddVideoTrack, this.handleAddVideoTrack), this.input.on(d.InputEvent.Video, this.handleAddVideoTrack), this.on("newListener", this.handleNewListener), this.initializeStreamParameters(i)
                }
            }
        },
        560550: function(e, t, n) {
            "use strict";
            n.r(t), n.d(t, {
                makeConnection: function() {
                    return g
                }
            });
            var i, s = n("383536"),
                a = n.n(s),
                o = n("811022"),
                r = n("773364"),
                l = n("566106"),
                u = n("8479"),
                d = n("62684"),
                c = n("760014"),
                h = n("588446"),
                p = n("779791"),
                f = n("353927"),
                m = n("53452");

            function E(e) {
                return e.split("-")[0]
            }

            function g(e, t, n, s) {
                let r = "".concat(null != a.name && "" !== a.name ? a.name : "unknown", " ").concat(null != a.version && "" !== a.version ? a.version : "unknown"),
                    l = new o.default("Connection(".concat(e, ")"));
                return m.BROWSER_SUPPORTS_UNIFIED_PLAN ? (l.info("Using Unified Plan (".concat(r, ")")), new p.default(e, t, n, s)) : (l.info("Using Plan B (".concat(r, ")")), new i(e, t, n, s))
            }
            i = class extends l.default {
                destroy() {
                    super.destroy(), this.pc.close()
                }
                setCodecs(e, t, n) {
                    var i, s, a;
                    let o;
                    (this.fpc.audioCodec !== e || this.fpc.videoCodec !== t) && (o = this.codecs.find(t => t.name === e), this.fpc.audioCodec = e, this.fpc.audioPayloadType = null !== (i = null == o ? void 0 : o.payloadType) && void 0 !== i ? i : 0, o = this.codecs.find(e => e.name === t), this.fpc.videoCodec = t, this.fpc.videoPayloadType = null !== (s = null == o ? void 0 : o.payloadType) && void 0 !== s ? s : 0, this.fpc.rtxPayloadType = null !== (a = null == o ? void 0 : o.rtxPayloadType) && void 0 !== a ? a : 0, this.pc.negotiationNeeded())
                }
                setStream(e) {
                    this.fpc.direction = null != e ? h.Directions.SENDRECV : h.Directions.SENDONLY, this.pc.setStream(null != e ? e : null)
                }
                createUser(e, t, n) {
                    var i;
                    if (0 === t) {
                        this.logger.warn("Attempting to create user ".concat(e, " with 0 audio SSRC"));
                        return
                    }
                    this.logger.info("Creating user: ".concat(e, " with audio SSRC: ").concat(t, " and video SSRCs: ").concat(null !== (i = null == n ? void 0 : n.join(",")) && void 0 !== i ? i : 0));
                    let s = null != n && n.length > 0 ? n[0] : 0;
                    this.fpc.addStream(e, t, s)
                }
                destroyUser(e) {
                    this.fpc.removeStream(e)
                }
                setBitRate(e) {
                    this.voiceBitrate !== e && (super.setBitRate(e), this.pc.setBitRate(e))
                }
                setSDP(e) {
                    this.pc.on("offer", () => this.fpc.createAnswer()), this.fpc.sdp = e
                }
                getUserIdBySsrc(e) {}
                getRawStats() {
                    return this.pc.getStats()
                }
                setVideoEncoderParameters(e) {}
                constructor(e, t, n, i) {
                    super(e, t, n, i), this.codecs = [], this.logger = new o.default("Connection(".concat(e, ")"));
                    let s = new u.default;
                    s.on("answer", e => this.pc.setRemoteDescription(e).catch(e => this.logger.error("Failed to set remote description (answer): ".concat(e)))), s.on("offer", e => {
                        this.pc.setRemoteDescription(e).then(() => this.pc.createAnswer()).then(e => this.fpc.setRemoteDescription(e)).catch(e => this.logger.error("Failed to set remote description (offer): ".concat(e)))
                    }), s.direction = null != this.input.stream ? h.Directions.SENDRECV : h.Directions.SENDONLY, this.fpc = s;
                    let a = new c.default(this.voiceBitrate);
                    a.on("addtrack", (e, t) => this.createOutput(E(e), t)), a.on("removetrack", (e, t) => this.destroyOutput(E(e), t)), a.once("connected", () => {
                        this.input.reset(), this.setConnectionState(f.ConnectionStates.CONNECTED), this.on(r.BaseConnectionEvent.Stats, this.handleStats), this.input.on(d.InputEvent.VoiceActivity, this.handleVoiceActivity)
                    }), a.on("connecting", () => this.setConnectionState(f.ConnectionStates.DTLS_CONNECTING)), a.on("checking", () => this.setConnectionState(f.ConnectionStates.ICE_CHECKING)), a.on("failed", () => this.setConnectionState(f.ConnectionStates.NO_ROUTE)), a.on("disconnected", () => this.setConnectionState(f.ConnectionStates.DISCONNECTED)), a.on("closed", () => this.setConnectionState(f.ConnectionStates.DISCONNECTED)), a.on("offer", e => {
                        let {
                            sdp: t
                        } = e, {
                            outboundStreams: n,
                            codecs: i,
                            audioSSRC: a,
                            videoSSRC: o,
                            rtxSSRC: l
                        } = (0, h.extractSDP)(t);
                        this.codecs = i;
                        let u = (0, h.getExtensions)(t);
                        s.outboundStreams = n, this.audioSSRC = a, s.extensions = u, (this.videoStreamParameters[0].ssrc !== o || this.videoStreamParameters[0].rtxSsrc !== l || !this.videoReady) && (this.videoStreamParameters[0].ssrc = o, this.videoStreamParameters[0].rtxSsrc = l, this.emit(r.BaseConnectionEvent.Video, this.ids.userId, this.input.getVideoStreamId(), this.audioSSRC, this.videoStreamParameters[0].ssrc, this.videoStreamParameters[0].rtxSsrc, this.videoStreamParameters), this.videoReady = !0)
                    }), a.once("offer", e => {
                        let {
                            sdp: t
                        } = e;
                        this.emit(r.BaseConnectionEvent.Connected, "webrtc", (0, h.truncateSDP)(t))
                    }), null != this.input.stream ? a.setStream(this.input.stream) : a.negotiationNeeded(), this.pc = a
                }
            }
        },
        820127: function(e, t, n) {
            "use strict";
            n.r(t), n.d(t, {
                default: function() {
                    return i
                }
            }), n("70102");
            var i, s = n("44170"),
                a = n("441822");
            i = class e extends s.EventEmitter {
                static async get(t, n) {
                    var i;
                    let s = {
                        ...t,
                        frameRate: 30
                    };
                    if ((null === (i = navigator.mediaDevices) || void 0 === i ? void 0 : i.getDisplayMedia) != null) return new e(await navigator.mediaDevices.getDisplayMedia({
                        audio: n,
                        video: s
                    }));
                    throw Error("UNKNOWN")
                }
                destroy() {
                    this.removeAllListeners(), (0, a.unregisterVideoStream)(this.streamId), this.stream.getTracks().forEach(e => e.stop())
                }
                reset() {
                    this.refreshSpeaking()
                }
                getStreamId() {
                    return this.streamId
                }
                refreshSpeaking() {
                    this.emit("speaking", this.stream.getAudioTracks().some(e => e.enabled))
                }
                constructor(e) {
                    super(), e.getVideoTracks().forEach(e => {
                        e.onended = () => {
                            this.emit("desktopsourceend")
                        }
                    }), this.id = e.getVideoTracks()[0].label, this.stream = e, this.streamId = (0, a.registerVideoStream)(e)
                }
            }
        },
        861001: function(e, t, n) {
            "use strict";
            n.r(t), n.d(t, {
                CAN_SET_DEVICES: function() {
                    return s
                },
                CAN_SET_OUTPUT_DEVICES: function() {
                    return a
                },
                getAudioInputDevices: function() {
                    return d
                },
                getAudioOutputDevices: function() {
                    return c
                },
                getVideoInputDevices: function() {
                    return h
                },
                getDevices: function() {
                    return p
                }
            }), n("860677"), n("424973");
            var i = n("353927");
            let s = null != navigator.mediaDevices && null != navigator.mediaDevices.enumerateDevices,
                a = s && "setSinkId" in HTMLAudioElement.prototype;

            function o(e) {
                return {
                    id: i.DEFAULT_DEVICE_ID,
                    type: e,
                    index: 0,
                    name: "Default"
                }
            }

            function r() {
                return [o(i.DeviceTypes.AUDIO_INPUT), o(i.DeviceTypes.AUDIO_OUTPUT), o(i.DeviceTypes.VIDEO_INPUT)]
            }

            function l(e, t) {
                return e.filter(e => e.type === t)
            }

            function u() {
                return s ? navigator.mediaDevices.enumerateDevices().then(e => {
                    let t = 0,
                        n = 0,
                        s = 0;
                    return e.filter(e => {
                        switch (e.kind) {
                            case i.DeviceTypes.AUDIO_INPUT:
                            case i.DeviceTypes.AUDIO_OUTPUT:
                            case i.DeviceTypes.VIDEO_INPUT:
                                return !0;
                            default:
                                return !1
                        }
                    }).map(e => {
                        let a;
                        switch (e.kind) {
                            case i.DeviceTypes.AUDIO_INPUT:
                                a = t++;
                                break;
                            case i.DeviceTypes.AUDIO_OUTPUT:
                                a = n++;
                                break;
                            case i.DeviceTypes.VIDEO_INPUT:
                            default:
                                a = s++
                        }
                        return {
                            id: e.deviceId,
                            type: e.kind,
                            index: a,
                            name: null != e.label && "" !== e.label ? e.label : 0 === a ? "Default" : "Device ".concat(a)
                        }
                    })
                }).then(e => (!a && (e = e.filter(e => e.type !== i.DeviceTypes.AUDIO_OUTPUT)).push(o(i.DeviceTypes.AUDIO_OUTPUT)), e)).catch(r) : new Promise(e => {
                    setImmediate(() => e(r()))
                })
            }
            async function d() {
                let e = await u();
                return l(e, i.DeviceTypes.AUDIO_INPUT)
            }
            async function c() {
                let e = await u();
                return l(e, i.DeviceTypes.AUDIO_OUTPUT)
            }
            async function h() {
                let e = await u();
                return l(e, i.DeviceTypes.VIDEO_INPUT)
            }
            async function p() {
                let e = await u();
                return [l(e, i.DeviceTypes.AUDIO_INPUT), l(e, i.DeviceTypes.AUDIO_OUTPUT), l(e, i.DeviceTypes.VIDEO_INPUT)]
            }
        },
        8479: function(e, t, n) {
            "use strict";
            n.r(t), n.d(t, {
                default: function() {
                    return i
                }
            }), n("424973"), n("70102"), n("222007");
            var i, s = n("44170"),
                a = n("383536"),
                o = n.n(a),
                r = n("588446");
            i = class extends s.EventEmitter {
                addStream(e, t, n) {
                    let i = !1;
                    !this.streams.some(e => e.ssrc === t) && this.streams.push({
                        ssrc: t,
                        cname: e,
                        type: "audio"
                    }), this.activeAudioSSRCs[e] !== t && (this.activeAudioSSRCs = {
                        ...this.activeAudioSSRCs,
                        [e]: t
                    }, i = !0), null != n && (n > 0 ? (!this.streams.some(e => e.ssrc === n) && this.streams.push({
                        ssrc: n,
                        cname: e,
                        type: "video"
                    }), this.activeVideoSSRCs[e] !== n && (this.activeVideoSSRCs = {
                        ...this.activeVideoSSRCs,
                        [e]: n
                    }, i = !0)) : null != this.activeVideoSSRCs[e] && (i = !0, this.activeVideoSSRCs = {
                        ...this.activeVideoSSRCs
                    }, delete this.activeVideoSSRCs[e])), i && this.negotiationNeeded()
                }
                removeStream(e) {
                    let t = !1;
                    null != this.activeAudioSSRCs[e] && (t = !0, this.activeAudioSSRCs = {
                        ...this.activeAudioSSRCs
                    }, delete this.activeAudioSSRCs[e]), null != this.activeVideoSSRCs[e] && (t = !0, this.activeVideoSSRCs = {
                        ...this.activeVideoSSRCs
                    }, delete this.activeVideoSSRCs[e]), t && this.negotiationNeeded()
                }
                get sdp() {
                    if (null == this._sdp) throw Error("sdp is not set");
                    return this._sdp
                }
                set sdp(e) {
                    if (!(0, r.validateSdp)(e)) throw Error("Incorrect SDP received from rtc-worker: ".concat(e));
                    this._sdp = e, this.createAnswer(), this.connected = !0, this._negotiationNeeded && this.negotiationNeeded()
                }
                negotiationNeeded() {
                    if (this.negotiating) {
                        this._negotiationNeeded = !0;
                        return
                    }
                    null != this._sdp ? (this.negotiating = !0, this._negotiationNeeded = !1, this.generateSessionDescription("offer")) : this._negotiationNeeded = !0
                }
                setRemoteDescription(e) {
                    return this.negotiating = !1, this._negotiationNeeded && this.negotiationNeeded(), Promise.resolve()
                }
                createAnswer() {
                    return this.generateSessionDescription("answer")
                }
                getSSRCs(e) {
                    let t = this.streams.map((e, t) => {
                        let {
                            cname: n,
                            ssrc: i,
                            type: s
                        } = e, a = this.activeAudioSSRCs[n], o = this.activeVideoSSRCs[n], l = "".concat(s, "_inbound_").concat(t);
                        return [i, n, s, a === i || o === i ? this.direction : r.Directions.INACTIVE, l]
                    });
                    if ("Firefox" !== o.name) return this.connected ? t : [];
                    let n = this.outboundStreams.map((e, t) => [0, "outbound", e.type, (0, r.getDirection)(e.direction), "".concat(e.type, "_outbound_").concat(t)]);
                    if ("answer" !== e) return n.concat(t);
                    {
                        let e = n.length - t.length,
                            i = n.slice(0, e).concat(t).slice(0, n.length);
                        return i.map((e, t) => {
                            let [n, i, s, a, o] = e;
                            return [n, i, s, (0, r.getDirection)(this.outboundStreams[t].direction), this.outboundStreams[t].mid]
                        })
                    }
                }
                generateSessionDescription(e) {
                    let t = this.audioCodec,
                        n = this.audioPayloadType,
                        i = this.videoCodec,
                        s = this.videoPayloadType,
                        a = this.rtxPayloadType,
                        o = this.sdp;
                    if (null == t || null == n || null == i || null == s || null == a || null == o || null == this.direction) throw Error("Invalid payload: audioCodec: ".concat(t, ", audioPayloadType: ").concat(null == n ? "null" : n, ", videoCodec: ").concat(i, ", videoCodecPayloadType: ").concat(null == s ? "null" : s, ", rtxPayloadType: ").concat(null == a ? "null" : a, ", sdp: ").concat(o));
                    let l = (0, r.generateSessionDescription)({
                        type: e,
                        baseSDP: o,
                        direction: this.direction,
                        audioCodec: t,
                        audioPayloadType: n,
                        audioBitRate: 40,
                        videoCodec: i,
                        videoPayloadType: s,
                        videoBitRate: 2500,
                        rtxPayloadType: a,
                        ssrcs: this.getSSRCs(e),
                        extensions: this.extensions
                    });
                    return this.emit(e, l), Promise.resolve(l)
                }
                constructor(...e) {
                    super(...e), this.audioCodec = null, this.audioPayloadType = null, this.videoCodec = null, this.videoPayloadType = null, this.rtxPayloadType = null, this.direction = null, this.outboundStreams = [], this.extensions = [], this.streams = [], this.activeAudioSSRCs = {}, this.activeVideoSSRCs = {}, this._sdp = null, this.connected = !1, this.negotiating = !1, this._negotiationNeeded = !1
                }
            }
        },
        201617: function(e, t, n) {
            "use strict";
            var i;
            n.r(t), n.d(t, {
                default: function() {
                    return i
                }
            }), i = class {
                acquire(e) {
                    return navigator.mediaDevices.getUserMedia(e)
                }
                release(e) {
                    e.getTracks().forEach(e => {
                        e.onended = function() {}, e.stop()
                    })
                }
            }
        },
        62684: function(e, t, n) {
            "use strict";
            n.r(t), n.d(t, {
                InputEvent: function() {
                    return InputEvent
                },
                default: function() {
                    return i
                }
            });
            var InputEvent, InputEvent, i, s = n("595275"),
                a = n("657869"),
                o = n("555013");
            (InputEvent = InputEvent || (InputEvent = {})).Stream = "stream", InputEvent.Video = "video", InputEvent.Mute = "mute", InputEvent.VoiceActivity = "voiceactivity", InputEvent.DesktopSourceEnd = "desktopsourceend", InputEvent.Speaking = "speaking", InputEvent.AudioPermission = "audio-permission", InputEvent.VideoPermission = "video-permission", InputEvent.AddVideoTrack = "add-video-track", i = class extends s.default {
                destroy() {
                    this.removeAllListeners(), this.destroyStreams()
                }
                destroyStreams() {
                    var e;
                    this.audio.destroy(), this.video.destroy(), null === (e = this.desktop) || void 0 === e || e.destroy()
                }
                setDesktop(e) {
                    this.destroyStreams(), null == e || e.addListener("desktopsourceend", this.handleDesktopSourceEnd), null == e || e.addListener("speaking", this.handleSpeaking), this.desktop = e, this.mergeStreams()
                }
                reset() {
                    var e;
                    this.audio.reset(), null === (e = this.desktop) || void 0 === e || e.reset()
                }
                getVideoStream() {
                    return null != this.desktop ? this.desktop.stream : this.video.stream
                }
                getVideoStreamId() {
                    return null != this.desktop ? this.desktop.getStreamId() : this.video.getStreamId()
                }
                enableAudioInput() {
                    this.audio.enable()
                }
                setAudioMode(e, t) {
                    this.audio.setMode(e, t)
                }
                setMute(e) {
                    this.audio.mute = e, this.emit("mute", e)
                }
                setEchoCancellation(e) {
                    this.audio.echoCancellation = e
                }
                setNoiseSuppression(e) {
                    this.audio.noiseSuppression = e
                }
                setNoiseCancellation(e) {
                    this.audio.noiseCancellation = e
                }
                setAutomaticGainControl(e) {
                    this.audio.automaticGainControl = e
                }
                setPTTActive(e) {
                    this.audio.setPTTActive(e)
                }
                setAudioSource(e) {
                    this.audio.setSource(e)
                }
                setVideoSource(e) {
                    this.video.setSource(e)
                }
                mute() {
                    return this.audio.mute
                }
                resumeAudio() {
                    this.audio.resume()
                }
                getAudioState() {
                    return this.audio.state
                }
                hasDesktopSource() {
                    return null != this.desktop
                }
                constructor(e) {
                    super(), this.video = new o.default, this.desktop = null, this.mergeStreams = () => {
                        var e, t, n;
                        let i = new MediaStream;
                        return null != this.desktop ? (null === (e = this.desktop.stream) || void 0 === e || e.getTracks().forEach(e => i.addTrack(e)), this.desktop.refreshSpeaking()) : (null === (t = this.audio.stream) || void 0 === t || t.getAudioTracks().forEach(e => i.addTrack(e)), null === (n = this.video.stream) || void 0 === n || n.getVideoTracks().forEach(e => i.addTrack(e))), this.stream = i, this.emit("stream", i), this.emit("video", this.getVideoStreamId()), i
                    }, this.handleVoiceActivity = e => {
                        this.emit("voiceactivity", e)
                    }, this.handleDesktopSourceEnd = () => {
                        this.emit("desktopsourceend")
                    }, this.handleSpeaking = e => {
                        this.emit("speaking", e)
                    }, this.handleAudioPermission = e => {
                        this.emit("audio-permission", e)
                    }, this.handleVideoPermission = e => {
                        this.emit("video-permission", e)
                    }, this.audio = new a.default(e), this.audio.addListener("voiceactivity", this.handleVoiceActivity), this.audio.addListener("speaking", this.handleSpeaking), this.audio.addListener("stream", this.mergeStreams), this.audio.addListener("permission", this.handleAudioPermission), this.video.addListener("stream", this.mergeStreams), this.video.addListener("permission", this.handleVideoPermission), this.video.addListener("add-video-track", e => this.emit("add-video-track", e))
                }
            }
        },
        581785: function(e, t, n) {
            "use strict";
            let i;

            function s() {
                return null != i ? i : i = (async () => {
                    let {
                        default: e
                    } = await n.el("702084").then(n.t.bind(n, "702084", 23)), t = new e({
                        params: {
                            logProcessStats: !1,
                            useSharedArrayBuffer: !1,
                            debugLogs: !1,
                            bufferOverflowMS: 200,
                            models: {
                                model8: "https://cdn.discordapp.com/assets/krisp_browser_models/v1.0.11_1/model_8.kw",
                                model16: "https://cdn.discordapp.com/assets/krisp_browser_models/v1.0.11_1/model_16.kw",
                                model32: "https://cdn.discordapp.com/assets/krisp_browser_models/v1.0.11_1/model_32.kw"
                            }
                        }
                    });
                    return await t.init(), t
                })()
            }
            n.r(t), n.d(t, {
                getKrispSDK: function() {
                    return s
                }
            })
        },
        13379: function(e, t, n) {
            "use strict";
            n.r(t), n.d(t, {
                default: function() {
                    return i
                }
            }), n("222007");
            var i, s = n("44170"),
                a = n("657869"),
                o = n("324304"),
                r = n("353927");
            let l = {
                voiceActivityDetection: !0,
                offerToReceiveAudio: !0,
                offerToReceiveVideo: !1,
                iceRestart: !1
            };
            i = class extends s.EventEmitter {
                stop() {
                    for (let e of (this.pc1.close(), this.pc2.close(), this.input.destroy(), Object.keys(this.outputs))) this.destroyOutput(e)
                }
                setAudioSource(e) {
                    this.input.setSource(e)
                }
                setAudioSink(e) {
                    for (let t of (this.sinkId = e, Object.keys(this.outputs))) this.outputs[t].setSinkId(e)
                }
                setNoiseCancellation(e) {
                    this.input.noiseCancellation = e
                }
                createOutput(e, t) {
                    let n = this.outputs[e];
                    null == n && ((n = new o.default(this.userId, this.audioContext)).mute = !1, n.volume = 100, n.setSpeakingFlags(r.SpeakingFlags.VOICE), n.setSinkId(this.sinkId), this.outputs[e] = n), n.addTrack(t), n.play()
                }
                destroyOutput(e, t) {
                    let n = this.outputs[e];
                    null != n && (null == t || 0 === n.removeTrack(t)) && (n.destroy(), delete this.outputs[e])
                }
                handshake() {
                    let e = e => {
                        let t = e.sdp.split("\n");
                        for (let e = 0; e < t.length; e++) {
                            let n = t[e];
                            if (/^a=mid:/.test(n)) break
                        }
                        return e.sdp = t.join("\n"), e
                    };
                    this.pc1.createOffer(l).then(t => {
                        this.pc1.setLocalDescription(e(t)).then(() => {
                            this.pc2.setRemoteDescription(t).then(() => {
                                this.pc2.createAnswer().then(e => {
                                    this.pc2.setLocalDescription(e).then(() => {
                                        this.pc1.setRemoteDescription(e)
                                    })
                                })
                            })
                        })
                    })
                }
                constructor(e, t, n, i = "") {
                    super(), this.senders = [], this.outputs = {}, this.handleStream = () => {
                        let e = this.input.getDelayedStream();
                        this.senders.forEach(e => this.pc1.removeTrack(e)), this.senders = [...e.getAudioTracks().map(t => this.pc1.addTrack(t, e))], this.handshake()
                    }, this.handleTrack = e => {
                        e.streams[0].getTracks().forEach(e => {
                            this.createOutput(e.id, e), e.onmute = () => {
                                this.destroyOutput(e.id, e)
                            }
                        })
                    }, this.userId = i, this.sinkId = n, this.pc1 = new RTCPeerConnection, this.pc1.onicecandidate = e => {
                        null != e.candidate && this.pc2.addIceCandidate(e.candidate)
                    }, this.pc2 = new RTCPeerConnection, this.pc2.onicecandidate = e => {
                        null != e.candidate && this.pc1.addIceCandidate(e.candidate)
                    }, this.pc2.ontrack = this.handleTrack, this.input = new a.default(e), this.input.setSource(t), this.input.on("stream", this.handleStream), this.input.enable(), this.audioContext = e
                }
            }
        },
        324304: function(e, t, n) {
            "use strict";
            n.r(t), n.d(t, {
                OutputEvent: function() {
                    return s
                },
                default: function() {
                    return a
                }
            });
            var i, s, a, o = n("811022"),
                r = n("595275"),
                l = n("861001"),
                u = n("441822"),
                d = n("353927");
            let c = new o.default("Output");
            (i = s || (s = {})).InteractionRequired = "interactionrequired", i.Speaking = "speaking", i.Video = "video", a = class extends r.default {
                play() {
                    var e;
                    null === (e = this.audioElement) || void 0 === e || e.play()
                }
                destroy() {
                    var e;
                    null === (e = this.audioElement) || void 0 === e || e.pause(), null != this.videoStreamId && (0, u.unregisterVideoStream)(this.videoStreamId), null != this.streamSourceNode && (this.streamSourceNode.disconnect(), this.streamSourceNode = null), null != this.levelNode && (this.levelNode.disconnect(), this.levelNode.port.postMessage("close"), this.levelNode = null), this.setSpeakingFlags(d.SpeakingFlags.NONE), this.removeAllListeners()
                }
                addTrack(e) {
                    if (this.stream.getTracks().includes(e)) return this.stream.getTracks().length;
                    if (this.stream.addTrack(e), null == this.audioElement) {
                        let e = document.createElement("audio");
                        e.srcObject = this.stream;
                        let t = e.play();
                        null != t && t.catch(() => this.emit("interactionrequired", !0)), this.audioElement = e, this.updateAudioElement()
                    }
                    if (null == this.levelNode && this.stream.getAudioTracks().length > 0) {
                        this.streamSourceNode = this.audioContext.createMediaStreamSource(this.stream);
                        try {
                            this.levelNode = new AudioWorkletNode(this.audioContext, "level-processor"), this.levelNode.port.onmessage = e => {
                                this.emit("speaking", e.data)
                            }, null != this.streamSourceNode && this.streamSourceNode.connect(this.levelNode)
                        } catch (e) {
                            c.warn("Output#Failed to setup speaking indicator: ".concat(e))
                        }
                    }
                    if ("video" === e.kind) {
                        null != this.videoStreamId && (0, u.unregisterVideoStream)(this.videoStreamId);
                        let t = this.stream.getVideoTracks();
                        t.forEach(t => {
                            e !== t && (t.discordIsTearingDown = !0, this.stream.removeTrack(t))
                        }), this.videoStreamId = (0, u.registerVideoStream)(this.stream), this.emit("video", this.videoStreamId)
                    }
                    if ("audio" === e.kind) {
                        let t = this.stream.getAudioTracks();
                        t.forEach(t => {
                            e !== t && (t.discordIsTearingDown = !0, this.stream.removeTrack(t))
                        })
                    }
                    return this.stream.getTracks().length
                }
                removeTrack(e) {
                    return this.stream.removeTrack(e), "video" === e.kind && (null != this.videoStreamId && (0, u.unregisterVideoStream)(this.videoStreamId), this.emit("video", null)), this.stream.getTracks().length
                }
                setSinkId(e) {
                    this.sinkId = e, this.updateAudioElement()
                }
                get mute() {
                    return this._mute
                }
                set mute(e) {
                    this._mute = e || !1, this.updateAudioElement()
                }
                get priority() {
                    return (this._speakingFlags & d.SpeakingFlags.PRIORITY) === d.SpeakingFlags.PRIORITY
                }
                get volume() {
                    return this._volume
                }
                set volume(e) {
                    this._volume = Math.max(0, Math.min(Math.round(e), d.DEFAULT_VOLUME)), this.updateAudioElement()
                }
                get speakingFlags() {
                    return this._speakingFlags
                }
                setSpeakingFlags(e) {
                    this._speakingFlags !== e && (this._speakingFlags = e, this.updateAudioElement())
                }
                updateAudioElement() {
                    let e = this.audioElement;
                    if (null != e) {
                        e.muted = this._mute, e.volume = this._volume / 100;
                        let t = this.sinkId;
                        null != t && l.CAN_SET_OUTPUT_DEVICES && e.setSinkId(t)
                    }
                }
                constructor(e, t) {
                    super(), this._speakingFlags = d.SpeakingFlags.NONE, this._mute = !1, this._volume = d.DEFAULT_VOLUME, this.sinkId = null, this.audioElement = null, this.stream = new MediaStream, this.videoStreamId = null, this.levelNode = null, this.streamSourceNode = null, this.id = e, this.audioContext = t
                }
            }
        },
        760014: function(e, t, n) {
            "use strict";
            n.r(t), n.d(t, {
                default: function() {
                    return i
                }
            }), n("222007"), n("70102");
            var i, s = n("44170"),
                a = n("811022"),
                o = n("53452");
            let r = new a.default("PeerConnection");
            i = class extends s.EventEmitter {
                setBitRate(e) {
                    this.bitrate !== e && (this.bitrate = e, this.negotiationNeeded())
                }
                close() {
                    r.info("Close RTCPeerConnection"), "closed" !== this.signalingState && this.pc.close(), this.removeAllListeners()
                }
                get peerConnectionState() {
                    return this.pc.connectionState
                }
                get iceGatheringState() {
                    return this.pc.iceGatheringState
                }
                get iceConnectionState() {
                    return this.pc.iceConnectionState
                }
                get signalingState() {
                    return this.pc.signalingState
                }
                get connected() {
                    return null != this.pc && /connected|completed/.test(this.pc.iceConnectionState)
                }
                setStream(e) {
                    let t = arguments.length > 1 && void 0 !== arguments[1] && arguments[1],
                        n = this.pc,
                        i = "closed" === this.iceConnectionState,
                        s = !1;
                    null != this.stream && !i && (this.senders.forEach(e => n.removeTrack(e)), s = !0), this.stream = e, this.senders = [], null != e && !i && (this.senders = [...e.getAudioTracks().map(t => n.addTrack(t, e)), ...e.getVideoTracks().map(t => n.addTrack(t, e))], s = !0), s && !t && this.negotiationNeeded()
                }
                createOffer() {
                    let e = this.pc;
                    return e.createOffer(this.makeOfferAnswerOptions()).then(t => e.setLocalDescription(this.mungeLocalDescription(t))).then(() => {
                        let t = e.localDescription;
                        if (null == t) throw Error("localDescription is null");
                        return this.emit("offer", t), t
                    }).catch(t => {
                        if ("have-remote-offer" === e.signalingState) return r.error(t), this.createOffer();
                        throw t
                    })
                }
                createAnswer() {
                    let e = this.pc;
                    return e.createAnswer(this.makeOfferAnswerOptions()).then(t => e.setLocalDescription(this.mungeLocalDescription(t))).then(() => {
                        let t = e.localDescription;
                        if (null == t) throw Error("localDescription is null");
                        return this.emit("answer", t), t
                    }).catch(t => {
                        throw r.warn("PeerConnection#createAnswer: Attempted to set local description in state: ".concat(e.signalingState)), t
                    })
                }
                negotiationNeeded() {
                    if (this.negotiating) {
                        this._negotiationNeeded = !0;
                        return
                    }
                    this.negotiating = !0, this._negotiationNeeded = !1, this.createOffer()
                }
                setRemoteDescription(e) {
                    return this.pc.setRemoteDescription(e)
                }
                getStats() {
                    return this.pc.getStats()
                }
                makeOfferAnswerOptions() {
                    return {
                        offerToReceiveAudio: !0,
                        offerToReceiveVideo: o.BROWSER_SUPPORTS_VIDEO,
                        iceRestart: !1
                    }
                }
                mungeLocalDescription(e) {
                    let t = e.sdp.split("\n");
                    for (let e = 0; e < t.length; e++) {
                        let n = t[e];
                        if (/^a=mid:/.test(n)) {
                            null != this.bitrate && t.splice(e + 1, 0, "b=AS:".concat(Math.floor(this.bitrate / 1e3)));
                            break
                        }
                    }
                    return e.sdp = t.join("\n"), e
                }
                emitTrack(e, t) {
                    !/^default/.test(t.id) && (t.onended = () => {
                        this.emit("removetrack", e, t)
                    }, this.emit("addtrack", e, t))
                }
                constructor(e) {
                    super(), this.stream = null, this.senders = [], this.negotiating = !1, this._negotiationNeeded = !1, this.handlePeerConnectionStateChange = () => {
                        let e = this.peerConnectionState;
                        r.info("peerConnectionState =>", e), "connecting" === e ? "connected" === this.iceConnectionState ? this.emit(e) : this.emit(this.iceConnectionState) : this.emit(e)
                    }, this.handleIceConnectionStateChange = () => {
                        let e = this.iceConnectionState;
                        r.info("iceConnectionState =>", e), "completed" === e && (e = "connected"), this.emit(e)
                    }, this.handleSignalingStateChange = () => {
                        r.info("signalingState => ".concat(this.signalingState, ", negotiation needed: ").concat(this._negotiationNeeded.toString())), "stable" === this.signalingState && (this.negotiating = !1, this._negotiationNeeded && this.negotiationNeeded())
                    }, this.handleIceGatheringStateChange = () => {
                        r.info("iceGatheringState =>", this.iceGatheringState)
                    }, this.handleTrack = e => {
                        this.emitTrack(e.streams[0].id, e.track)
                    }, this.bitrate = e;
                    let t = this.pc = new RTCPeerConnection({
                        sdpSemantics: "plan-b"
                    });
                    o.BROWSER_SUPPORTS_CONNECTION_STATE ? (t.onconnectionstatechange = this.handlePeerConnectionStateChange, t.oniceconnectionstatechange = this.handlePeerConnectionStateChange) : t.oniceconnectionstatechange = this.handleIceConnectionStateChange, t.onsignalingstatechange = this.handleSignalingStateChange, t.onicegatheringstatechange = this.handleIceGatheringStateChange, t.ontrack = this.handleTrack.bind(this), r.info("Constructed RTCPeerConnection")
                }
            }
        },
        588446: function(e, t, n) {
            "use strict";
            n.r(t), n.d(t, {
                Directions: function() {
                    return s
                },
                getDirection: function() {
                    return g
                },
                generateSessionDescription: function() {
                    return C
                },
                generateUnifiedSessionDescription: function() {
                    return T
                },
                extractSDP: function() {
                    return A
                },
                truncateSDP: function() {
                    return N
                },
                validateSdp: function() {
                    return D
                },
                getExtensions: function() {
                    return O
                }
            }), n("222007"), n("70102"), n("424973"), n("808653"), n("700225");
            var i, s, a, o, r = n("773179"),
                l = n.n(r),
                u = n("383536"),
                d = n.n(u),
                c = n("21794"),
                h = n("811022"),
                p = n("353927"),
                f = n("53452");
            let m = new h.default("SDP");
            (a = i || (i = {})).AUDIO = "a", a.VIDEO = "v", (o = s || (s = {})).SENDRECV = "sendrecv", o.SENDONLY = "sendonly", o.RECVONLY = "recvonly", o.INACTIVE = "inactive";
            let E = "UDP/TLS/RTP/SAVPF";

            function g(e) {
                switch (e) {
                    case "recvonly":
                        return "sendonly";
                    case "sendonly":
                        return "recvonly";
                    case "sendrecv":
                        return "sendrecv";
                    default:
                        return "inactive"
                }
            }

            function S(e, t, n) {
                let i = "".concat(e, "-").concat(t),
                    s = "".concat(n).concat(i);
                return [{
                    attribute: "cname",
                    id: t,
                    value: i
                }, {
                    attribute: "msid",
                    id: t,
                    value: "".concat(i, " ").concat(s)
                }, {
                    attribute: "mslabel",
                    id: t,
                    value: i
                }, {
                    attribute: "label",
                    id: t,
                    value: s
                }]
            }

            function _(e) {
                return c.write({
                    version: 0,
                    timing: {
                        start: 0,
                        stop: 0
                    },
                    origin: {
                        address: "127.0.0.1",
                        ipVer: 4,
                        netType: "IN",
                        sessionId: "1420070400000",
                        sessionVersion: 0,
                        username: "-"
                    },
                    name: "-",
                    msidSemantic: {
                        semantic: "WMS",
                        token: "*"
                    },
                    groups: [{
                        type: "BUNDLE",
                        mids: e.filter(e => null != e.mid).map(e => e.mid).join(" ")
                    }],
                    media: e
                })
            }

            function v(e) {
                let {
                    mid: t,
                    type: n,
                    setup: i,
                    direction: s,
                    baseSDP: a,
                    codec: o,
                    payload: r,
                    bitrate: u,
                    ssrcs: h,
                    extensions: m,
                    rtxPayload: g,
                    sendingVideo: S
                } = e;
                if ("inactive" === s && !f.BROWSER_SUPPORTS_UNIFIED_PLAN) return {
                    connection: {
                        ip: "0.0.0.0",
                        version: 4
                    },
                    direction: "inactive",
                    fmtp: [],
                    payloads: r,
                    port: 0,
                    protocol: E,
                    rtp: [{
                        codec: "NULL",
                        payload: r,
                        rate: 0
                    }],
                    mid: void 0,
                    type: n
                };
                let {
                    media: [_]
                } = c.parse(a);
                if (_.type = n, _.protocol = E, _.payloads = r, _.setup = i, _.mid = t, _.rtcpMux = "rtcp-mux", _.direction = s, _.ssrcs = h, h.length > 0 && (null != g && (_.ssrcGroups = l(h).chunk(4).map(e => {
                        let t = e[0].id;
                        return {
                            semantics: "FID",
                            ssrcs: "".concat(t, " ").concat(t + 1)
                        }
                    }).value(), _.ssrcs = l(h).chunk(4).map(e => {
                        let t = e.map(e => (e = {
                            ...e
                        }, e.id += 1, e));
                        return [...e, ...t]
                    }).flatten().value()), f.BROWSER_SUPPORTS_UNIFIED_PLAN || "Firefox" === d.name)) {
                    let e = h.find(e => "msid" === e.attribute);
                    if (null == e) throw Error("msid missing");
                    _.msid = e.value, _.ssrcs = _.ssrcs.filter(e => "cname" === e.attribute)
                }
                switch (n) {
                    case "audio":
                        "Firefox" === d.name ? _.ext = m.filter(e => "urn:ietf:params:rtp-hdrext:ssrc-audio-level" === e.uri) : (_.ext = m.filter(e => "urn:ietf:params:rtp-hdrext:ssrc-audio-level" === e.uri || "http://www.ietf.org/id/draft-holmer-rmcat-transport-wide-cc-extensions-01" === e.uri), _.rtcpFb = [{
                            type: "transport-cc",
                            payload: r
                        }]), _.rtp.push({
                            codec: o,
                            encoding: 2,
                            payload: r,
                            rate: 48e3
                        }), o === p.Codecs.OPUS && _.fmtp.push({
                            config: "minptime=10;useinbandfec=1;usedtx=".concat(S ? "0" : "1"),
                            payload: r
                        }), _.maxptime = 60;
                        break;
                    case "video":
                        _.ext = m.filter(e => "urn:ietf:params:rtp-hdrext:toffset" === e.uri || "http://www.webrtc.org/experiments/rtp-hdrext/abs-send-time" === e.uri || "urn:3gpp:video-orientation" === e.uri || "http://www.ietf.org/id/draft-holmer-rmcat-transport-wide-cc-extensions-01" === e.uri || "http://www.webrtc.org/experiments/rtp-hdrext/playout-delay" === e.uri), _.rtp.push({
                            codec: o,
                            payload: r,
                            rate: 9e4
                        });
                        let v = "x-google-max-bitrate=".concat(u);
                        o === p.Codecs.H264 && (v += ";level-asymmetry-allowed=1;packetization-mode=1;profile-level-id=42e01f"), _.fmtp.push({
                            config: v,
                            payload: r
                        }), _.rtcpFb = [{
                            type: "ccm",
                            subtype: "fir",
                            payload: r
                        }, {
                            type: "nack",
                            payload: r
                        }, {
                            type: "nack",
                            subtype: "pli",
                            payload: r
                        }, {
                            type: "goog-remb",
                            payload: r
                        }, {
                            type: "transport-cc",
                            payload: r
                        }], null != g && (_.rtp.push({
                            codec: "rtx",
                            payload: g,
                            rate: 9e4
                        }), _.fmtp.push({
                            config: "apt=".concat(r),
                            payload: g
                        }), _.payloads = "".concat(_.payloads, " ").concat(g))
                }
                return _
            }

            function C(e) {
                let {
                    type: t,
                    baseSDP: n,
                    direction: i,
                    audioCodec: s,
                    audioPayloadType: a,
                    audioBitRate: o,
                    videoCodec: r,
                    videoPayloadType: u,
                    videoBitRate: c,
                    rtxPayloadType: h,
                    ssrcs: p,
                    extensions: f
                } = e, E = [];
                if (m.info("generateSessionDescription: ".concat(JSON.stringify(p))), "Firefox" === d.name) {
                    let e = "answer" === t ? "passive" : "active";
                    p.forEach(t => {
                        let [i, l, d, p, m] = t;
                        if ("video" !== d || 0 !== u && 0 !== h) E.push(v({
                            mid: m,
                            type: d,
                            setup: e,
                            direction: p,
                            baseSDP: n,
                            codec: "audio" === d ? s : r,
                            payload: "audio" === d ? a : u,
                            bitrate: "audio" === d ? o : c,
                            ssrcs: S(l, i, "audio" === d ? "a" : "v"),
                            extensions: f
                        }))
                    })
                } else {
                    let e = "answer" === t ? "passive" : "actpass",
                        d = l(p).filter(e => {
                            let [t, n, i, s, a] = e;
                            return "inactive" !== s && "audio" === i
                        }).map(e => {
                            let [t, n] = e;
                            return S(n, t, "a")
                        }).value();
                    if (E.push(v({
                            mid: "audio",
                            type: "audio",
                            setup: e,
                            direction: i,
                            baseSDP: n,
                            codec: s,
                            payload: a,
                            bitrate: o,
                            ssrcs: l.flatten(d),
                            extensions: f
                        })), u > 0) {
                        let t = l(p).filter(e => {
                            let [t, n, i, s, a] = e;
                            return "inactive" !== s && "video" === i
                        }).map(e => {
                            let [t, n] = e;
                            return S(n, t, "v")
                        }).value();
                        E.push(v({
                            mid: "video",
                            type: "video",
                            setup: e,
                            direction: i,
                            baseSDP: n,
                            codec: r,
                            payload: u,
                            bitrate: c,
                            ssrcs: l.flatten(t),
                            extensions: f,
                            rtxPayload: h
                        }))
                    }
                }
                let g = _(E);
                return new RTCSessionDescription({
                    type: t,
                    sdp: g
                })
            }

            function T(e) {
                let {
                    type: t,
                    baseSDP: n,
                    audioCodec: i,
                    audioPayloadType: s,
                    audioBitRate: a,
                    videoCodec: o,
                    videoPayloadType: r,
                    videoBitRate: l,
                    sendingVideo: u,
                    rtxPayloadType: d,
                    ssrcs: c,
                    extensions: h
                } = e, p = [], f = "answer" === t ? "passive" : "actpass";
                c.forEach(e => {
                    let t, {
                        ssrc: c,
                        cname: m,
                        type: E,
                        direction: g,
                        mid: _
                    } = e;
                    "" !== m ? t = S(m, c, "audio" === E ? "a" : "v") : (t = [], "sendonly" === g ? g = "inactive" : "sendrecv" === g && (g = "recvonly"));
                    p.push(v({
                        mid: _,
                        type: E,
                        setup: f,
                        direction: g,
                        baseSDP: n,
                        codec: "audio" === E ? i : o,
                        payload: "audio" === E ? s : r,
                        bitrate: "audio" === E ? a : l,
                        ssrcs: t,
                        extensions: h,
                        rtxPayload: "audio" === E ? null : d,
                        sendingVideo: u
                    }))
                });
                let m = _(p);
                return new RTCSessionDescription({
                    type: t,
                    sdp: m
                })
            }

            function I(e, t, n, i, s) {
                let a = l.find(e, {
                    codec: i
                });
                if (null == a) return null;
                let o = l.find(t, e => RegExp("^apt=".concat(a.payload)).test(e.config)),
                    r = null;
                if (null != o) {
                    let t = l.find(e, {
                        codec: p.Codecs.RTX,
                        payload: o.payload
                    });
                    null != t && (r = t.payload)
                }
                return {
                    type: n,
                    name: i,
                    priority: s + 1,
                    payloadType: a.payload,
                    rtxPayloadType: r
                }
            }

            function A(e) {
                let t = c.parse(e).media.reduce((e, t) => {
                    let n, {
                        type: i,
                        rtp: s,
                        ssrcs: a,
                        fmtp: o,
                        direction: r,
                        mid: u
                    } = t;
                    switch (e.outboundStreams.push({
                            type: i,
                            direction: r,
                            mid: u
                        }), i) {
                        case "audio":
                            [p.Codecs.OPUS].forEach((t, n) => {
                                let a = I(s, o, i, t, n);
                                null != a && e.codecs.push(a)
                            }), "sendrecv" === r && null != (n = l.find(a, {
                                attribute: "cname"
                            })) && (e.audioSSRC = n.id);
                            break;
                        case "video":
                            [p.Codecs.H264, p.Codecs.VP8, p.Codecs.VP9].forEach((t, n) => {
                                let a = I(s, o, i, t, n);
                                null != a && e.codecs.push(a)
                            }), "sendrecv" === r && (null != (n = l.find(a, {
                                attribute: "cname"
                            })) && (e.videoSSRC = n.id), null != (n = l.findLast(a, {
                                attribute: "cname"
                            })) && (n.id === e.videoSSRC && m.warn("Unable to find a unique rtx SSRC!"), e.rtxSSRC = n.id))
                    }
                    return e
                }, {
                    outboundStreams: [],
                    codecs: [],
                    audioSSRC: 0,
                    videoSSRC: 0,
                    rtxSSRC: 0
                });
                return t.codecs = l.uniqWith(t.codecs, l.isEqual), t
            }

            function N(e) {
                var t;
                let {
                    codecs: n
                } = A(e), i = n.find(e => e.name === p.Codecs.VP8), s = RegExp("^a=ice|a=extmap|a=fingerprint|opus|VP8|".concat(null !== (t = null == i ? void 0 : i.rtxPayloadType) && void 0 !== t ? t : 0, " rtx"), "i");
                return {
                    sdp: l(e).split(/\r\n/).filter(e => s.test(e)).uniq().join("\n"),
                    codecs: n
                }
            }

            function D(e) {
                if (!e.includes("a=fingerprint")) return m.error("Remote SDP does not include fingerprint!"), !1;
                if (!e.includes("a=ice-ufrag")) return m.error("Remote SDP does not include ICE user name!"), !1;
                if (!e.includes("a=ice-pwd")) return m.error("Remote SDP does not include ICE password!"), !1;
                if (!e.includes("a=candidate")) return m.error("Remote SDP does not include ICE candidate!"), !1;
                if (!e.includes("c=")) return m.error("Remote SDP does not include c-line!"), !1;
                let t = e.split("\n").filter(e => e.startsWith("c=")).join().trim();
                return !(t.split(" ").length < 3) || (m.error("Incorrect c-line: ".concat(t)), !1)
            }

            function O(e) {
                return l(e).split(/\r\n/).filter(e => e.startsWith("a=extmap:")).uniq().map(e => {
                    let t = e.split(" "),
                        n = t[0].split("/");
                    return {
                        value: parseInt(n[0].substr(9), 10),
                        uri: t[1]
                    }
                }).value()
            }
        },
        779791: function(e, t, n) {
            "use strict";
            n.r(t), n.d(t, {
                default: function() {
                    return s
                }
            }), n("424973"), n("70102"), n("222007");
            var i, s, a = n("383536"),
                o = n.n(a),
                r = n("811022"),
                l = n("773364"),
                u = n("566106"),
                d = n("62684"),
                c = n("588446"),
                h = n("353927"),
                p = n("53452");
            let f = null === (i = o.name) || void 0 === i ? void 0 : i.toLowerCase().includes("firefox");

            function m(e, t) {
                e.sender.replaceTrack(t), e.direction = null != t ? "sendrecv" : "recvonly"
            }
            s = class extends u.default {
                destroy() {
                    super.destroy(), "closed" !== this.signalingState && this.pc.close()
                }
                setCodecs(e, t, n) {
                    var i, s, a;
                    let o;
                    (this.audioCodec !== e || this.videoCodec !== t) && (o = this.codecs.find(t => t.name === e), this.audioCodec = e, this.audioPayloadType = null !== (i = null == o ? void 0 : o.payloadType) && void 0 !== i ? i : 0, o = this.codecs.find(e => e.name === t), this.videoCodec = t, this.videoPayloadType = null !== (s = null == o ? void 0 : o.payloadType) && void 0 !== s ? s : 0, this.rtxPayloadType = null !== (a = null == o ? void 0 : o.rtxPayloadType) && void 0 !== a ? a : 0, this.logger.info("Renegotiating: Codecs changed"), this.handleNegotiationNeeded())
                }
                setStream(e) {
                    let t = "closed" === this.iceConnectionState;
                    null != e && !t && (m(this.audioTransceiver, e.getAudioTracks()[0]), this.videoSupported && m(this.videoTransceiver, e.getVideoTracks()[0])), this.logger.info("Renegotiating: Streams changed"), this.handleNegotiationNeeded()
                }
                createUser(e, t, n) {
                    var i;
                    if (0 === t) {
                        this.logger.warn("Attempting to create user ".concat(e, " with 0 audio SSRC"));
                        return
                    }
                    this.logger.info("Creating user: ".concat(e, " with audio SSRC: ").concat(t, " and video SSRCs: ").concat(null !== (i = null == n ? void 0 : n.join(",")) && void 0 !== i ? i : 0));
                    let s = !1,
                        a = this.users.get(e);
                    if (null == a && (a = {}), a.audioSSRC !== t) {
                        a.audioSSRC = t, s = !0, this.unassignedStreams.audio.push({
                            cname: e,
                            ssrc: t
                        });
                        let n = this.inactiveTransceivers.audio.length,
                            i = this.unassignedStreams.audio.length;
                        this.addTransceivers("audio", "recvonly", 10 + i - n)
                    }
                    if (this.videoSupported && void 0 !== n && (!f || void 0 === a.videoSSRC)) {
                        let t = null != n && n.length > 0 ? n[0] : 0;
                        if (t > 0) {
                            if (a.videoSSRC !== t) {
                                a.videoSSRC = t, s = !0, this.unassignedStreams.video.push({
                                    cname: e,
                                    ssrc: t
                                });
                                let n = this.inactiveTransceivers.video.length,
                                    i = this.unassignedStreams.video.length;
                                this.addTransceivers("video", "recvonly", 10 + i - n)
                            }
                        } else null != a.videoSSRC && (a.videoSSRC = void 0, s = !0)
                    }
                    if (s) {
                        this.users.set(e, a), t > 0 && this.userIdsBySsrc.set(t, e);
                        let i = null != n && n.length > 0 ? n[0] : 0;
                        i > 0 && this.userIdsBySsrc.set(i, e), this.logger.info("Renegotiating: User joined"), this.handleNegotiationNeeded()
                    }
                }
                destroyUser(e) {
                    let t = this.users.get(e);
                    if (null != t) {
                        let {
                            audioSSRC: n,
                            videoSSRC: i
                        } = t;
                        this.users.delete(e), null != n && this.userIdsBySsrc.delete(n), null != i && this.userIdsBySsrc.delete(i), this.logger.info("Renegotiating: User left"), this.handleNegotiationNeeded()
                    }
                }
                setBitRate(e) {
                    this.voiceBitrate !== e && (super.setBitRate(e), this.setAudioEncoderParameters([{
                        parameter: u.EncoderParameter.AUDIO_BITRATE,
                        value: e
                    }]))
                }
                setSDP(e) {
                    if (!(0, c.validateSdp)(e)) throw Error("Incorrect SDP received from rtc-worker: ".concat(e));
                    this.sdp = e, this.setRemoteAnswer()
                }
                get peerConnectionState() {
                    return this.pc.connectionState
                }
                get iceGatheringState() {
                    return this.pc.iceGatheringState
                }
                get iceConnectionState() {
                    return this.pc.iceConnectionState
                }
                get signalingState() {
                    return this.pc.signalingState
                }
                get connected() {
                    return "connected" === this.pc.iceConnectionState
                }
                setTransceiverEncodingParameters(e, t) {
                    if (null == e || 0 === t.length) return;
                    let n = e.sender,
                        i = n.getParameters();
                    if (null == i.encodings) return;
                    let s = !1;
                    for (let e of i.encodings)
                        for (let {
                                propertyName: n,
                                value: i
                            }
                            of t) e[n] !== i && (this.logger.info("UnifiedConnection.setTransceiverEncodingParameters: ".concat(n, ": from '").concat(e[n], "' to '").concat(i, "'")), s = !0, e[n] = i);
                    if (!s) return;
                    let a = e => {
                        this.logger.error('UnifiedConnection.setTransceiverEncodingProperty: setParameters failed: "'.concat(e, '" (').concat(JSON.stringify(t), ')"'))
                    };
                    n.setParameters(i).then(() => {}, e => a(e)).catch(e => a(e))
                }
                setAudioEncoderParameters(e) {
                    let t = {
                            [u.EncoderParameter.AUDIO_BITRATE]: "maxBitrate"
                        },
                        n = [];
                    for (let {
                            parameter: i,
                            value: s
                        }
                        of e) {
                        let e = t[i];
                        if (null == e) {
                            this.logger.info('UnifiedConnection.setEncoderParameter: Unable to set parameter "'.concat(i, '"'));
                            return
                        }
                        n.push({
                            propertyName: e,
                            value: s
                        })
                    }
                    this.setTransceiverEncodingParameters(this.audioTransceiver, n)
                }
                setVideoEncoderParameters(e) {
                    let t = {
                            [u.EncoderParameter.VIDEO_BITRATE]: "maxBitrate",
                            [u.EncoderParameter.VIDEO_RESOLUTION_SCALE]: "scaleResolutionDownBy",
                            [u.EncoderParameter.VIDEO_FRAMERATE]: "maxFramerate"
                        },
                        n = [];
                    for (let {
                            parameter: i,
                            value: s
                        }
                        of e) {
                        let e = t[i];
                        if (null == e) {
                            this.logger.info('UnifiedConnection.setEncoderParameter: Unable to set parameter "'.concat(i, '"'));
                            return
                        }
                        n.push({
                            propertyName: e,
                            value: s
                        })
                    }
                    this.setTransceiverEncodingParameters(this.videoTransceiver, n)
                }
                getRawStats() {
                    return this.pc.getStats()
                }
                makeOfferAnswerOptions() {
                    return {
                        iceRestart: !1
                    }
                }
                parseLocalDescription() {
                    let e = this.pc.localDescription;
                    if (null == e) throw Error("localDescription is null");
                    let t = e.sdp,
                        {
                            outboundStreams: n,
                            codecs: i,
                            audioSSRC: s,
                            videoSSRC: a,
                            rtxSSRC: o
                        } = (0, c.extractSDP)(t);
                    return this.outboundStreams = n, this.codecs = i, this.extensions = (0, c.getExtensions)(t), this.audioSSRC = s, this.videoReady = a > 0 && o > 0, (this.videoStreamParameters[0].ssrc !== a || this.videoStreamParameters[0].rtxSsrc !== o || this.videoReady) && (this.videoStreamParameters[0].ssrc = 0 === a ? this.videoStreamParameters[0].ssrc : a, this.videoStreamParameters[0].rtxSsrc = 0 === o ? this.videoStreamParameters[0].rtxSsrc : o, this.videoStreamParameters[0].active = this.videoReady, this.emit(l.BaseConnectionEvent.Video, this.ids.userId, this.input.getVideoStreamId(), this.audioSSRC, a, o, this.videoStreamParameters)), t
                }
                addTransceivers(e, t, n, i) {
                    let s = this.pc,
                        a = s.getTransceivers().length;
                    for (let o = a; o < a + n; o++) "video" === e && null != i ? s.addTransceiver(e, {
                        direction: t,
                        streams: [i]
                    }) : s.addTransceiver(e, {
                        direction: t
                    }), this.inactiveTransceivers[e].push(o.toString())
                }
                buildSSRCsFromOutboundStreams() {
                    let e = this.outboundStreams.map(e => {
                        let {
                            mid: t,
                            type: n,
                            direction: i
                        } = e;
                        t = String(t);
                        let s = this.assignedStreams.get(t);
                        if (null != s) {
                            let e = this.users.get(s.cname),
                                i = "audio" === n ? null == e ? void 0 : e.audioSSRC : null == e ? void 0 : e.videoSSRC;
                            s.ssrc !== i && (s = void 0, this.assignedStreams.delete(t))
                        }
                        let a = this.unassignedStreams[n],
                            o = this.inactiveTransceivers[n],
                            r = o.indexOf(t);
                        return null == s && a.length > 0 && -1 !== r && (s = a.pop(), o.splice(r, 1), this.assignedStreams.set(t, s)), null == s && (s = {
                            ssrc: -1,
                            cname: ""
                        }), {
                            ssrc: s.ssrc,
                            cname: s.cname,
                            type: n,
                            direction: (0, c.getDirection)(i),
                            mid: t
                        }
                    });
                    return e
                }
                generateSDPAnswer() {
                    var e, t;
                    let n = this.audioCodec,
                        i = this.audioPayloadType,
                        s = this.videoCodec,
                        a = this.videoPayloadType,
                        o = this.videoSupported && (null === (t = this.videoTransceiver) || void 0 === t ? void 0 : null === (e = t.sender) || void 0 === e ? void 0 : e.track) != null,
                        r = this.rtxPayloadType,
                        l = this.sdp;
                    if (null == n || null == i || null == s || null == a || null == r || null == l) throw Error("Invalid payload: audioCodec: ".concat(n, ", audioPayloadType: ").concat(null == i ? "null" : i, ", videoCodec: ").concat(s, ", videoCodecPayloadType: ").concat(null == a ? "null" : a, ", rtxPayloadType: ").concat(null == r ? "null" : r, ", sdp: ").concat(null == l ? "null" : l));
                    let u = this.buildSSRCsFromOutboundStreams();
                    return (0, c.generateUnifiedSessionDescription)({
                        type: "answer",
                        baseSDP: l,
                        audioCodec: n,
                        audioPayloadType: i,
                        audioBitRate: this.voiceBitrate,
                        videoCodec: s,
                        videoPayloadType: a,
                        videoBitRate: 2500,
                        sendingVideo: o,
                        rtxPayloadType: r,
                        ssrcs: u,
                        extensions: this.extensions
                    })
                }
                async setRemoteAnswer() {
                    let e = this.pc,
                        t = this.generateSDPAnswer();
                    await e.setRemoteDescription(t), (this.unassignedStreams.audio.length > 0 || this.unassignedStreams.video.length > 0) && (this.negotiationNeeded = !0, this.logger.info("Renegotiating: Streams left unassigned after negotiation - renegotiate")), this.negotiating = !1, this.negotiationNeeded && this.handleNegotiationNeeded()
                }
                setConnected() {
                    this.input.reset(), this.setConnectionState(h.ConnectionStates.CONNECTED), this.on(l.BaseConnectionEvent.Stats, this.handleStats), this.input.on(d.InputEvent.VoiceActivity, this.handleVoiceActivity)
                }
                async handleNegotiationNeeded() {
                    let e = arguments.length > 0 && void 0 !== arguments[0] && arguments[0];
                    if (!e && (this.negotiating || null == this.sdp)) {
                        this.negotiationNeeded = !0;
                        return
                    }
                    this.negotiating = !0, this.negotiationNeeded = !1;
                    let t = this.pc,
                        n = await t.createOffer(this.makeOfferAnswerOptions());
                    await t.setLocalDescription(n);
                    let i = this.parseLocalDescription();
                    null == this.sdp ? this.emit(l.BaseConnectionEvent.Connected, "webrtc", (0, c.truncateSDP)(i)) : this.setRemoteAnswer()
                }
                constructor(e, t, n, i) {
                    super(e, t, n, i), this.sdp = null, this.negotiating = !1, this.negotiationNeeded = !1, this.users = new Map, this.userIdsBySsrc = new Map, this.assignedStreams = new Map, this.unassignedStreams = {
                        audio: [],
                        video: []
                    }, this.inactiveTransceivers = {
                        audio: [],
                        video: []
                    }, this.outboundStreams = [], this.trackUserIds = {}, this.audioCodec = null, this.audioPayloadType = null, this.videoCodec = null, this.videoPayloadType = null, this.rtxPayloadType = null, this.extensions = [], this.codecs = [], this.getUserIdBySsrc = e => this.userIdsBySsrc.get(e), this.handlePeerConnectionStateChange = () => {
                        let e = this.peerConnectionState;
                        switch (this.logger.info("peerConnectionState =>", e), e) {
                            case "connected":
                                this.setConnected();
                                break;
                            case "connecting":
                                "connected" === this.iceConnectionState ? this.setConnectionState(h.ConnectionStates.DTLS_CONNECTING) : this.setConnectionState(h.ConnectionStates.ICE_CHECKING);
                                break;
                            case "failed":
                                this.setConnectionState(h.ConnectionStates.NO_ROUTE);
                                break;
                            case "disconnected":
                            case "closed":
                                this.setConnectionState(h.ConnectionStates.DISCONNECTED)
                        }
                    }, this.handleIceConnectionStateChange = () => {
                        let e = this.iceConnectionState;
                        switch (this.logger.info("iceConnectionState =>", e), e) {
                            case "connected":
                                this.setConnected();
                                break;
                            case "checking":
                                this.setConnectionState(h.ConnectionStates.ICE_CHECKING);
                                break;
                            case "failed":
                                this.setConnectionState(h.ConnectionStates.NO_ROUTE);
                                break;
                            case "disconnected":
                            case "closed":
                                this.setConnectionState(h.ConnectionStates.DISCONNECTED)
                        }
                    }, this.handleSignalingStateChange = () => {
                        let e = this.signalingState;
                        this.logger.info("signalingState => ".concat(e))
                    }, this.handleIceGatheringStateChange = () => {
                        this.logger.info("iceGatheringState =>", this.iceGatheringState)
                    }, this.handleTrack = e => {
                        let t = e.streams[0].id,
                            n = e.track;
                        if (!/^default/.test(n.id)) {
                            var i, s, a, o;
                            let [e, r] = t.split("-");
                            this.trackUserIds[n.id] = e;
                            let l = this.users.get(e);
                            if ((null == l ? void 0 : null === (s = l.videoSSRC) || void 0 === s ? void 0 : null === (i = s.toString) || void 0 === i ? void 0 : i.call(s)) !== r && (null == l ? void 0 : null === (o = l.audioSSRC) || void 0 === o ? void 0 : null === (a = o.toString) || void 0 === a ? void 0 : a.call(o)) !== r) {
                                this.logger.info("Got stale ssrc ".concat(r, " for ").concat(n.kind, " track, user ID ").concat(e));
                                return
                            }
                            this.createOutput(e, n), n.onunmute = () => this.createOutput(e, n), n.onmute = () => {
                                var t;
                                (null === (t = this.users.get(e)) || void 0 === t ? void 0 : t.videoSSRC) == null && this.destroyOutput(e, n)
                            }
                        }
                    }, this.logger = new r.default("UnifiedConnection(".concat(e, ")")), this.videoSupported = p.BROWSER_SUPPORTS_VIDEO;
                    let s = this.pc = new RTCPeerConnection({
                        bundlePolicy: "max-bundle",
                        sdpSemantics: "unified-plan"
                    });
                    p.BROWSER_SUPPORTS_CONNECTION_STATE ? (s.onconnectionstatechange = this.handlePeerConnectionStateChange, s.oniceconnectionstatechange = this.handlePeerConnectionStateChange) : s.oniceconnectionstatechange = this.handleIceConnectionStateChange, s.onsignalingstatechange = this.handleSignalingStateChange, s.onicegatheringstatechange = this.handleIceGatheringStateChange, s.ontrack = this.handleTrack, s.addTransceiver("audio", {
                        direction: "recvonly",
                        sendEncodings: [{
                            maxBitrate: this.voiceBitrate
                        }]
                    }), this.audioTransceiver = s.getTransceivers()[0], this.videoSupported && (this.addTransceivers("video", "recvonly", 1, this.input.getVideoStream()), this.videoTransceiver = s.getTransceivers()[1]), this.addTransceivers("audio", "recvonly", 10), this.videoSupported && this.addTransceivers("video", "recvonly", 10), this.setStream(this.input.stream), this.logger.info("Renegotiating: Initial negotiation"), this.handleNegotiationNeeded(!0)
                }
            }
        },
        111e3: function(e, t, n) {
            "use strict";
            var i;
            n.r(t), n.d(t, {
                default: function() {
                    return i
                }
            }), n("424973"), n("370692"), n("477657"), n("811875"), n("90301"), n("652153"), n("28797"), n("817884"), n("597349"), n("667536"), n("690341");
            i = class {
                stop() {
                    this.source.disconnect(), clearInterval(this.interval), this.speakingCounter = 0
                }
                get speaking() {
                    return this.speakingCounter > 0 || this.silentFrames < this.silenceThreshold
                }
                update() {
                    this.currentVolume = function(e, t) {
                        let n = -1 / 0;
                        e.getFloatFrequencyData(t);
                        for (let e = 4; e < t.length; e++) t[e] > n && t[e] < 0 && (n = t[e]);
                        return n
                    }(this.analyser, this.fftBins), this.speakingHistory[this.speakingHistoryIndex] && this.speakingCounter--;
                    let e = this.currentVolume > this.threshold;
                    this.speakingHistory[this.speakingHistoryIndex] = e, e && this.speakingCounter++, ++this.speakingHistoryIndex === this.speakingHistory.length && (this.speakingHistoryIndex = 0), this.speakingCounter > 0 ? this.silentFrames = 0 : this.silentFrames++
                }
                constructor(e, t, n, i = .1, s = 10) {
                    this.currentVolume = 0, this.speakingHistoryIndex = 0, this.speakingCounter = 0, this.onProcess = null;
                    let a = e.createAnalyser();
                    a.fftSize = 512, a.smoothingTimeConstant = i;
                    let o = e.createMediaStreamSource(t);
                    o.connect(a);
                    let r = [];
                    for (let e = 0; e < s; e++) r.push(!1);
                    let l = window.setInterval(() => {
                        var e;
                        this.update(), null === (e = this.onProcess) || void 0 === e || e.call(this, this.speaking, this.currentVolume)
                    }, 20);
                    this.threshold = n, this.analyser = a, this.interval = l, this.fftBins = new Float32Array(a.fftSize), this.source = o, this.speakingHistory = r, this.silenceThreshold = this.speakingHistory.length, this.silentFrames = this.silenceThreshold
                }
            }
        },
        555013: function(e, t, n) {
            "use strict";
            n.r(t), n.d(t, {
                default: function() {
                    return i
                }
            }), n("70102"), n("222007");
            var i, s = n("44170"),
                a = n("861001"),
                o = n("201617"),
                r = n("441822"),
                l = n("353927"),
                u = n("843455");
            let d = new o.default;
            i = class extends s.EventEmitter {
                destroy() {
                    null != this.stream && (d.release(this.stream), this.stream = null), null != this.streamId && (0, r.unregisterVideoStream)(this.streamId), this.destroyed = !0
                }
                getStreamId() {
                    return this.streamId
                }
                async setSource(e) {
                    if (this.sourceId === e) return this.stream;
                    this.sourceId = e, null != this.stream && (d.release(this.stream), this.stream = null);
                    let t = await (0, a.getVideoInputDevices)();
                    if (this.sourceId === l.DISABLED_DEVICE_ID) return this.setStream(new MediaStream);
                    let n = {
                        width: 1280
                    };
                    t.some(e => e.id === this.sourceId) && (n.deviceId = this.sourceId);
                    try {
                        let e = await d.acquire({
                            audio: !1,
                            video: n
                        });
                        if (this.destroyed) throw d.release(e), Error("VideoInput: Already destroyed");
                        return this.emit("permission", !0), this.setStream(e)
                    } catch (e) {
                        if ("string" != typeof e) switch (e.name) {
                            case "PermissionDeniedError":
                            case "NotAllowedError":
                                throw this.emit("permission", !1), u.UserMediaErrors.PERMISSION_DENIED;
                            case "PermissionDismissedError":
                                throw this.emit("permission", !1), u.UserMediaErrors.PERMISSION_DISMISSED;
                            case "DevicesNotFoundError":
                            case "NotFoundError":
                                throw u.UserMediaErrors.NO_DEVICES_FOUND;
                            default:
                                throw e.name || "UNKNOWN"
                        }
                        throw e
                    }
                }
                setStream(e) {
                    return null != this.streamId && ((0, r.unregisterVideoStream)(this.streamId), this.streamId = null), this.stream = e, e.onaddtrack = e => this.emit("add-video-track", e), e.getVideoTracks().length > 0 && (this.streamId = (0, r.registerVideoStream)(e)), this.emit("stream", e), this.emit("video", this.getStreamId()), e
                }
                constructor(...e) {
                    super(...e), this.stream = new MediaStream, this.sourceId = l.DISABLED_DEVICE_ID, this.streamId = null, this.destroyed = !1
                }
            }
        },
        441822: function(e, t, n) {
            "use strict";
            n.r(t), n.d(t, {
                registerVideoStream: function() {
                    return o
                },
                unregisterVideoStream: function() {
                    return r
                },
                getVideoStream: function() {
                    return l
                }
            });
            var i = n("773179"),
                s = n.n(i);
            let a = {};

            function o(e) {
                let t = s.uniqueId("VideoStream");
                return a[t] = e, t
            }

            function r(e) {
                delete a[e]
            }

            function l(e) {
                return a[e]
            }
        },
        849074: function(e, t, n) {
            "use strict";
            var i, s;
            n.r(t), n.d(t, {
                WebRTCStatsCalculator: function() {
                    return a
                }
            }), n("222007");
            class a {
                update(e) {
                    for (let t in e.rtp.inbound) {
                        let n = e.rtp.inbound[t];
                        for (let e of n)
                            if ("video" === e.type) {
                                let t = this.getInboundBytesRecevierCalculator(e),
                                    n = this.getInboundFrameDecodeRateCalculator(e);
                                e.bitrate = t.calculate(e), e.frameRateDecode = n.calculate(e)
                            }
                    }
                    for (let t of e.rtp.outbound)
                        if ("video" === t.type) {
                            let e = this.getOutboundBytesSentCalculator(t),
                                n = this.getOutboundEncodeRateCalculator(t);
                            t.bitrate = e.calculate(t), t.frameRateEncode = n.calculate(t)
                        }
                }
                static getCalculatorOrCreate(e, t, n, i) {
                    let s = arguments.length > 4 && void 0 !== arguments[4] ? arguments[4] : 0,
                        a = e[t.ssrc];
                    return null == a && (a = new r(n, i, s), e[t.ssrc] = a), a
                }
                getInboundBytesRecevierCalculator(e) {
                    return a.getCalculatorOrCreate(this.inboundVideoBitrate, e, "bytesReceived", "timestamp", 3)
                }
                getInboundFrameDecodeRateCalculator(e) {
                    return a.getCalculatorOrCreate(this.inboundDecodeFps, e, "framesDecoded", "timestamp", 5)
                }
                getOutboundBytesSentCalculator(e) {
                    return a.getCalculatorOrCreate(this.outboundVideoBitrate, e, "bytesSent", "timestamp", 3)
                }
                getOutboundEncodeRateCalculator(e) {
                    return a.getCalculatorOrCreate(this.outboundEncodeFps, e, "framesEncoded", "timestamp", 5)
                }
                constructor() {
                    this.inboundVideoBitrate = {}, this.inboundDecodeFps = {}, this.outboundVideoBitrate = {}, this.outboundEncodeFps = {}
                }
            }(s = i || (i = {}))[s.NONE = 0] = "NONE", s[s.MILLISECONDS_FROM_SECONDS = 1] = "MILLISECONDS_FROM_SECONDS", s[s.BYTES_TO_BITS = 2] = "BYTES_TO_BITS", s[s.ROUND = 4] = "ROUND";
            let o = {
                0: {
                    multiplier: 1
                },
                1: {
                    postfix: "_in_ms",
                    multiplier: 1e3
                },
                2: {
                    bitrate: !0,
                    postfix: "",
                    multiplier: 8
                }
            };
            class r {
                calculate(e) {
                    let t = this.previous;
                    if (this.previous = e, null == t) return;
                    let n = e.timestamp - t.timestamp;
                    if (n <= 0 || "number" != typeof n) return;
                    let i = t[this.accumulativeMetricKey],
                        s = e[this.accumulativeMetricKey];
                    if ("number" != typeof i || "number" != typeof s) return;
                    let a = t[this.samplesMetricKey],
                        o = e[this.samplesMetricKey];
                    if ("number" != typeof a || "number" != typeof o) return;
                    let r = (s - i) / (o - a) * this.multiplier;
                    return this.round ? Math.round(r) : r
                }
                constructor(e, t, n = 0) {
                    for (let r in this.accumulativeMetricKey = e, this.samplesMetricKey = t, this.multiplier = 1, this.round = !1, i) {
                        var s, a;
                        let e = Number(r);
                        !isNaN(e) && (n & e) != 0 && r in o && (this.multiplier *= null !== (a = null === (s = o[r]) || void 0 === s ? void 0 : s.multiplier) && void 0 !== a ? a : 1)
                    }
                    this.round = (4 & n) != 0
                }
            }
        },
        551079: function(e, t, n) {
            "use strict";
            n.r(t), n.d(t, {
                default: function() {
                    return i
                }
            }), n("506083"), n("70102"), n("222007"), n("369198");
            var i, s = n("383536"),
                a = n.n(s),
                o = n("811022"),
                r = n("595275"),
                l = n("662697"),
                u = n.n(l),
                d = n("947279"),
                c = n("773364"),
                h = n("953161"),
                p = n("793722"),
                f = n("657869"),
                m = n("560550"),
                E = n("820127"),
                g = n("861001"),
                S = n("899676"),
                _ = n("13379"),
                v = n("238372"),
                C = n("232125"),
                T = n("353927"),
                I = n("53452");
            let A = new o.default("MediaEngineWebRTC");
            i = class extends r.default {
                destroy() {
                    null != this.voiceActivityInput && (this.voiceActivityInput.destroy(), this.voiceActivityInput = null), this.eachConnection(e => e.destroy()), this.emit(c.MediaEngineEvent.Destroy), this.removeAllListeners()
                }
                interact() {
                    !this.interacted && (document.createElement("audio").play(), this.interacted = !0), this.eachConnection(e => e.interact())
                }
                static supported() {
                    return !__OVERLAY__ && (I.BROWSER_SUPPORTS_VOICE && null != window.AudioContext && null != window.RTCPeerConnection ? (n("231638"), !0) : (A.info("WebRTC is not supported on", a.name, a.version), !1))
                }
                supported() {
                    return !0
                }
                supports(e) {
                    switch (e) {
                        case T.Features.AUDIO_INPUT_DEVICE:
                            return g.CAN_SET_DEVICES;
                        case T.Features.AUDIO_OUTPUT_DEVICE:
                            return g.CAN_SET_OUTPUT_DEVICES;
                        case T.Features.VIDEO:
                            return I.BROWSER_SUPPORTS_VIDEO;
                        case T.Features.DESKTOP_CAPTURE:
                            var t;
                            return (null === (t = navigator.mediaDevices) || void 0 === t ? void 0 : t.getDisplayMedia) != null;
                        case T.Features.VOICE_PROCESSING:
                            return "Chrome" === a.name;
                        case T.Features.NATIVE_PING:
                        case T.Features.DIAGNOSTICS:
                            return I.BROWSER_SUPPORTS_DIAGNOSTICS;
                        case T.Features.DESKTOP_CAPTURE_APPLICATIONS:
                        case T.Features.LOOPBACK:
                        case T.Features.NOISE_SUPPRESSION:
                        case T.Features.AUTOMATIC_GAIN_CONTROL:
                            return "Safari" !== a.name;
                        case T.Features.NOISE_CANCELLATION:
                            return u();
                        case T.Features.QOS:
                        case T.Features.ATTENUATION:
                        case T.Features.AUTOMATIC_VAD:
                        case T.Features.LEGACY_AUDIO_SUBSYSTEM:
                        case T.Features.EXPERIMENTAL_AUDIO_SUBSYSTEM:
                        case T.Features.DEBUG_LOGGING:
                        case T.Features.VOICE_PANNING:
                        case T.Features.AUTO_ENABLE:
                        case T.Features.DESKTOP_CAPTURE_FORMAT:
                        case T.Features.VIDEO_HOOK:
                        case T.Features.OPEN_H264:
                        case T.Features.AEC_DUMP:
                        case T.Features.DISABLE_VIDEO:
                        case T.Features.CONNECTION_REPLAY:
                        case T.Features.SIMULCAST:
                        case T.Features.SCREEN_CAPTURE_KIT:
                        default:
                            return !1
                    }
                }
                getAudioContext() {
                    return null == this._audioContext && (this._audioContext = new AudioContext), this._audioContext
                }
                connect(e, t, n) {
                    let {
                        ssrc: i,
                        address: s,
                        port: a,
                        modes: o,
                        streamUserId: r,
                        streamParameters: l
                    } = n, u = (0, m.makeConnection)(e, t, this.getAudioContext(), l);
                    return u.streamUserId = r, u.setOutputVolume(this.outputVolume), u.setSinkId(this.sinkId), u.once(d.BaseConnectionEvent.Destroy, e => this.connections.delete(e)), u.on(d.BaseConnectionEvent.Silence, e => this.emit(c.MediaEngineEvent.Silence, e)), u.on(d.BaseConnectionEvent.DesktopSourceEnd, this.handleDesktopSourceEnd), u.on(d.BaseConnectionEvent.AudioPermission, this.handleAudioPermission), u.on(d.BaseConnectionEvent.VideoPermission, this.handleVideoPermission), this.interacted && u.interact(), e === T.MediaEngineContextTypes.DEFAULT && (u.setAudioSource(this.sourceId), this.enabled && u.input.enableAudioInput()), this.connections.add(u), this.emit(c.MediaEngineEvent.Connection, u), u
                }
                findConnection(e) {
                    return Array.from(this.connections).find(t => null == e || t.context === e)
                }
                eachConnection(e, t) {
                    this.connections.forEach(n => {
                        (null == t || n.context === t) && e(n)
                    })
                }
                enable() {
                    return null == this.enablePromise && (this.enablePromise = this._enable().finally(() => {
                        this.enablePromise = null
                    })), this.enablePromise
                }
                async _enable() {
                    if (this.enabled) return;
                    await this.getAudioContext().audioWorklet.addModule(S);
                    let e = new f.default(this.getAudioContext());
                    e.on("permission", this.handleAudioPermission);
                    try {
                        var t;
                        await e.enable(), "Firefox" === a.name && await this.handleDeviceChange(), this.enabled = !0, this.eachConnection(e => e.input.enableAudioInput(), T.MediaEngineContextTypes.DEFAULT), null === (t = this.voiceActivityInput) || void 0 === t || t.enable()
                    } finally {
                        e.destroy()
                    }
                }
                setInputVolume(e) {}
                setOutputVolume(e) {
                    this.outputVolume = e, this.connections.forEach(t => t.setOutputVolume(e))
                }
                getAudioInputDevices() {
                    return (0, g.getAudioInputDevices)()
                }
                setAudioInputDevice(e) {
                    var t, n;
                    this.sourceId = e, this.eachConnection(t => t.setAudioSource(e), T.MediaEngineContextTypes.DEFAULT), null === (t = this.voiceActivityInput) || void 0 === t || t.setSource(e), null === (n = this.loopback) || void 0 === n || n.setAudioSource(e)
                }
                getAudioOutputDevices() {
                    return (0, g.getAudioOutputDevices)()
                }
                setAudioOutputDevice(e) {
                    var t;
                    this.sinkId = e, this.connections.forEach(t => t.setSinkId(e)), null === (t = this.loopback) || void 0 === t || t.setAudioSink(e)
                }
                getVideoInputDevices() {
                    return (0, g.getVideoInputDevices)()
                }
                setVideoInputDevice(e) {
                    this.eachConnection(t => t.setVideoSource(e), T.MediaEngineContextTypes.DEFAULT)
                }
                getSupportedVideoCodecs(e) {
                    e([])
                }
                getCodecCapabilities(e) {
                    e("")
                }
                async getDesktopSource(e) {
                    let t = arguments.length > 1 && void 0 !== arguments[1] && arguments[1],
                        n = await E.default.get(e, t);
                    return this.pendingDesktopInputs[n.id] = n, n.id
                }
                getDesktopSources() {
                    return Promise.reject(Error("NO_STREAM"))
                }
                getScreenPreviews(e, t) {
                    return Promise.reject(Error("UNSUPPORTED"))
                }
                getWindowPreviews(e, t) {
                    return Promise.reject(Error("UNSUPPORTED"))
                }
                setClipBufferLength(e) {}
                saveClip(e, t) {
                    return Promise.reject(Error("UNSUPPORTED"))
                }
                saveClipForSSRC(e, t, n, i) {
                    return Promise.reject(Error("UNSUPPORTED"))
                }
                updateClipMetadata(e, t) {
                    return Promise.reject(Error("UNSUPPORTED"))
                }
                exportClip(e, t) {
                    return Promise.reject(Error("UNSUPPORTED"))
                }
                setGoLiveSource(e, t) {
                    if (null == e) this.eachConnection(e => e.setDesktopInput(null), t);
                    else if (null != e.desktopDescription && null != this.findConnection(t)) {
                        let n = this.pendingDesktopInputs[e.desktopDescription.id];
                        delete this.pendingDesktopInputs[e.desktopDescription.id], null != n && this.eachConnection(e => e.setDesktopInput(n), t)
                    }
                }
                setClipsSource(e) {}
                setSoundshareSource(e, t, n) {}
                setAudioSubsystem(e) {}
                getAudioSubsystem() {
                    return T.AudioSubsystems.STANDARD
                }
                getAudioLayer() {
                    return ""
                }
                getDebugLogging() {
                    return !1
                }
                setDebugLogging(e) {}
                writeAudioDebugState() {
                    return Promise.reject(Error("Audio debug state is not supported."))
                }
                setExperimentalAdm(e) {}
                setLoopback(e, t) {
                    e && null == this.loopback ? (this.enable(), this.loopback = new _.default(this.getAudioContext(), this.sourceId, this.sinkId), this.loopback.setNoiseCancellation(t.noiseCancellation)) : !e && null != this.loopback && (this.loopback.stop(), this.loopback = null)
                }
                getLoopback() {
                    return null != this.loopback
                }
                setH264Enabled(e) {}
                setAv1Enabled(e) {}
                setH265Enabled(e) {}
                getCodecSurvey() {
                    return Promise.reject(Error("getCodecSurvey is not implemented on MediaEngine of browsers."))
                }
                startAecDump() {}
                stopAecDump() {}
                setAecDump(e) {}
                createReplayConnection(e, t) {
                    throw Error("Connection replay is not supported.")
                }
                setUseDirectVideo(e) {}
                setMaxSyncDelayOverride(e) {}
                rankRtcRegions(e) {
                    return Promise.reject(Error("RTC region latency test is not supported."))
                }
                getSoundshareStatus() {
                    return Promise.reject(Error("getSoundshareStatus is not supported."))
                }
                enableSoundshare() {
                    return Promise.reject(Error("enableSoundshare is not supported."))
                }
                applyMediaFilterSettings(e) {
                    return Promise.resolve()
                }
                startLocalAudioRecording() {
                    return Promise.reject(Error("startLocalAudioRecording is not supported."))
                }
                stopLocalAudioRecording(e) {}
                speedTester(e, t) {
                    throw Error("speedTester is not supported.")
                }
                setHasFullbandPerformance(e) {}
                getSupportedSecureFramesProtocolVersion() {
                    return 0
                }
                getSupportedBandwidthEstimationExperiments(e) {
                    e([])
                }
                constructor() {
                    super(), this.Video = C.default, this.Camera = v.default, this._audioContext = null, this.outputVolume = T.DEFAULT_VOLUME, this.sourceId = T.DEFAULT_DEVICE_ID, this.sinkId = T.DEFAULT_DEVICE_ID, this.enabled = !1, this.connections = new Set, this.interacted = !1, this.loopback = null, this.voiceActivityInput = null, this.pendingDesktopInputs = {}, this.enablePromise = null, this.handleActiveSinksChange = (e, t) => {
                        this.connections.forEach(n => n.setHasActiveVideoOutputSink(e, t))
                    }, this.handleNewListener = e => {
                        switch (e) {
                            case c.MediaEngineEvent.DeviceChange:
                                null != navigator.mediaDevices && null == navigator.mediaDevices.ondevicechange && (navigator.mediaDevices.ondevicechange = () => {
                                    this.handleDeviceChange()
                                }, this.handleDeviceChange());
                                break;
                            case c.MediaEngineEvent.VoiceActivity:
                                null == this.voiceActivityInput && (this.voiceActivityInput = new f.default(this.getAudioContext()), this.voiceActivityInput.setSource(this.sourceId), this.voiceActivityInput.on("voiceactivity", this.handleVoiceActivity), this.enabled && this.voiceActivityInput.enable())
                        }
                    }, this.handleRemoveListener = e => {
                        switch (e) {
                            case c.MediaEngineEvent.DeviceChange:
                                var t;
                                (null === (t = navigator.mediaDevices) || void 0 === t ? void 0 : t.ondevicechange) != null && 0 === this.listenerCount(c.MediaEngineEvent.DeviceChange) && (navigator.mediaDevices.ondevicechange = null);
                                break;
                            case c.MediaEngineEvent.VoiceActivity:
                                null != this.voiceActivityInput && 0 === this.listenerCount(c.MediaEngineEvent.VoiceActivity) && (this.voiceActivityInput.destroy(), this.voiceActivityInput = null)
                        }
                    }, this.handleDeviceChange = () => (0, g.getDevices)().then(e => {
                        let [t, n, i] = e;
                        return this.emit(c.MediaEngineEvent.DeviceChange, t, n, i)
                    }), this.handleVoiceActivity = e => {
                        this.emit(c.MediaEngineEvent.VoiceActivity, e, 0)
                    }, this.handleDesktopSourceEnd = () => {
                        this.emit(c.MediaEngineEvent.DesktopSourceEnd)
                    }, this.handleAudioPermission = e => {
                        this.emit(c.MediaEngineEvent.AudioPermission, e)
                    }, this.handleVideoPermission = e => {
                        this.emit(c.MediaEngineEvent.VideoPermission, e)
                    }, this.on("newListener", this.handleNewListener), this.on("removeListener", this.handleRemoveListener), (0, p.setActiveSinksChangeCallback)(this.handleActiveSinksChange), (0, h.default)(this)
                }
            }
        },
        369198: function(e, t, n) {
            "use strict";
            n.r(t);
            var i, s = n("383536"),
                a = n.n(s),
                o = n("67021");
            window.AudioContext = null !== (i = window.AudioContext) && void 0 !== i ? i : window.webkitAudioContext, null != window.RTCPeerConnection && "Chrome" === a.name && 52 > (0, o.platformVersion)() && ["createOffer", "createAnswer"].forEach(e => {
                let t = RTCPeerConnection.prototype[e];
                RTCPeerConnection.prototype[e] = function() {
                    for (var e = arguments.length, n = Array(e), i = 0; i < e; i++) n[i] = arguments[i];
                    let s = this;
                    if (n.length < 1 || 1 === n.length && "object" == typeof n[0]) {
                        let e = 1 === n.length ? n[0] : void 0;
                        return null != e && (e = {
                            mandatory: {
                                OfferToReceiveAudio: e.offerToReceiveAudio || !1,
                                OfferToReceiveVideo: e.offerToReceiveVideo || !1
                            },
                            optional: [{
                                VoiceActivityDetection: e.voiceActivityDetection || !1
                            }, {
                                IceRestart: e.iceRestart || !1
                            }]
                        }), new Promise((n, i) => t.apply(s, [n, i, e]))
                    }
                    return t.apply(this, n)
                }
            })
        },
        948961: function(e, t, n) {
            "use strict";
            n.r(t), n.d(t, {
                default: function() {
                    return a
                }
            }), n("222007"), n("424973");
            var i = n("823302");

            function s(e) {
                return {
                    id: e.payloadType,
                    name: e.mimeType.split("/").slice(1)[0]
                }
            }

            function a(e, t, n, a) {
                var o, r, l;
                let u = {},
                    d = {},
                    c = [],
                    h = [];
                for (let t of e.values()) switch (t.type) {
                    case "candidate-pair":
                        u[t.id] = t;
                        break;
                    case "codec":
                        d[t.id] = t;
                        break;
                    case "inbound-rtp":
                        c.push(t);
                        break;
                    case "outbound-rtp":
                        h.push(t)
                }
                let p = Object.values(u).find(e => "succeeded" === e.state);
                if (void 0 === p) return null;
                let f = [];
                for (let e of h) {
                    let t = d[e.codecId];
                    if (null == t) continue;
                    let a = {
                        type: e.kind,
                        ssrc: e.ssrc,
                        timestamp: e.timestamp,
                        sinkWant: (0, i.formatSinkWantStat)(n, e.ssrc, "video" === e.kind),
                        sinkWantAsInt: (0, i.formatSinkWantAsInt)(n, e.ssrc),
                        codec: s(t),
                        bytesSent: e.bytesSent,
                        packetsSent: e.packetsSent
                    };
                    if ("audio" === e.kind) f.push({
                        ...a,
                        type: "audio"
                    });
                    else if ("video" === e.kind) {
                        ;
                        let t = null !== e.frameWidth ? {
                            width: e.frameWidth,
                            height: e.frameHeight
                        } : void 0;
                        f.push({
                            ...a,
                            framesEncoded: e.framesEncoded,
                            keyFramesEncoded: e.keyFramesEncoded,
                            firCount: e.firCount,
                            nackCount: e.nackCount,
                            pliCount: e.pliCount,
                            bitrateTarget: e.targetBitrate,
                            qpSum: e.qpSum,
                            averageEncodeTime: null == e.framesEncoded || null === (l = e.totalEncodeTime) || 0 === l ? void 0 : (1e3 * e.totalEncodeTime / e.framesEncoded).toFixed(1),
                            resolution: t,
                            framesSent: e.framesSent,
                            frameRateInput: e.framesPerSecond,
                            type: "video"
                        })
                    }
                }
                let m = {};
                for (let e of c) {
                    let o = d[e.codecId];
                    if (null == o) continue;
                    let r = t(e.ssrc);
                    if (null == r) continue;
                    let l = {
                        type: e.kind,
                        ssrc: e.ssrc,
                        timestamp: e.timestamp,
                        sinkWant: (0, i.formatSinkWantStat)(n, e.ssrc, "video" === e.kind),
                        sinkWantAsInt: (0, i.formatSinkWantAsInt)(n, e.ssrc),
                        sinkWantLocal: (0, i.formatSinkWantStat)(a, e.ssrc, "video" === e.kind),
                        codec: s(o),
                        bytesReceived: e.bytesReceived,
                        packetsReceived: e.packetsReceived,
                        packetsLost: e.packetsLost
                    };
                    if ("audio" === e.kind) {
                        let t = void 0 !== e.jitterBufferDelay && void 0 !== e.jitterBufferEmittedCount ? Math.round(1e3 * e.jitterBufferDelay / e.jitterBufferEmittedCount) : 0;
                        null == m[r] && (m[r] = []), m[r].push({
                            ...l,
                            audioLevel: e.audioLevel,
                            jitter: 1e3 * e.jitter,
                            jitterBuffer: t
                        })
                    } else if ("video" === e.kind) {
                        null == m[r] && (m[r] = []);
                        let t = null !== e.frameWidth ? {
                            width: e.frameWidth,
                            height: e.frameHeight
                        } : void 0;
                        m[r].push({
                            ...l,
                            resolution: t,
                            framesDecoded: e.framesDecoded,
                            keyFramesDecoded: e.keyFramesDecoded,
                            framesDropped: e.framesDropped,
                            framesReceived: e.framesReceived,
                            frameRateDecode: e.framesPerSecond,
                            averageDecodeTime: null == e.framesDecoded || null == e.totalDecodeTime ? void 0 : (1e3 * e.totalDecodeTime / e.framesDecoded).toFixed(1),
                            firCount: e.firCount,
                            nackCount: e.nackCount,
                            pliCount: e.pliCount,
                            qpSum: e.qpSum,
                            decoderImplementationName: "WebRTC"
                        })
                    }
                }
                let E = (null !== (o = p.currentRoundTripTime) && void 0 !== o ? o : 0) * 1e3;
                return {
                    transport: {
                        availableOutgoingBitrate: null !== (r = p.availableOutgoingBitrate) && void 0 !== r ? r : 0,
                        bytesReceived: p.bytesReceived,
                        bytesSent: p.bytesSent,
                        ping: E
                    },
                    rtp: {
                        inbound: m,
                        outbound: f
                    }
                }
            }
        },
        238372: function(e, t, n) {
            "use strict";
            n.r(t), n.d(t, {
                default: function() {
                    return l
                }
            }), n("222007");
            var i = n("37983"),
                s = n("884691"),
                a = n("441822"),
                o = n("232125");
            async function r(e) {
                let {
                    deviceId: t,
                    width: n,
                    height: i,
                    disabled: s
                } = e;
                if (s) return null;
                try {
                    let e = await navigator.mediaDevices.getUserMedia({
                        audio: !1,
                        video: {
                            width: n * window.devicePixelRatio,
                            height: i * window.devicePixelRatio,
                            frameRate: 30,
                            deviceId: t
                        }
                    });
                    return e
                } catch (e) {
                    return null
                }
            }

            function l(e) {
                let {
                    deviceId: t,
                    width: n,
                    height: l,
                    disabled: u
                } = e, [d, c] = s.useState();
                return s.useEffect(() => {
                    let e = r({
                        deviceId: t,
                        width: n,
                        height: l,
                        disabled: u
                    }).then(e => {
                        let t = null != e ? (0, a.registerVideoStream)(e) : null;
                        return c(t), {
                            stream: e,
                            streamId: t
                        }
                    });
                    return () => {
                        e.then(e => {
                            var t;
                            let {
                                stream: n,
                                streamId: i
                            } = e;
                            null != (t = n) && t.getTracks().forEach(e => e.stop()), null != i && (0, a.unregisterVideoStream)(i)
                        })
                    }
                }, [t, n, l, u]), null == d ? (0, i.jsx)("div", {
                    className: "media-engine-video",
                    style: {
                        width: n,
                        height: l
                    }
                }) : (0, i.jsx)(o.default, {
                    streamId: d,
                    style: {
                        width: n,
                        height: l
                    }
                })
            }
            l.defaultProps = {
                disabled: !1,
                width: 320,
                height: 180
            }
        },
        232125: function(e, t, n) {
            "use strict";
            n.r(t), n.d(t, {
                default: function() {
                    return u
                }
            });
            var i = n("37983"),
                s = n("884691"),
                a = n("677935"),
                o = n.n(a),
                r = n("793722"),
                l = n("441822");

            function u(e) {
                let {
                    streamId: t,
                    paused: n,
                    onReady: a,
                    onResize: u,
                    className: d,
                    ...c
                } = e, h = s.useRef(null), p = s.useRef({
                    width: 0,
                    height: 0
                });
                s.useLayoutEffect(() => {
                    let e = h.current;
                    if (null != e) return (0, r.registerActiveSink)(t), e.srcObject = (0, l.getVideoStream)(t), () => {
                        (0, r.unregisterActiveSink)(t), e.srcObject = null, e.load()
                    }
                }, [t]), s.useEffect(() => {
                    var e, i;
                    return n ? (null === (e = h.current) || void 0 === e || e.pause(), (0, r.unregisterActiveSink)(t)) : null === (i = h.current) || void 0 === i || i.play().catch(() => {}), () => {
                        n && (0, r.registerActiveSink)(t)
                    }
                }, [n]);
                let f = s.useCallback(() => {
                    var e, t, n, i;
                    let {
                        width: s,
                        height: a
                    } = p.current, o = null !== (n = null === (e = h.current) || void 0 === e ? void 0 : e.videoWidth) && void 0 !== n ? n : 0, r = null !== (i = null === (t = h.current) || void 0 === t ? void 0 : t.videoHeight) && void 0 !== i ? i : 0;
                    if (s !== o || a !== r) {
                        let e = {
                            width: o,
                            height: r
                        };
                        null == u || u(e), p.current = e
                    }
                }, [u]);
                s.useLayoutEffect(() => {
                    let e = h.current;
                    if (null != e) return e.addEventListener("resize", f), () => e.removeEventListener("resize", f)
                }, [f]);
                let m = s.useCallback(() => {
                        null == a || a()
                    }, [a]),
                    E = s.useCallback(e => {
                        !n && e.currentTarget.play()
                    }, [n]);
                return (0, i.jsx)("video", {
                    className: o("media-engine-video", d),
                    ref: h,
                    autoPlay: !0,
                    onPause: E,
                    onCanPlayThrough: m,
                    muted: !0,
                    ...c
                })
            }
            u.defaultProps = {
                paused: !1
            }
        },
        398183: function(e, t, n) {
            "use strict";
            n.r(t), n.d(t, {
                now: function() {
                    return s
                },
                TimeStampProducer: function() {
                    return a
                },
                StopWatch: function() {
                    return r
                },
                sleep: function() {
                    return l
                }
            }), n("70102"), n("129334");
            var i = n("279295");
            let s = () => Math.floor(i.timeOrigin + i.performance.now()),
                a = new class {
                    now() {
                        return s()
                    }
                };
            class o {
                isGreaterThan(e) {
                    return this.milliseconds > e.milliseconds
                }
                isGreaterOrEqualTo(e) {
                    return this.milliseconds >= e.milliseconds
                }
                constructor(e, t, n, i) {
                    this.milliseconds = 0, this.asMilliseconds = () => this.milliseconds, this.asSeconds = () => this.milliseconds / 1e3, this.asMinutes = () => this.milliseconds / 1e3 / 60, this.asHours = () => this.milliseconds / 1e3 / 60 / 60, this.add = e => o.fromMilliseconds(this.milliseconds + e.milliseconds), this.subtract = e => o.fromMilliseconds(this.milliseconds - e.milliseconds), this.subtractOrZero = e => o.fromMilliseconds(Math.max(this.milliseconds - e.milliseconds, 0)), this.milliseconds += i || 0, this.milliseconds += 1e3 * (n || 0), this.milliseconds += 6e4 * (t || 0), this.milliseconds += 36e5 * (e || 0)
                }
            }
            o.fromMilliseconds = e => new o(0, 0, 0, e), o.fromSeconds = e => new o(0, 0, e), o.fromMinutes = e => new o(0, e), o.fromHours = e => new o(e);
            class r {
                start() {
                    null == this.startTime && (this.startTime = this.timestampProducer.now())
                }
                restart() {
                    this.startTime = this.timestampProducer.now()
                }
                reset() {
                    this.startTime = void 0, this.timePassed = 0
                }
                stop() {
                    null != this.startTime && (this.timePassed += this.timestampProducer.now() - this.startTime, this.startTime = void 0)
                }
                toggle(e) {
                    e !== this.isRunning() && (e ? this.start() : this.stop())
                }
                elapsed() {
                    if (null == this.startTime) return o.fromMilliseconds(this.timePassed);
                    let e = this.timestampProducer.now() - this.startTime;
                    return o.fromMilliseconds(this.timePassed + e)
                }
                isRunning() {
                    return null != this.startTime
                }
                static startNew() {
                    let e = new r;
                    return e.start(), e
                }
                constructor(e = a) {
                    this.timestampProducer = e, this.startTime = void 0, this.timePassed = 0
                }
            }

            function l(e) {
                let t = "number" == typeof e ? e : e.asMilliseconds();
                return new Promise(e => {
                    setTimeout(() => e(), t)
                })
            }
        },
        631734: function(e, t, n) {
            "use strict";
            n.r(t), n.d(t, {
                default: function() {
                    return i
                }
            }), n("70102");
            var i = class e extends Error {
                constructor(e, t) {
                    super(t), this.code = e, this.message = t, this.name = "RPCError"
                }
            }
        },
        411916: function(e, t, n) {
            "use strict";
            var i, s;
            n.r(t), n.d(t, {
                DesignIds: function() {
                    return i
                }
            }), (s = i || (i = {}))[s.CLASSIC_IA = 0] = "CLASSIC_IA", s[s.DESIGN_IA = 1] = "DESIGN_IA", s[s.DESIGN_TABS_IA = 2] = "DESIGN_TABS_IA"
        },
        561467: function(e, t, n) {
            "use strict";
            var i, s;
            n.r(t), n.d(t, {
                Notifications: function() {
                    return i
                }
            }), (s = i || (i = {}))[s.StreamNotificationsGuildMaxSize = 50] = "StreamNotificationsGuildMaxSize"
        },
        53452: function(e, t, n) {
            "use strict";
            n.r(t), n.d(t, {
                IS_APP_COMPATIBLE_BROWSER: function() {
                    return l
                },
                BROWSER_SUPPORTS_VOICE: function() {
                    return u
                },
                BROWSER_SUPPORTS_VIDEO: function() {
                    return d
                },
                BROWSER_SUPPORTS_UNIFIED_PLAN: function() {
                    return c
                },
                BROWSER_SUPPORTS_DIAGNOSTICS: function() {
                    return h
                },
                BROWSER_SUPPORTS_CONNECTION_STATE: function() {
                    return p
                }
            });
            var i, s = n("383536"),
                a = n.n(s);
            let o = parseInt(null !== (i = a.version) && void 0 !== i ? i : "0", 10),
                r = void 0 !== a.ua && a.ua.indexOf("OculusBrowser") > -1,
                l = (() => {
                    if (null == window.WebSocket) return !1;
                    switch (a.name) {
                        case "IE":
                        case "Microsoft Edge":
                            return o >= 15;
                        default:
                            return !0
                    }
                })(),
                u = r || "Firefox" === a.name && o >= 80 || "Chrome" === a.name && o >= 37 || "Opera" === a.name && o >= 66 || "Node.js" === a.name && o >= 6 || "Electron" === a.name && o >= 1 || "Safari" === a.name && o >= 13 || "Microsoft Edge" === a.name && o >= 37,
                d = "Chrome" === a.name || "Safari" === a.name || "Firefox" === a.name && o >= 80 || "Opera" === a.name || "Microsoft Edge" === a.name,
                c = r || "Firefox" === a.name && o >= 73 || "Safari" === a.name && o >= 13 || "Chrome" === a.name && o >= 80 || "Microsoft Edge" === a.name && o >= 80,
                h = "Chrome" === a.name && o >= 58 || "Safari" === a.name && o >= 15 || "Firefox" === a.name && o >= 108,
                p = "Chrome" === a.name && o >= 72 || "Safari" === a.name && o >= 11 || "Opera" === a.name && o >= 60 || "Microsoft Edge" === a.name && o >= 79
        },
        595275: function(e, t, n) {
            "use strict";
            n.r(t), n.d(t, {
                default: function() {
                    return i
                }
            }), n("222007");
            var i, s = n("44170");
            i = class {
                on(e, t) {
                    this.emitter.on(e, t)
                }
                off(e, t) {
                    this.emitter.off(e, t)
                }
                once(e, t) {
                    this.emitter.once(e, t)
                }
                addListener(e, t) {
                    this.emitter.addListener(e, t)
                }
                removeListener(e, t) {
                    this.emitter.removeListener(e, t)
                }
                removeAllListeners() {
                    this.emitter.removeAllListeners()
                }
                emit(e) {
                    for (var t = arguments.length, n = Array(t > 1 ? t - 1 : 0), i = 1; i < t; i++) n[i - 1] = arguments[i];
                    this.emitter.emit(e, ...n)
                }
                emitUnsafe(e) {
                    for (var t = arguments.length, n = Array(t > 1 ? t - 1 : 0), i = 1; i < t; i++) n[i - 1] = arguments[i];
                    this.emitter.emit(e, ...n)
                }
                listenerCount(e) {
                    return this.emitter.listenerCount(e)
                }
                constructor() {
                    this.emitter = new s.EventEmitter
                }
            }
        }
    }
]);